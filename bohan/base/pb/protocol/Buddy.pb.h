// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Buddy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Buddy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Buddy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "BaseDefine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Buddy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Buddy_2eproto {
  static const uint32_t offsets[];
};
namespace Bohan {
namespace Buddy {
class AllUserReq;
struct AllUserReqDefaultTypeInternal;
extern AllUserReqDefaultTypeInternal _AllUserReq_default_instance_;
class AllUserRsp;
struct AllUserRspDefaultTypeInternal;
extern AllUserRspDefaultTypeInternal _AllUserRsp_default_instance_;
class ChangeAvatarReq;
struct ChangeAvatarReqDefaultTypeInternal;
extern ChangeAvatarReqDefaultTypeInternal _ChangeAvatarReq_default_instance_;
class ChangeAvatarRsp;
struct ChangeAvatarRspDefaultTypeInternal;
extern ChangeAvatarRspDefaultTypeInternal _ChangeAvatarRsp_default_instance_;
class DepartmentReq;
struct DepartmentReqDefaultTypeInternal;
extern DepartmentReqDefaultTypeInternal _DepartmentReq_default_instance_;
class DepartmentRsp;
struct DepartmentRspDefaultTypeInternal;
extern DepartmentRspDefaultTypeInternal _DepartmentRsp_default_instance_;
class PCLoginStatusNotify;
struct PCLoginStatusNotifyDefaultTypeInternal;
extern PCLoginStatusNotifyDefaultTypeInternal _PCLoginStatusNotify_default_instance_;
class RecentContactSessionReq;
struct RecentContactSessionReqDefaultTypeInternal;
extern RecentContactSessionReqDefaultTypeInternal _RecentContactSessionReq_default_instance_;
class RecentContactSessionRsp;
struct RecentContactSessionRspDefaultTypeInternal;
extern RecentContactSessionRspDefaultTypeInternal _RecentContactSessionRsp_default_instance_;
class RemoveSessionNotify;
struct RemoveSessionNotifyDefaultTypeInternal;
extern RemoveSessionNotifyDefaultTypeInternal _RemoveSessionNotify_default_instance_;
class RemoveSessionReq;
struct RemoveSessionReqDefaultTypeInternal;
extern RemoveSessionReqDefaultTypeInternal _RemoveSessionReq_default_instance_;
class RemoveSessionRsp;
struct RemoveSessionRspDefaultTypeInternal;
extern RemoveSessionRspDefaultTypeInternal _RemoveSessionRsp_default_instance_;
class UserStatNotify;
struct UserStatNotifyDefaultTypeInternal;
extern UserStatNotifyDefaultTypeInternal _UserStatNotify_default_instance_;
class UsersInfoReq;
struct UsersInfoReqDefaultTypeInternal;
extern UsersInfoReqDefaultTypeInternal _UsersInfoReq_default_instance_;
class UsersInfoRsp;
struct UsersInfoRspDefaultTypeInternal;
extern UsersInfoRspDefaultTypeInternal _UsersInfoRsp_default_instance_;
class UsersStatReq;
struct UsersStatReqDefaultTypeInternal;
extern UsersStatReqDefaultTypeInternal _UsersStatReq_default_instance_;
class UsersStatRsp;
struct UsersStatRspDefaultTypeInternal;
extern UsersStatRspDefaultTypeInternal _UsersStatRsp_default_instance_;
}  // namespace Buddy
}  // namespace Bohan
PROTOBUF_NAMESPACE_OPEN
template<> ::Bohan::Buddy::AllUserReq* Arena::CreateMaybeMessage<::Bohan::Buddy::AllUserReq>(Arena*);
template<> ::Bohan::Buddy::AllUserRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::AllUserRsp>(Arena*);
template<> ::Bohan::Buddy::ChangeAvatarReq* Arena::CreateMaybeMessage<::Bohan::Buddy::ChangeAvatarReq>(Arena*);
template<> ::Bohan::Buddy::ChangeAvatarRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::ChangeAvatarRsp>(Arena*);
template<> ::Bohan::Buddy::DepartmentReq* Arena::CreateMaybeMessage<::Bohan::Buddy::DepartmentReq>(Arena*);
template<> ::Bohan::Buddy::DepartmentRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::DepartmentRsp>(Arena*);
template<> ::Bohan::Buddy::PCLoginStatusNotify* Arena::CreateMaybeMessage<::Bohan::Buddy::PCLoginStatusNotify>(Arena*);
template<> ::Bohan::Buddy::RecentContactSessionReq* Arena::CreateMaybeMessage<::Bohan::Buddy::RecentContactSessionReq>(Arena*);
template<> ::Bohan::Buddy::RecentContactSessionRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::RecentContactSessionRsp>(Arena*);
template<> ::Bohan::Buddy::RemoveSessionNotify* Arena::CreateMaybeMessage<::Bohan::Buddy::RemoveSessionNotify>(Arena*);
template<> ::Bohan::Buddy::RemoveSessionReq* Arena::CreateMaybeMessage<::Bohan::Buddy::RemoveSessionReq>(Arena*);
template<> ::Bohan::Buddy::RemoveSessionRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::RemoveSessionRsp>(Arena*);
template<> ::Bohan::Buddy::UserStatNotify* Arena::CreateMaybeMessage<::Bohan::Buddy::UserStatNotify>(Arena*);
template<> ::Bohan::Buddy::UsersInfoReq* Arena::CreateMaybeMessage<::Bohan::Buddy::UsersInfoReq>(Arena*);
template<> ::Bohan::Buddy::UsersInfoRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::UsersInfoRsp>(Arena*);
template<> ::Bohan::Buddy::UsersStatReq* Arena::CreateMaybeMessage<::Bohan::Buddy::UsersStatReq>(Arena*);
template<> ::Bohan::Buddy::UsersStatRsp* Arena::CreateMaybeMessage<::Bohan::Buddy::UsersStatRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Bohan {
namespace Buddy {

// ===================================================================

class RecentContactSessionReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.RecentContactSessionReq) */ {
 public:
  inline RecentContactSessionReq() : RecentContactSessionReq(nullptr) {}
  ~RecentContactSessionReq() override;
  explicit PROTOBUF_CONSTEXPR RecentContactSessionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecentContactSessionReq(const RecentContactSessionReq& from);
  RecentContactSessionReq(RecentContactSessionReq&& from) noexcept
    : RecentContactSessionReq() {
    *this = ::std::move(from);
  }

  inline RecentContactSessionReq& operator=(const RecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecentContactSessionReq& operator=(RecentContactSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RecentContactSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecentContactSessionReq* internal_default_instance() {
    return reinterpret_cast<const RecentContactSessionReq*>(
               &_RecentContactSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RecentContactSessionReq& a, RecentContactSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RecentContactSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecentContactSessionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecentContactSessionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecentContactSessionReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecentContactSessionReq& from);
  void MergeFrom(const RecentContactSessionReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecentContactSessionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.RecentContactSessionReq";
  }
  protected:
  explicit RecentContactSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kLatestUpdateTimeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 latest_update_time = 2;
  bool has_latest_update_time() const;
  private:
  bool _internal_has_latest_update_time() const;
  public:
  void clear_latest_update_time();
  uint32_t latest_update_time() const;
  void set_latest_update_time(uint32_t value);
  private:
  uint32_t _internal_latest_update_time() const;
  void _internal_set_latest_update_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.RecentContactSessionReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t latest_update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class RecentContactSessionRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.RecentContactSessionRsp) */ {
 public:
  inline RecentContactSessionRsp() : RecentContactSessionRsp(nullptr) {}
  ~RecentContactSessionRsp() override;
  explicit PROTOBUF_CONSTEXPR RecentContactSessionRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecentContactSessionRsp(const RecentContactSessionRsp& from);
  RecentContactSessionRsp(RecentContactSessionRsp&& from) noexcept
    : RecentContactSessionRsp() {
    *this = ::std::move(from);
  }

  inline RecentContactSessionRsp& operator=(const RecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecentContactSessionRsp& operator=(RecentContactSessionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RecentContactSessionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecentContactSessionRsp* internal_default_instance() {
    return reinterpret_cast<const RecentContactSessionRsp*>(
               &_RecentContactSessionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecentContactSessionRsp& a, RecentContactSessionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(RecentContactSessionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecentContactSessionRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecentContactSessionRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecentContactSessionRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecentContactSessionRsp& from);
  void MergeFrom(const RecentContactSessionRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecentContactSessionRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.RecentContactSessionRsp";
  }
  protected:
  explicit RecentContactSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactSessionListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated .Bohan.BaseDefine.ContactSessionInfo contact_session_list = 2;
  int contact_session_list_size() const;
  private:
  int _internal_contact_session_list_size() const;
  public:
  void clear_contact_session_list();
  ::Bohan::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();
  private:
  const ::Bohan::BaseDefine::ContactSessionInfo& _internal_contact_session_list(int index) const;
  ::Bohan::BaseDefine::ContactSessionInfo* _internal_add_contact_session_list();
  public:
  const ::Bohan::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  ::Bohan::BaseDefine::ContactSessionInfo* add_contact_session_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.RecentContactSessionRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::ContactSessionInfo > contact_session_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class UserStatNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.UserStatNotify) */ {
 public:
  inline UserStatNotify() : UserStatNotify(nullptr) {}
  ~UserStatNotify() override;
  explicit PROTOBUF_CONSTEXPR UserStatNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStatNotify(const UserStatNotify& from);
  UserStatNotify(UserStatNotify&& from) noexcept
    : UserStatNotify() {
    *this = ::std::move(from);
  }

  inline UserStatNotify& operator=(const UserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStatNotify& operator=(UserStatNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserStatNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStatNotify* internal_default_instance() {
    return reinterpret_cast<const UserStatNotify*>(
               &_UserStatNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserStatNotify& a, UserStatNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStatNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStatNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStatNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStatNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserStatNotify& from);
  void MergeFrom(const UserStatNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStatNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.UserStatNotify";
  }
  protected:
  explicit UserStatNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserStatFieldNumber = 1,
  };
  // required .Bohan.BaseDefine.UserStat user_stat = 1;
  bool has_user_stat() const;
  private:
  bool _internal_has_user_stat() const;
  public:
  void clear_user_stat();
  const ::Bohan::BaseDefine::UserStat& user_stat() const;
  PROTOBUF_NODISCARD ::Bohan::BaseDefine::UserStat* release_user_stat();
  ::Bohan::BaseDefine::UserStat* mutable_user_stat();
  void set_allocated_user_stat(::Bohan::BaseDefine::UserStat* user_stat);
  private:
  const ::Bohan::BaseDefine::UserStat& _internal_user_stat() const;
  ::Bohan::BaseDefine::UserStat* _internal_mutable_user_stat();
  public:
  void unsafe_arena_set_allocated_user_stat(
      ::Bohan::BaseDefine::UserStat* user_stat);
  ::Bohan::BaseDefine::UserStat* unsafe_arena_release_user_stat();

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.UserStatNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Bohan::BaseDefine::UserStat* user_stat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class UsersInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.UsersInfoReq) */ {
 public:
  inline UsersInfoReq() : UsersInfoReq(nullptr) {}
  ~UsersInfoReq() override;
  explicit PROTOBUF_CONSTEXPR UsersInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersInfoReq(const UsersInfoReq& from);
  UsersInfoReq(UsersInfoReq&& from) noexcept
    : UsersInfoReq() {
    *this = ::std::move(from);
  }

  inline UsersInfoReq& operator=(const UsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersInfoReq& operator=(UsersInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsersInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersInfoReq* internal_default_instance() {
    return reinterpret_cast<const UsersInfoReq*>(
               &_UsersInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UsersInfoReq& a, UsersInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersInfoReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsersInfoReq& from);
  void MergeFrom(const UsersInfoReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsersInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.UsersInfoReq";
  }
  protected:
  explicit UsersInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated uint32 user_id_list = 2;
  int user_id_list_size() const;
  private:
  int _internal_user_id_list_size() const;
  public:
  void clear_user_id_list();
  private:
  uint32_t _internal_user_id_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_user_id_list() const;
  void _internal_add_user_id_list(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_user_id_list();
  public:
  uint32_t user_id_list(int index) const;
  void set_user_id_list(int index, uint32_t value);
  void add_user_id_list(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      user_id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.UsersInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > user_id_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class UsersInfoRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.UsersInfoRsp) */ {
 public:
  inline UsersInfoRsp() : UsersInfoRsp(nullptr) {}
  ~UsersInfoRsp() override;
  explicit PROTOBUF_CONSTEXPR UsersInfoRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersInfoRsp(const UsersInfoRsp& from);
  UsersInfoRsp(UsersInfoRsp&& from) noexcept
    : UsersInfoRsp() {
    *this = ::std::move(from);
  }

  inline UsersInfoRsp& operator=(const UsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersInfoRsp& operator=(UsersInfoRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsersInfoRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersInfoRsp* internal_default_instance() {
    return reinterpret_cast<const UsersInfoRsp*>(
               &_UsersInfoRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UsersInfoRsp& a, UsersInfoRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersInfoRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersInfoRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersInfoRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersInfoRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsersInfoRsp& from);
  void MergeFrom(const UsersInfoRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsersInfoRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.UsersInfoRsp";
  }
  protected:
  explicit UsersInfoRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated .Bohan.BaseDefine.UserInfo user_info_list = 2;
  int user_info_list_size() const;
  private:
  int _internal_user_info_list_size() const;
  public:
  void clear_user_info_list();
  ::Bohan::BaseDefine::UserInfo* mutable_user_info_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >*
      mutable_user_info_list();
  private:
  const ::Bohan::BaseDefine::UserInfo& _internal_user_info_list(int index) const;
  ::Bohan::BaseDefine::UserInfo* _internal_add_user_info_list();
  public:
  const ::Bohan::BaseDefine::UserInfo& user_info_list(int index) const;
  ::Bohan::BaseDefine::UserInfo* add_user_info_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >&
      user_info_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.UsersInfoRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo > user_info_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class RemoveSessionReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.RemoveSessionReq) */ {
 public:
  inline RemoveSessionReq() : RemoveSessionReq(nullptr) {}
  ~RemoveSessionReq() override;
  explicit PROTOBUF_CONSTEXPR RemoveSessionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSessionReq(const RemoveSessionReq& from);
  RemoveSessionReq(RemoveSessionReq&& from) noexcept
    : RemoveSessionReq() {
    *this = ::std::move(from);
  }

  inline RemoveSessionReq& operator=(const RemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSessionReq& operator=(RemoveSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoveSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSessionReq* internal_default_instance() {
    return reinterpret_cast<const RemoveSessionReq*>(
               &_RemoveSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RemoveSessionReq& a, RemoveSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSessionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSessionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSessionReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoveSessionReq& from);
  void MergeFrom(const RemoveSessionReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoveSessionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.RemoveSessionReq";
  }
  protected:
  explicit RemoveSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kSessionTypeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.RemoveSessionReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class RemoveSessionRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.RemoveSessionRsp) */ {
 public:
  inline RemoveSessionRsp() : RemoveSessionRsp(nullptr) {}
  ~RemoveSessionRsp() override;
  explicit PROTOBUF_CONSTEXPR RemoveSessionRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSessionRsp(const RemoveSessionRsp& from);
  RemoveSessionRsp(RemoveSessionRsp&& from) noexcept
    : RemoveSessionRsp() {
    *this = ::std::move(from);
  }

  inline RemoveSessionRsp& operator=(const RemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSessionRsp& operator=(RemoveSessionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoveSessionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSessionRsp* internal_default_instance() {
    return reinterpret_cast<const RemoveSessionRsp*>(
               &_RemoveSessionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RemoveSessionRsp& a, RemoveSessionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSessionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSessionRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSessionRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSessionRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoveSessionRsp& from);
  void MergeFrom(const RemoveSessionRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoveSessionRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.RemoveSessionRsp";
  }
  protected:
  explicit RemoveSessionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kResultCodeFieldNumber = 2,
    kSessionIdFieldNumber = 4,
    kSessionTypeFieldNumber = 3,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result_code = 2;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // required uint32 session_id = 4;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 3;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.RemoveSessionRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t result_code_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class AllUserReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.AllUserReq) */ {
 public:
  inline AllUserReq() : AllUserReq(nullptr) {}
  ~AllUserReq() override;
  explicit PROTOBUF_CONSTEXPR AllUserReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllUserReq(const AllUserReq& from);
  AllUserReq(AllUserReq&& from) noexcept
    : AllUserReq() {
    *this = ::std::move(from);
  }

  inline AllUserReq& operator=(const AllUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllUserReq& operator=(AllUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllUserReq* internal_default_instance() {
    return reinterpret_cast<const AllUserReq*>(
               &_AllUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AllUserReq& a, AllUserReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AllUserReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllUserReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllUserReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllUserReq& from);
  void MergeFrom(const AllUserReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllUserReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.AllUserReq";
  }
  protected:
  explicit AllUserReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kLatestUpdateTimeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 latest_update_time = 2;
  bool has_latest_update_time() const;
  private:
  bool _internal_has_latest_update_time() const;
  public:
  void clear_latest_update_time();
  uint32_t latest_update_time() const;
  void set_latest_update_time(uint32_t value);
  private:
  uint32_t _internal_latest_update_time() const;
  void _internal_set_latest_update_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.AllUserReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t latest_update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class AllUserRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.AllUserRsp) */ {
 public:
  inline AllUserRsp() : AllUserRsp(nullptr) {}
  ~AllUserRsp() override;
  explicit PROTOBUF_CONSTEXPR AllUserRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllUserRsp(const AllUserRsp& from);
  AllUserRsp(AllUserRsp&& from) noexcept
    : AllUserRsp() {
    *this = ::std::move(from);
  }

  inline AllUserRsp& operator=(const AllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllUserRsp& operator=(AllUserRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AllUserRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllUserRsp* internal_default_instance() {
    return reinterpret_cast<const AllUserRsp*>(
               &_AllUserRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AllUserRsp& a, AllUserRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(AllUserRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllUserRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllUserRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllUserRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AllUserRsp& from);
  void MergeFrom(const AllUserRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllUserRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.AllUserRsp";
  }
  protected:
  explicit AllUserRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserListFieldNumber = 3,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kLatestUpdateTimeFieldNumber = 2,
  };
  // repeated .Bohan.BaseDefine.UserInfo user_list = 3;
  int user_list_size() const;
  private:
  int _internal_user_list_size() const;
  public:
  void clear_user_list();
  ::Bohan::BaseDefine::UserInfo* mutable_user_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >*
      mutable_user_list();
  private:
  const ::Bohan::BaseDefine::UserInfo& _internal_user_list(int index) const;
  ::Bohan::BaseDefine::UserInfo* _internal_add_user_list();
  public:
  const ::Bohan::BaseDefine::UserInfo& user_list(int index) const;
  ::Bohan::BaseDefine::UserInfo* add_user_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >&
      user_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 latest_update_time = 2;
  bool has_latest_update_time() const;
  private:
  bool _internal_has_latest_update_time() const;
  public:
  void clear_latest_update_time();
  uint32_t latest_update_time() const;
  void set_latest_update_time(uint32_t value);
  private:
  uint32_t _internal_latest_update_time() const;
  void _internal_set_latest_update_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.AllUserRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo > user_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t latest_update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class UsersStatReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.UsersStatReq) */ {
 public:
  inline UsersStatReq() : UsersStatReq(nullptr) {}
  ~UsersStatReq() override;
  explicit PROTOBUF_CONSTEXPR UsersStatReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersStatReq(const UsersStatReq& from);
  UsersStatReq(UsersStatReq&& from) noexcept
    : UsersStatReq() {
    *this = ::std::move(from);
  }

  inline UsersStatReq& operator=(const UsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersStatReq& operator=(UsersStatReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsersStatReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersStatReq* internal_default_instance() {
    return reinterpret_cast<const UsersStatReq*>(
               &_UsersStatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UsersStatReq& a, UsersStatReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersStatReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersStatReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersStatReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersStatReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsersStatReq& from);
  void MergeFrom(const UsersStatReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsersStatReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.UsersStatReq";
  }
  protected:
  explicit UsersStatReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated uint32 user_id_list = 2;
  int user_id_list_size() const;
  private:
  int _internal_user_id_list_size() const;
  public:
  void clear_user_id_list();
  private:
  uint32_t _internal_user_id_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_user_id_list() const;
  void _internal_add_user_id_list(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_user_id_list();
  public:
  uint32_t user_id_list(int index) const;
  void set_user_id_list(int index, uint32_t value);
  void add_user_id_list(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      user_id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.UsersStatReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > user_id_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class UsersStatRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.UsersStatRsp) */ {
 public:
  inline UsersStatRsp() : UsersStatRsp(nullptr) {}
  ~UsersStatRsp() override;
  explicit PROTOBUF_CONSTEXPR UsersStatRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersStatRsp(const UsersStatRsp& from);
  UsersStatRsp(UsersStatRsp&& from) noexcept
    : UsersStatRsp() {
    *this = ::std::move(from);
  }

  inline UsersStatRsp& operator=(const UsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersStatRsp& operator=(UsersStatRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UsersStatRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersStatRsp* internal_default_instance() {
    return reinterpret_cast<const UsersStatRsp*>(
               &_UsersStatRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UsersStatRsp& a, UsersStatRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersStatRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersStatRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersStatRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersStatRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UsersStatRsp& from);
  void MergeFrom(const UsersStatRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UsersStatRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.UsersStatRsp";
  }
  protected:
  explicit UsersStatRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserStatListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // repeated .Bohan.BaseDefine.UserStat user_stat_list = 2;
  int user_stat_list_size() const;
  private:
  int _internal_user_stat_list_size() const;
  public:
  void clear_user_stat_list();
  ::Bohan::BaseDefine::UserStat* mutable_user_stat_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserStat >*
      mutable_user_stat_list();
  private:
  const ::Bohan::BaseDefine::UserStat& _internal_user_stat_list(int index) const;
  ::Bohan::BaseDefine::UserStat* _internal_add_user_stat_list();
  public:
  const ::Bohan::BaseDefine::UserStat& user_stat_list(int index) const;
  ::Bohan::BaseDefine::UserStat* add_user_stat_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserStat >&
      user_stat_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.UsersStatRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserStat > user_stat_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class ChangeAvatarReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.ChangeAvatarReq) */ {
 public:
  inline ChangeAvatarReq() : ChangeAvatarReq(nullptr) {}
  ~ChangeAvatarReq() override;
  explicit PROTOBUF_CONSTEXPR ChangeAvatarReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeAvatarReq(const ChangeAvatarReq& from);
  ChangeAvatarReq(ChangeAvatarReq&& from) noexcept
    : ChangeAvatarReq() {
    *this = ::std::move(from);
  }

  inline ChangeAvatarReq& operator=(const ChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeAvatarReq& operator=(ChangeAvatarReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChangeAvatarReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeAvatarReq* internal_default_instance() {
    return reinterpret_cast<const ChangeAvatarReq*>(
               &_ChangeAvatarReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChangeAvatarReq& a, ChangeAvatarReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeAvatarReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeAvatarReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeAvatarReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeAvatarReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChangeAvatarReq& from);
  void MergeFrom(const ChangeAvatarReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeAvatarReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.ChangeAvatarReq";
  }
  protected:
  explicit ChangeAvatarReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvatarUrlFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // required string avatar_url = 2;
  bool has_avatar_url() const;
  private:
  bool _internal_has_avatar_url() const;
  public:
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.ChangeAvatarReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class ChangeAvatarRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.ChangeAvatarRsp) */ {
 public:
  inline ChangeAvatarRsp() : ChangeAvatarRsp(nullptr) {}
  ~ChangeAvatarRsp() override;
  explicit PROTOBUF_CONSTEXPR ChangeAvatarRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeAvatarRsp(const ChangeAvatarRsp& from);
  ChangeAvatarRsp(ChangeAvatarRsp&& from) noexcept
    : ChangeAvatarRsp() {
    *this = ::std::move(from);
  }

  inline ChangeAvatarRsp& operator=(const ChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeAvatarRsp& operator=(ChangeAvatarRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChangeAvatarRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeAvatarRsp* internal_default_instance() {
    return reinterpret_cast<const ChangeAvatarRsp*>(
               &_ChangeAvatarRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChangeAvatarRsp& a, ChangeAvatarRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeAvatarRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeAvatarRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeAvatarRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeAvatarRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChangeAvatarRsp& from);
  void MergeFrom(const ChangeAvatarRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeAvatarRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.ChangeAvatarRsp";
  }
  protected:
  explicit ChangeAvatarRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kResultCodeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result_code = 2;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.ChangeAvatarRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t result_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class PCLoginStatusNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.PCLoginStatusNotify) */ {
 public:
  inline PCLoginStatusNotify() : PCLoginStatusNotify(nullptr) {}
  ~PCLoginStatusNotify() override;
  explicit PROTOBUF_CONSTEXPR PCLoginStatusNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCLoginStatusNotify(const PCLoginStatusNotify& from);
  PCLoginStatusNotify(PCLoginStatusNotify&& from) noexcept
    : PCLoginStatusNotify() {
    *this = ::std::move(from);
  }

  inline PCLoginStatusNotify& operator=(const PCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCLoginStatusNotify& operator=(PCLoginStatusNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PCLoginStatusNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCLoginStatusNotify* internal_default_instance() {
    return reinterpret_cast<const PCLoginStatusNotify*>(
               &_PCLoginStatusNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PCLoginStatusNotify& a, PCLoginStatusNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(PCLoginStatusNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCLoginStatusNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCLoginStatusNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCLoginStatusNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PCLoginStatusNotify& from);
  void MergeFrom(const PCLoginStatusNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PCLoginStatusNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.PCLoginStatusNotify";
  }
  protected:
  explicit PCLoginStatusNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kLoginStatFieldNumber = 2,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.UserStatType login_stat = 2;
  bool has_login_stat() const;
  private:
  bool _internal_has_login_stat() const;
  public:
  void clear_login_stat();
  ::Bohan::BaseDefine::UserStatType login_stat() const;
  void set_login_stat(::Bohan::BaseDefine::UserStatType value);
  private:
  ::Bohan::BaseDefine::UserStatType _internal_login_stat() const;
  void _internal_set_login_stat(::Bohan::BaseDefine::UserStatType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.PCLoginStatusNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    int login_stat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class RemoveSessionNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.RemoveSessionNotify) */ {
 public:
  inline RemoveSessionNotify() : RemoveSessionNotify(nullptr) {}
  ~RemoveSessionNotify() override;
  explicit PROTOBUF_CONSTEXPR RemoveSessionNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSessionNotify(const RemoveSessionNotify& from);
  RemoveSessionNotify(RemoveSessionNotify&& from) noexcept
    : RemoveSessionNotify() {
    *this = ::std::move(from);
  }

  inline RemoveSessionNotify& operator=(const RemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSessionNotify& operator=(RemoveSessionNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoveSessionNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSessionNotify* internal_default_instance() {
    return reinterpret_cast<const RemoveSessionNotify*>(
               &_RemoveSessionNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RemoveSessionNotify& a, RemoveSessionNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSessionNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSessionNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSessionNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSessionNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RemoveSessionNotify& from);
  void MergeFrom(const RemoveSessionNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemoveSessionNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.RemoveSessionNotify";
  }
  protected:
  explicit RemoveSessionNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kSessionTypeFieldNumber = 2,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.RemoveSessionNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class DepartmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.DepartmentReq) */ {
 public:
  inline DepartmentReq() : DepartmentReq(nullptr) {}
  ~DepartmentReq() override;
  explicit PROTOBUF_CONSTEXPR DepartmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepartmentReq(const DepartmentReq& from);
  DepartmentReq(DepartmentReq&& from) noexcept
    : DepartmentReq() {
    *this = ::std::move(from);
  }

  inline DepartmentReq& operator=(const DepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepartmentReq& operator=(DepartmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DepartmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepartmentReq* internal_default_instance() {
    return reinterpret_cast<const DepartmentReq*>(
               &_DepartmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DepartmentReq& a, DepartmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DepartmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepartmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DepartmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DepartmentReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DepartmentReq& from);
  void MergeFrom(const DepartmentReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DepartmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.DepartmentReq";
  }
  protected:
  explicit DepartmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kLatestUpdateTimeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 latest_update_time = 2;
  bool has_latest_update_time() const;
  private:
  bool _internal_has_latest_update_time() const;
  public:
  void clear_latest_update_time();
  uint32_t latest_update_time() const;
  void set_latest_update_time(uint32_t value);
  private:
  uint32_t _internal_latest_update_time() const;
  void _internal_set_latest_update_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.DepartmentReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t latest_update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// -------------------------------------------------------------------

class DepartmentRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Buddy.DepartmentRsp) */ {
 public:
  inline DepartmentRsp() : DepartmentRsp(nullptr) {}
  ~DepartmentRsp() override;
  explicit PROTOBUF_CONSTEXPR DepartmentRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepartmentRsp(const DepartmentRsp& from);
  DepartmentRsp(DepartmentRsp&& from) noexcept
    : DepartmentRsp() {
    *this = ::std::move(from);
  }

  inline DepartmentRsp& operator=(const DepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepartmentRsp& operator=(DepartmentRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DepartmentRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepartmentRsp* internal_default_instance() {
    return reinterpret_cast<const DepartmentRsp*>(
               &_DepartmentRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DepartmentRsp& a, DepartmentRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(DepartmentRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepartmentRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DepartmentRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DepartmentRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DepartmentRsp& from);
  void MergeFrom(const DepartmentRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DepartmentRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Buddy.DepartmentRsp";
  }
  protected:
  explicit DepartmentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeptListFieldNumber = 3,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kLatestUpdateTimeFieldNumber = 2,
  };
  // repeated .Bohan.BaseDefine.DepartInfo dept_list = 3;
  int dept_list_size() const;
  private:
  int _internal_dept_list_size() const;
  public:
  void clear_dept_list();
  ::Bohan::BaseDefine::DepartInfo* mutable_dept_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::DepartInfo >*
      mutable_dept_list();
  private:
  const ::Bohan::BaseDefine::DepartInfo& _internal_dept_list(int index) const;
  ::Bohan::BaseDefine::DepartInfo* _internal_add_dept_list();
  public:
  const ::Bohan::BaseDefine::DepartInfo& dept_list(int index) const;
  ::Bohan::BaseDefine::DepartInfo* add_dept_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::DepartInfo >&
      dept_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 latest_update_time = 2;
  bool has_latest_update_time() const;
  private:
  bool _internal_has_latest_update_time() const;
  public:
  void clear_latest_update_time();
  uint32_t latest_update_time() const;
  void set_latest_update_time(uint32_t value);
  private:
  uint32_t _internal_latest_update_time() const;
  void _internal_set_latest_update_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Buddy.DepartmentRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::DepartInfo > dept_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t latest_update_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Buddy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecentContactSessionReq

// required uint32 user_id = 1;
inline bool RecentContactSessionReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RecentContactSessionReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void RecentContactSessionReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RecentContactSessionReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RecentContactSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionReq.user_id)
  return _internal_user_id();
}
inline void RecentContactSessionReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void RecentContactSessionReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RecentContactSessionReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool RecentContactSessionReq::_internal_has_latest_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RecentContactSessionReq::has_latest_update_time() const {
  return _internal_has_latest_update_time();
}
inline void RecentContactSessionReq::clear_latest_update_time() {
  _impl_.latest_update_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RecentContactSessionReq::_internal_latest_update_time() const {
  return _impl_.latest_update_time_;
}
inline uint32_t RecentContactSessionReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionReq.latest_update_time)
  return _internal_latest_update_time();
}
inline void RecentContactSessionReq::_internal_set_latest_update_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.latest_update_time_ = value;
}
inline void RecentContactSessionReq::set_latest_update_time(uint32_t value) {
  _internal_set_latest_update_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RecentContactSessionReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool RecentContactSessionReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecentContactSessionReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void RecentContactSessionReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecentContactSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecentContactSessionReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RecentContactSessionReq.attach_data)
}
inline std::string* RecentContactSessionReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.RecentContactSessionReq.attach_data)
  return _s;
}
inline const std::string& RecentContactSessionReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void RecentContactSessionReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RecentContactSessionReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RecentContactSessionReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.RecentContactSessionReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RecentContactSessionReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.RecentContactSessionReq.attach_data)
}

// -------------------------------------------------------------------

// RecentContactSessionRsp

// required uint32 user_id = 1;
inline bool RecentContactSessionRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RecentContactSessionRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void RecentContactSessionRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RecentContactSessionRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RecentContactSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionRsp.user_id)
  return _internal_user_id();
}
inline void RecentContactSessionRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void RecentContactSessionRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RecentContactSessionRsp.user_id)
}

// repeated .Bohan.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int RecentContactSessionRsp::_internal_contact_session_list_size() const {
  return _impl_.contact_session_list_.size();
}
inline int RecentContactSessionRsp::contact_session_list_size() const {
  return _internal_contact_session_list_size();
}
inline ::Bohan::BaseDefine::ContactSessionInfo* RecentContactSessionRsp::mutable_contact_session_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.RecentContactSessionRsp.contact_session_list)
  return _impl_.contact_session_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::ContactSessionInfo >*
RecentContactSessionRsp::mutable_contact_session_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.RecentContactSessionRsp.contact_session_list)
  return &_impl_.contact_session_list_;
}
inline const ::Bohan::BaseDefine::ContactSessionInfo& RecentContactSessionRsp::_internal_contact_session_list(int index) const {
  return _impl_.contact_session_list_.Get(index);
}
inline const ::Bohan::BaseDefine::ContactSessionInfo& RecentContactSessionRsp::contact_session_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionRsp.contact_session_list)
  return _internal_contact_session_list(index);
}
inline ::Bohan::BaseDefine::ContactSessionInfo* RecentContactSessionRsp::_internal_add_contact_session_list() {
  return _impl_.contact_session_list_.Add();
}
inline ::Bohan::BaseDefine::ContactSessionInfo* RecentContactSessionRsp::add_contact_session_list() {
  ::Bohan::BaseDefine::ContactSessionInfo* _add = _internal_add_contact_session_list();
  // @@protoc_insertion_point(field_add:Bohan.Buddy.RecentContactSessionRsp.contact_session_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::ContactSessionInfo >&
RecentContactSessionRsp::contact_session_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.RecentContactSessionRsp.contact_session_list)
  return _impl_.contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool RecentContactSessionRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecentContactSessionRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void RecentContactSessionRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecentContactSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RecentContactSessionRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecentContactSessionRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RecentContactSessionRsp.attach_data)
}
inline std::string* RecentContactSessionRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.RecentContactSessionRsp.attach_data)
  return _s;
}
inline const std::string& RecentContactSessionRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void RecentContactSessionRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RecentContactSessionRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RecentContactSessionRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.RecentContactSessionRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RecentContactSessionRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.RecentContactSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// UserStatNotify

// required .Bohan.BaseDefine.UserStat user_stat = 1;
inline bool UserStatNotify::_internal_has_user_stat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_stat_ != nullptr);
  return value;
}
inline bool UserStatNotify::has_user_stat() const {
  return _internal_has_user_stat();
}
inline const ::Bohan::BaseDefine::UserStat& UserStatNotify::_internal_user_stat() const {
  const ::Bohan::BaseDefine::UserStat* p = _impl_.user_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::Bohan::BaseDefine::UserStat&>(
      ::Bohan::BaseDefine::_UserStat_default_instance_);
}
inline const ::Bohan::BaseDefine::UserStat& UserStatNotify::user_stat() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UserStatNotify.user_stat)
  return _internal_user_stat();
}
inline void UserStatNotify::unsafe_arena_set_allocated_user_stat(
    ::Bohan::BaseDefine::UserStat* user_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_stat_);
  }
  _impl_.user_stat_ = user_stat;
  if (user_stat) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Bohan.Buddy.UserStatNotify.user_stat)
}
inline ::Bohan::BaseDefine::UserStat* UserStatNotify::release_user_stat() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Bohan::BaseDefine::UserStat* temp = _impl_.user_stat_;
  _impl_.user_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Bohan::BaseDefine::UserStat* UserStatNotify::unsafe_arena_release_user_stat() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.UserStatNotify.user_stat)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Bohan::BaseDefine::UserStat* temp = _impl_.user_stat_;
  _impl_.user_stat_ = nullptr;
  return temp;
}
inline ::Bohan::BaseDefine::UserStat* UserStatNotify::_internal_mutable_user_stat() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::Bohan::BaseDefine::UserStat>(GetArenaForAllocation());
    _impl_.user_stat_ = p;
  }
  return _impl_.user_stat_;
}
inline ::Bohan::BaseDefine::UserStat* UserStatNotify::mutable_user_stat() {
  ::Bohan::BaseDefine::UserStat* _msg = _internal_mutable_user_stat();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UserStatNotify.user_stat)
  return _msg;
}
inline void UserStatNotify::set_allocated_user_stat(::Bohan::BaseDefine::UserStat* user_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_stat_);
  }
  if (user_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_stat));
    if (message_arena != submessage_arena) {
      user_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_stat, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_stat_ = user_stat;
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.UserStatNotify.user_stat)
}

// -------------------------------------------------------------------

// UsersInfoReq

// required uint32 user_id = 1;
inline bool UsersInfoReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsersInfoReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UsersInfoReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UsersInfoReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoReq.user_id)
  return _internal_user_id();
}
inline void UsersInfoReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UsersInfoReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersInfoReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int UsersInfoReq::_internal_user_id_list_size() const {
  return _impl_.user_id_list_.size();
}
inline int UsersInfoReq::user_id_list_size() const {
  return _internal_user_id_list_size();
}
inline void UsersInfoReq::clear_user_id_list() {
  _impl_.user_id_list_.Clear();
}
inline uint32_t UsersInfoReq::_internal_user_id_list(int index) const {
  return _impl_.user_id_list_.Get(index);
}
inline uint32_t UsersInfoReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoReq.user_id_list)
  return _internal_user_id_list(index);
}
inline void UsersInfoReq::set_user_id_list(int index, uint32_t value) {
  _impl_.user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersInfoReq.user_id_list)
}
inline void UsersInfoReq::_internal_add_user_id_list(uint32_t value) {
  _impl_.user_id_list_.Add(value);
}
inline void UsersInfoReq::add_user_id_list(uint32_t value) {
  _internal_add_user_id_list(value);
  // @@protoc_insertion_point(field_add:Bohan.Buddy.UsersInfoReq.user_id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UsersInfoReq::_internal_user_id_list() const {
  return _impl_.user_id_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UsersInfoReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.UsersInfoReq.user_id_list)
  return _internal_user_id_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UsersInfoReq::_internal_mutable_user_id_list() {
  return &_impl_.user_id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UsersInfoReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.UsersInfoReq.user_id_list)
  return _internal_mutable_user_id_list();
}

// optional bytes attach_data = 20;
inline bool UsersInfoReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsersInfoReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UsersInfoReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersInfoReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersInfoReq.attach_data)
}
inline std::string* UsersInfoReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersInfoReq.attach_data)
  return _s;
}
inline const std::string& UsersInfoReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UsersInfoReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersInfoReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersInfoReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.UsersInfoReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UsersInfoReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.UsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// UsersInfoRsp

// required uint32 user_id = 1;
inline bool UsersInfoRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsersInfoRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UsersInfoRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UsersInfoRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoRsp.user_id)
  return _internal_user_id();
}
inline void UsersInfoRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UsersInfoRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersInfoRsp.user_id)
}

// repeated .Bohan.BaseDefine.UserInfo user_info_list = 2;
inline int UsersInfoRsp::_internal_user_info_list_size() const {
  return _impl_.user_info_list_.size();
}
inline int UsersInfoRsp::user_info_list_size() const {
  return _internal_user_info_list_size();
}
inline ::Bohan::BaseDefine::UserInfo* UsersInfoRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersInfoRsp.user_info_list)
  return _impl_.user_info_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >*
UsersInfoRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.UsersInfoRsp.user_info_list)
  return &_impl_.user_info_list_;
}
inline const ::Bohan::BaseDefine::UserInfo& UsersInfoRsp::_internal_user_info_list(int index) const {
  return _impl_.user_info_list_.Get(index);
}
inline const ::Bohan::BaseDefine::UserInfo& UsersInfoRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoRsp.user_info_list)
  return _internal_user_info_list(index);
}
inline ::Bohan::BaseDefine::UserInfo* UsersInfoRsp::_internal_add_user_info_list() {
  return _impl_.user_info_list_.Add();
}
inline ::Bohan::BaseDefine::UserInfo* UsersInfoRsp::add_user_info_list() {
  ::Bohan::BaseDefine::UserInfo* _add = _internal_add_user_info_list();
  // @@protoc_insertion_point(field_add:Bohan.Buddy.UsersInfoRsp.user_info_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >&
UsersInfoRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.UsersInfoRsp.user_info_list)
  return _impl_.user_info_list_;
}

// optional bytes attach_data = 20;
inline bool UsersInfoRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsersInfoRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UsersInfoRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersInfoRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersInfoRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersInfoRsp.attach_data)
}
inline std::string* UsersInfoRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersInfoRsp.attach_data)
  return _s;
}
inline const std::string& UsersInfoRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UsersInfoRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersInfoRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersInfoRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.UsersInfoRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UsersInfoRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.UsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// RemoveSessionReq

// required uint32 user_id = 1;
inline bool RemoveSessionReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveSessionReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void RemoveSessionReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveSessionReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RemoveSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionReq.user_id)
  return _internal_user_id();
}
inline void RemoveSessionReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void RemoveSessionReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionReq.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool RemoveSessionReq::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveSessionReq::has_session_type() const {
  return _internal_has_session_type();
}
inline void RemoveSessionReq::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionReq::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionReq::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionReq.session_type)
  return _internal_session_type();
}
inline void RemoveSessionReq::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void RemoveSessionReq::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionReq.session_type)
}

// required uint32 session_id = 3;
inline bool RemoveSessionReq::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveSessionReq::has_session_id() const {
  return _internal_has_session_id();
}
inline void RemoveSessionReq::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RemoveSessionReq::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t RemoveSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionReq.session_id)
  return _internal_session_id();
}
inline void RemoveSessionReq::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void RemoveSessionReq::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionReq.session_id)
}

// optional bytes attach_data = 20;
inline bool RemoveSessionReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoveSessionReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void RemoveSessionReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoveSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSessionReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionReq.attach_data)
}
inline std::string* RemoveSessionReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.RemoveSessionReq.attach_data)
  return _s;
}
inline const std::string& RemoveSessionReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void RemoveSessionReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSessionReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSessionReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.RemoveSessionReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoveSessionReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.RemoveSessionReq.attach_data)
}

// -------------------------------------------------------------------

// RemoveSessionRsp

// required uint32 user_id = 1;
inline bool RemoveSessionRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveSessionRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void RemoveSessionRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveSessionRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RemoveSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionRsp.user_id)
  return _internal_user_id();
}
inline void RemoveSessionRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void RemoveSessionRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionRsp.user_id)
}

// required uint32 result_code = 2;
inline bool RemoveSessionRsp::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveSessionRsp::has_result_code() const {
  return _internal_has_result_code();
}
inline void RemoveSessionRsp::clear_result_code() {
  _impl_.result_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RemoveSessionRsp::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t RemoveSessionRsp::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionRsp.result_code)
  return _internal_result_code();
}
inline void RemoveSessionRsp::_internal_set_result_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.result_code_ = value;
}
inline void RemoveSessionRsp::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionRsp.result_code)
}

// required .Bohan.BaseDefine.SessionType session_type = 3;
inline bool RemoveSessionRsp::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RemoveSessionRsp::has_session_type() const {
  return _internal_has_session_type();
}
inline void RemoveSessionRsp::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionRsp::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionRsp::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionRsp.session_type)
  return _internal_session_type();
}
inline void RemoveSessionRsp::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_type_ = value;
}
inline void RemoveSessionRsp::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionRsp.session_type)
}

// required uint32 session_id = 4;
inline bool RemoveSessionRsp::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemoveSessionRsp::has_session_id() const {
  return _internal_has_session_id();
}
inline void RemoveSessionRsp::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemoveSessionRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t RemoveSessionRsp::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionRsp.session_id)
  return _internal_session_id();
}
inline void RemoveSessionRsp::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_id_ = value;
}
inline void RemoveSessionRsp::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionRsp.session_id)
}

// optional bytes attach_data = 20;
inline bool RemoveSessionRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoveSessionRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void RemoveSessionRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoveSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSessionRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionRsp.attach_data)
}
inline std::string* RemoveSessionRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.RemoveSessionRsp.attach_data)
  return _s;
}
inline const std::string& RemoveSessionRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void RemoveSessionRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSessionRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSessionRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.RemoveSessionRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoveSessionRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.RemoveSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// AllUserReq

// required uint32 user_id = 1;
inline bool AllUserReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllUserReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void AllUserReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AllUserReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t AllUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserReq.user_id)
  return _internal_user_id();
}
inline void AllUserReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void AllUserReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool AllUserReq::_internal_has_latest_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllUserReq::has_latest_update_time() const {
  return _internal_has_latest_update_time();
}
inline void AllUserReq::clear_latest_update_time() {
  _impl_.latest_update_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AllUserReq::_internal_latest_update_time() const {
  return _impl_.latest_update_time_;
}
inline uint32_t AllUserReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserReq.latest_update_time)
  return _internal_latest_update_time();
}
inline void AllUserReq::_internal_set_latest_update_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.latest_update_time_ = value;
}
inline void AllUserReq::set_latest_update_time(uint32_t value) {
  _internal_set_latest_update_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool AllUserReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllUserReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void AllUserReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllUserReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserReq.attach_data)
}
inline std::string* AllUserReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.AllUserReq.attach_data)
  return _s;
}
inline const std::string& AllUserReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void AllUserReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* AllUserReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* AllUserReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.AllUserReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllUserReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.AllUserReq.attach_data)
}

// -------------------------------------------------------------------

// AllUserRsp

// required uint32 user_id = 1;
inline bool AllUserRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllUserRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void AllUserRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AllUserRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t AllUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserRsp.user_id)
  return _internal_user_id();
}
inline void AllUserRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void AllUserRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool AllUserRsp::_internal_has_latest_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllUserRsp::has_latest_update_time() const {
  return _internal_has_latest_update_time();
}
inline void AllUserRsp::clear_latest_update_time() {
  _impl_.latest_update_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AllUserRsp::_internal_latest_update_time() const {
  return _impl_.latest_update_time_;
}
inline uint32_t AllUserRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserRsp.latest_update_time)
  return _internal_latest_update_time();
}
inline void AllUserRsp::_internal_set_latest_update_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.latest_update_time_ = value;
}
inline void AllUserRsp::set_latest_update_time(uint32_t value) {
  _internal_set_latest_update_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserRsp.latest_update_time)
}

// repeated .Bohan.BaseDefine.UserInfo user_list = 3;
inline int AllUserRsp::_internal_user_list_size() const {
  return _impl_.user_list_.size();
}
inline int AllUserRsp::user_list_size() const {
  return _internal_user_list_size();
}
inline ::Bohan::BaseDefine::UserInfo* AllUserRsp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.AllUserRsp.user_list)
  return _impl_.user_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >*
AllUserRsp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.AllUserRsp.user_list)
  return &_impl_.user_list_;
}
inline const ::Bohan::BaseDefine::UserInfo& AllUserRsp::_internal_user_list(int index) const {
  return _impl_.user_list_.Get(index);
}
inline const ::Bohan::BaseDefine::UserInfo& AllUserRsp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserRsp.user_list)
  return _internal_user_list(index);
}
inline ::Bohan::BaseDefine::UserInfo* AllUserRsp::_internal_add_user_list() {
  return _impl_.user_list_.Add();
}
inline ::Bohan::BaseDefine::UserInfo* AllUserRsp::add_user_list() {
  ::Bohan::BaseDefine::UserInfo* _add = _internal_add_user_list();
  // @@protoc_insertion_point(field_add:Bohan.Buddy.AllUserRsp.user_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserInfo >&
AllUserRsp::user_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.AllUserRsp.user_list)
  return _impl_.user_list_;
}

// optional bytes attach_data = 20;
inline bool AllUserRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllUserRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void AllUserRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.AllUserRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllUserRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.AllUserRsp.attach_data)
}
inline std::string* AllUserRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.AllUserRsp.attach_data)
  return _s;
}
inline const std::string& AllUserRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void AllUserRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* AllUserRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* AllUserRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.AllUserRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllUserRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.AllUserRsp.attach_data)
}

// -------------------------------------------------------------------

// UsersStatReq

// required uint32 user_id = 1;
inline bool UsersStatReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsersStatReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UsersStatReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UsersStatReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UsersStatReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatReq.user_id)
  return _internal_user_id();
}
inline void UsersStatReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UsersStatReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersStatReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int UsersStatReq::_internal_user_id_list_size() const {
  return _impl_.user_id_list_.size();
}
inline int UsersStatReq::user_id_list_size() const {
  return _internal_user_id_list_size();
}
inline void UsersStatReq::clear_user_id_list() {
  _impl_.user_id_list_.Clear();
}
inline uint32_t UsersStatReq::_internal_user_id_list(int index) const {
  return _impl_.user_id_list_.Get(index);
}
inline uint32_t UsersStatReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatReq.user_id_list)
  return _internal_user_id_list(index);
}
inline void UsersStatReq::set_user_id_list(int index, uint32_t value) {
  _impl_.user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersStatReq.user_id_list)
}
inline void UsersStatReq::_internal_add_user_id_list(uint32_t value) {
  _impl_.user_id_list_.Add(value);
}
inline void UsersStatReq::add_user_id_list(uint32_t value) {
  _internal_add_user_id_list(value);
  // @@protoc_insertion_point(field_add:Bohan.Buddy.UsersStatReq.user_id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UsersStatReq::_internal_user_id_list() const {
  return _impl_.user_id_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UsersStatReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.UsersStatReq.user_id_list)
  return _internal_user_id_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UsersStatReq::_internal_mutable_user_id_list() {
  return &_impl_.user_id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UsersStatReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.UsersStatReq.user_id_list)
  return _internal_mutable_user_id_list();
}

// optional bytes attach_data = 20;
inline bool UsersStatReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsersStatReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UsersStatReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsersStatReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersStatReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersStatReq.attach_data)
}
inline std::string* UsersStatReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersStatReq.attach_data)
  return _s;
}
inline const std::string& UsersStatReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UsersStatReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersStatReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersStatReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.UsersStatReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UsersStatReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.UsersStatReq.attach_data)
}

// -------------------------------------------------------------------

// UsersStatRsp

// required uint32 user_id = 1;
inline bool UsersStatRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UsersStatRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UsersStatRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UsersStatRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UsersStatRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatRsp.user_id)
  return _internal_user_id();
}
inline void UsersStatRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UsersStatRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersStatRsp.user_id)
}

// repeated .Bohan.BaseDefine.UserStat user_stat_list = 2;
inline int UsersStatRsp::_internal_user_stat_list_size() const {
  return _impl_.user_stat_list_.size();
}
inline int UsersStatRsp::user_stat_list_size() const {
  return _internal_user_stat_list_size();
}
inline ::Bohan::BaseDefine::UserStat* UsersStatRsp::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersStatRsp.user_stat_list)
  return _impl_.user_stat_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserStat >*
UsersStatRsp::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.UsersStatRsp.user_stat_list)
  return &_impl_.user_stat_list_;
}
inline const ::Bohan::BaseDefine::UserStat& UsersStatRsp::_internal_user_stat_list(int index) const {
  return _impl_.user_stat_list_.Get(index);
}
inline const ::Bohan::BaseDefine::UserStat& UsersStatRsp::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatRsp.user_stat_list)
  return _internal_user_stat_list(index);
}
inline ::Bohan::BaseDefine::UserStat* UsersStatRsp::_internal_add_user_stat_list() {
  return _impl_.user_stat_list_.Add();
}
inline ::Bohan::BaseDefine::UserStat* UsersStatRsp::add_user_stat_list() {
  ::Bohan::BaseDefine::UserStat* _add = _internal_add_user_stat_list();
  // @@protoc_insertion_point(field_add:Bohan.Buddy.UsersStatRsp.user_stat_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UserStat >&
UsersStatRsp::user_stat_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.UsersStatRsp.user_stat_list)
  return _impl_.user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool UsersStatRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UsersStatRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UsersStatRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsersStatRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.UsersStatRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersStatRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.UsersStatRsp.attach_data)
}
inline std::string* UsersStatRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.UsersStatRsp.attach_data)
  return _s;
}
inline const std::string& UsersStatRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UsersStatRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersStatRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersStatRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.UsersStatRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UsersStatRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.UsersStatRsp.attach_data)
}

// -------------------------------------------------------------------

// ChangeAvatarReq

// required uint32 user_id = 1;
inline bool ChangeAvatarReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeAvatarReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void ChangeAvatarReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChangeAvatarReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t ChangeAvatarReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarReq.user_id)
  return _internal_user_id();
}
inline void ChangeAvatarReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_id_ = value;
}
inline void ChangeAvatarReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarReq.user_id)
}

// required string avatar_url = 2;
inline bool ChangeAvatarReq::_internal_has_avatar_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeAvatarReq::has_avatar_url() const {
  return _internal_has_avatar_url();
}
inline void ChangeAvatarReq::clear_avatar_url() {
  _impl_.avatar_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeAvatarReq::avatar_url() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarReq.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeAvatarReq::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarReq.avatar_url)
}
inline std::string* ChangeAvatarReq::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.ChangeAvatarReq.avatar_url)
  return _s;
}
inline const std::string& ChangeAvatarReq::_internal_avatar_url() const {
  return _impl_.avatar_url_.Get();
}
inline void ChangeAvatarReq::_internal_set_avatar_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeAvatarReq::_internal_mutable_avatar_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeAvatarReq::release_avatar_url() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.ChangeAvatarReq.avatar_url)
  if (!_internal_has_avatar_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.avatar_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeAvatarReq::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.ChangeAvatarReq.avatar_url)
}

// optional bytes attach_data = 20;
inline bool ChangeAvatarReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeAvatarReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void ChangeAvatarReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChangeAvatarReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeAvatarReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarReq.attach_data)
}
inline std::string* ChangeAvatarReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.ChangeAvatarReq.attach_data)
  return _s;
}
inline const std::string& ChangeAvatarReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void ChangeAvatarReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeAvatarReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeAvatarReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.ChangeAvatarReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeAvatarReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.ChangeAvatarReq.attach_data)
}

// -------------------------------------------------------------------

// ChangeAvatarRsp

// required uint32 user_id = 1;
inline bool ChangeAvatarRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeAvatarRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void ChangeAvatarRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChangeAvatarRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t ChangeAvatarRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarRsp.user_id)
  return _internal_user_id();
}
inline void ChangeAvatarRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void ChangeAvatarRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarRsp.user_id)
}

// required uint32 result_code = 2;
inline bool ChangeAvatarRsp::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeAvatarRsp::has_result_code() const {
  return _internal_has_result_code();
}
inline void ChangeAvatarRsp::clear_result_code() {
  _impl_.result_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChangeAvatarRsp::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t ChangeAvatarRsp::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarRsp.result_code)
  return _internal_result_code();
}
inline void ChangeAvatarRsp::_internal_set_result_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.result_code_ = value;
}
inline void ChangeAvatarRsp::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool ChangeAvatarRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeAvatarRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void ChangeAvatarRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeAvatarRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.ChangeAvatarRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeAvatarRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.ChangeAvatarRsp.attach_data)
}
inline std::string* ChangeAvatarRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.ChangeAvatarRsp.attach_data)
  return _s;
}
inline const std::string& ChangeAvatarRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void ChangeAvatarRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeAvatarRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeAvatarRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.ChangeAvatarRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeAvatarRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.ChangeAvatarRsp.attach_data)
}

// -------------------------------------------------------------------

// PCLoginStatusNotify

// required uint32 user_id = 1;
inline bool PCLoginStatusNotify::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PCLoginStatusNotify::has_user_id() const {
  return _internal_has_user_id();
}
inline void PCLoginStatusNotify::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t PCLoginStatusNotify::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t PCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.PCLoginStatusNotify.user_id)
  return _internal_user_id();
}
inline void PCLoginStatusNotify::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void PCLoginStatusNotify::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.PCLoginStatusNotify.user_id)
}

// required .Bohan.BaseDefine.UserStatType login_stat = 2;
inline bool PCLoginStatusNotify::_internal_has_login_stat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PCLoginStatusNotify::has_login_stat() const {
  return _internal_has_login_stat();
}
inline void PCLoginStatusNotify::clear_login_stat() {
  _impl_.login_stat_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Bohan::BaseDefine::UserStatType PCLoginStatusNotify::_internal_login_stat() const {
  return static_cast< ::Bohan::BaseDefine::UserStatType >(_impl_.login_stat_);
}
inline ::Bohan::BaseDefine::UserStatType PCLoginStatusNotify::login_stat() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.PCLoginStatusNotify.login_stat)
  return _internal_login_stat();
}
inline void PCLoginStatusNotify::_internal_set_login_stat(::Bohan::BaseDefine::UserStatType value) {
  assert(::Bohan::BaseDefine::UserStatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.login_stat_ = value;
}
inline void PCLoginStatusNotify::set_login_stat(::Bohan::BaseDefine::UserStatType value) {
  _internal_set_login_stat(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.PCLoginStatusNotify.login_stat)
}

// -------------------------------------------------------------------

// RemoveSessionNotify

// required uint32 user_id = 1;
inline bool RemoveSessionNotify::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoveSessionNotify::has_user_id() const {
  return _internal_has_user_id();
}
inline void RemoveSessionNotify::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RemoveSessionNotify::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t RemoveSessionNotify::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionNotify.user_id)
  return _internal_user_id();
}
inline void RemoveSessionNotify::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void RemoveSessionNotify::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionNotify.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool RemoveSessionNotify::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveSessionNotify::has_session_type() const {
  return _internal_has_session_type();
}
inline void RemoveSessionNotify::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionNotify::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType RemoveSessionNotify::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionNotify.session_type)
  return _internal_session_type();
}
inline void RemoveSessionNotify::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_type_ = value;
}
inline void RemoveSessionNotify::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionNotify.session_type)
}

// required uint32 session_id = 3;
inline bool RemoveSessionNotify::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveSessionNotify::has_session_id() const {
  return _internal_has_session_id();
}
inline void RemoveSessionNotify::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveSessionNotify::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t RemoveSessionNotify::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.RemoveSessionNotify.session_id)
  return _internal_session_id();
}
inline void RemoveSessionNotify::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void RemoveSessionNotify::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.RemoveSessionNotify.session_id)
}

// -------------------------------------------------------------------

// DepartmentReq

// required uint32 user_id = 1;
inline bool DepartmentReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DepartmentReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void DepartmentReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DepartmentReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t DepartmentReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentReq.user_id)
  return _internal_user_id();
}
inline void DepartmentReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void DepartmentReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool DepartmentReq::_internal_has_latest_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DepartmentReq::has_latest_update_time() const {
  return _internal_has_latest_update_time();
}
inline void DepartmentReq::clear_latest_update_time() {
  _impl_.latest_update_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DepartmentReq::_internal_latest_update_time() const {
  return _impl_.latest_update_time_;
}
inline uint32_t DepartmentReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentReq.latest_update_time)
  return _internal_latest_update_time();
}
inline void DepartmentReq::_internal_set_latest_update_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.latest_update_time_ = value;
}
inline void DepartmentReq::set_latest_update_time(uint32_t value) {
  _internal_set_latest_update_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool DepartmentReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DepartmentReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void DepartmentReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DepartmentReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DepartmentReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentReq.attach_data)
}
inline std::string* DepartmentReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.DepartmentReq.attach_data)
  return _s;
}
inline const std::string& DepartmentReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void DepartmentReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DepartmentReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DepartmentReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.DepartmentReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DepartmentReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.DepartmentReq.attach_data)
}

// -------------------------------------------------------------------

// DepartmentRsp

// required uint32 user_id = 1;
inline bool DepartmentRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DepartmentRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void DepartmentRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DepartmentRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t DepartmentRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentRsp.user_id)
  return _internal_user_id();
}
inline void DepartmentRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void DepartmentRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool DepartmentRsp::_internal_has_latest_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DepartmentRsp::has_latest_update_time() const {
  return _internal_has_latest_update_time();
}
inline void DepartmentRsp::clear_latest_update_time() {
  _impl_.latest_update_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DepartmentRsp::_internal_latest_update_time() const {
  return _impl_.latest_update_time_;
}
inline uint32_t DepartmentRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentRsp.latest_update_time)
  return _internal_latest_update_time();
}
inline void DepartmentRsp::_internal_set_latest_update_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.latest_update_time_ = value;
}
inline void DepartmentRsp::set_latest_update_time(uint32_t value) {
  _internal_set_latest_update_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentRsp.latest_update_time)
}

// repeated .Bohan.BaseDefine.DepartInfo dept_list = 3;
inline int DepartmentRsp::_internal_dept_list_size() const {
  return _impl_.dept_list_.size();
}
inline int DepartmentRsp::dept_list_size() const {
  return _internal_dept_list_size();
}
inline ::Bohan::BaseDefine::DepartInfo* DepartmentRsp::mutable_dept_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.DepartmentRsp.dept_list)
  return _impl_.dept_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::DepartInfo >*
DepartmentRsp::mutable_dept_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Buddy.DepartmentRsp.dept_list)
  return &_impl_.dept_list_;
}
inline const ::Bohan::BaseDefine::DepartInfo& DepartmentRsp::_internal_dept_list(int index) const {
  return _impl_.dept_list_.Get(index);
}
inline const ::Bohan::BaseDefine::DepartInfo& DepartmentRsp::dept_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentRsp.dept_list)
  return _internal_dept_list(index);
}
inline ::Bohan::BaseDefine::DepartInfo* DepartmentRsp::_internal_add_dept_list() {
  return _impl_.dept_list_.Add();
}
inline ::Bohan::BaseDefine::DepartInfo* DepartmentRsp::add_dept_list() {
  ::Bohan::BaseDefine::DepartInfo* _add = _internal_add_dept_list();
  // @@protoc_insertion_point(field_add:Bohan.Buddy.DepartmentRsp.dept_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::DepartInfo >&
DepartmentRsp::dept_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Buddy.DepartmentRsp.dept_list)
  return _impl_.dept_list_;
}

// optional bytes attach_data = 20;
inline bool DepartmentRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DepartmentRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void DepartmentRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DepartmentRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Buddy.DepartmentRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DepartmentRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Buddy.DepartmentRsp.attach_data)
}
inline std::string* DepartmentRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Buddy.DepartmentRsp.attach_data)
  return _s;
}
inline const std::string& DepartmentRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void DepartmentRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DepartmentRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DepartmentRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Buddy.DepartmentRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DepartmentRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Buddy.DepartmentRsp.attach_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace Bohan

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Buddy_2eproto
