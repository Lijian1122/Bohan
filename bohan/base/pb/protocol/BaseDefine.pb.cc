// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseDefine.proto

#include "BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Bohan {
namespace BaseDefine {
PROTOBUF_CONSTEXPR IpAddr::IpAddr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0u} {}
struct IpAddrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IpAddrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IpAddrDefaultTypeInternal() {}
  union {
    IpAddr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IpAddrDefaultTypeInternal _IpAddr_default_instance_;
PROTOBUF_CONSTEXPR UserInfo::UserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nick_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_real_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_tel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.gender_)*/0u
  , /*decltype(_impl_.department_id_)*/0u
  , /*decltype(_impl_.status_)*/0u} {}
struct UserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_CONSTEXPR ContactSessionInfo::ContactSessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latest_msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.session_status_)*/0
  , /*decltype(_impl_.updated_time_)*/0u
  , /*decltype(_impl_.latest_msg_id_)*/0u
  , /*decltype(_impl_.latest_msg_from_user_id_)*/0u
  , /*decltype(_impl_.session_type_)*/1
  , /*decltype(_impl_.latest_msg_type_)*/1} {}
struct ContactSessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactSessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactSessionInfoDefaultTypeInternal() {}
  union {
    ContactSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
PROTOBUF_CONSTEXPR UserStat::UserStat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.status_)*/1} {}
struct UserStatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStatDefaultTypeInternal() {}
  union {
    UserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatDefaultTypeInternal _UserStat_default_instance_;
PROTOBUF_CONSTEXPR ServerUserStat::ServerUserStat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.status_)*/1
  , /*decltype(_impl_.client_type_)*/1} {}
struct ServerUserStatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerUserStatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerUserStatDefaultTypeInternal() {}
  union {
    ServerUserStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
PROTOBUF_CONSTEXPR UnreadInfo::UnreadInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latest_msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/0u
  , /*decltype(_impl_.unread_cnt_)*/0u
  , /*decltype(_impl_.latest_msg_id_)*/0u
  , /*decltype(_impl_.latest_msg_from_user_id_)*/0u
  , /*decltype(_impl_.session_type_)*/1
  , /*decltype(_impl_.latest_msg_type_)*/1} {}
struct UnreadInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnreadInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnreadInfoDefaultTypeInternal() {}
  union {
    UnreadInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
PROTOBUF_CONSTEXPR MsgInfo::MsgInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.from_session_id_)*/0u
  , /*decltype(_impl_.create_time_)*/0u
  , /*decltype(_impl_.msg_type_)*/1} {}
struct MsgInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgInfoDefaultTypeInternal() {}
  union {
    MsgInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
PROTOBUF_CONSTEXPR GroupVersionInfo::GroupVersionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.version_)*/0u} {}
struct GroupVersionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupVersionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupVersionInfoDefaultTypeInternal() {}
  union {
    GroupVersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
PROTOBUF_CONSTEXPR GroupInfo::GroupInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_member_list_)*/{}
  , /*decltype(_impl_.group_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.group_creator_id_)*/0u
  , /*decltype(_impl_.group_type_)*/0
  , /*decltype(_impl_.shield_status_)*/0u} {}
struct GroupInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupInfoDefaultTypeInternal() {}
  union {
    GroupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
PROTOBUF_CONSTEXPR UserTokenInfo::UserTokenInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.push_count_)*/0u
  , /*decltype(_impl_.push_type_)*/0u
  , /*decltype(_impl_.user_type_)*/1} {}
struct UserTokenInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserTokenInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserTokenInfoDefaultTypeInternal() {}
  union {
    UserTokenInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
PROTOBUF_CONSTEXPR PushResult::PushResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.result_code_)*/0u} {}
struct PushResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PushResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PushResultDefaultTypeInternal() {}
  union {
    PushResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PushResultDefaultTypeInternal _PushResult_default_instance_;
PROTOBUF_CONSTEXPR ShieldStatus::ShieldStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_id_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.shield_status_)*/0u} {}
struct ShieldStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShieldStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShieldStatusDefaultTypeInternal() {}
  union {
    ShieldStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
PROTOBUF_CONSTEXPR OfflineFileInfo::OfflineFileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.task_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_user_id_)*/0u
  , /*decltype(_impl_.file_size_)*/0u} {}
struct OfflineFileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfflineFileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfflineFileInfoDefaultTypeInternal() {}
  union {
    OfflineFileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
PROTOBUF_CONSTEXPR DepartInfo::DepartInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dept_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dept_id_)*/0u
  , /*decltype(_impl_.priority_)*/0u
  , /*decltype(_impl_.parent_dept_id_)*/0u
  , /*decltype(_impl_.dept_status_)*/0} {}
struct DepartInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DepartInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DepartInfoDefaultTypeInternal() {}
  union {
    DepartInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
}  // namespace BaseDefine
}  // namespace Bohan
namespace Bohan {
namespace BaseDefine {
bool ServiceID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceID_strings[8] = {};

static const char ServiceID_names[] =
  "SID_BUDDY_LIST"
  "SID_FILE"
  "SID_GROUP"
  "SID_INTERNAL"
  "SID_LOGIN"
  "SID_MSG"
  "SID_OTHER"
  "SID_SWITCH_SERVICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceID_entries[] = {
  { {ServiceID_names + 0, 14}, 2 },
  { {ServiceID_names + 14, 8}, 5 },
  { {ServiceID_names + 22, 9}, 4 },
  { {ServiceID_names + 31, 12}, 8 },
  { {ServiceID_names + 43, 9}, 1 },
  { {ServiceID_names + 52, 7}, 3 },
  { {ServiceID_names + 59, 9}, 7 },
  { {ServiceID_names + 68, 18}, 6 },
};

static const int ServiceID_entries_by_number[] = {
  4, // 1 -> SID_LOGIN
  0, // 2 -> SID_BUDDY_LIST
  5, // 3 -> SID_MSG
  2, // 4 -> SID_GROUP
  1, // 5 -> SID_FILE
  7, // 6 -> SID_SWITCH_SERVICE
  6, // 7 -> SID_OTHER
  3, // 8 -> SID_INTERNAL
};

const std::string& ServiceID_Name(
    ServiceID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceID_entries,
          ServiceID_entries_by_number,
          8, ServiceID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceID_entries,
      ServiceID_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceID_strings[idx].get();
}
bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceID_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ServiceID>(int_value);
  }
  return success;
}
bool LoginCmdID_IsValid(int value) {
  switch (value) {
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginCmdID_strings[11] = {};

static const char LoginCmdID_names[] =
  "CID_LOGIN_KICK_USER"
  "CID_LOGIN_REQ_DEVICETOKEN"
  "CID_LOGIN_REQ_KICKPCCLIENT"
  "CID_LOGIN_REQ_LOGINOUT"
  "CID_LOGIN_REQ_MSGSERVER"
  "CID_LOGIN_REQ_USERLOGIN"
  "CID_LOGIN_RES_DEVICETOKEN"
  "CID_LOGIN_RES_KICKPCCLIENT"
  "CID_LOGIN_RES_LOGINOUT"
  "CID_LOGIN_RES_MSGSERVER"
  "CID_LOGIN_RES_USERLOGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginCmdID_entries[] = {
  { {LoginCmdID_names + 0, 19}, 263 },
  { {LoginCmdID_names + 19, 25}, 264 },
  { {LoginCmdID_names + 44, 26}, 266 },
  { {LoginCmdID_names + 70, 22}, 261 },
  { {LoginCmdID_names + 92, 23}, 257 },
  { {LoginCmdID_names + 115, 23}, 259 },
  { {LoginCmdID_names + 138, 25}, 265 },
  { {LoginCmdID_names + 163, 26}, 267 },
  { {LoginCmdID_names + 189, 22}, 262 },
  { {LoginCmdID_names + 211, 23}, 258 },
  { {LoginCmdID_names + 234, 23}, 260 },
};

static const int LoginCmdID_entries_by_number[] = {
  4, // 257 -> CID_LOGIN_REQ_MSGSERVER
  9, // 258 -> CID_LOGIN_RES_MSGSERVER
  5, // 259 -> CID_LOGIN_REQ_USERLOGIN
  10, // 260 -> CID_LOGIN_RES_USERLOGIN
  3, // 261 -> CID_LOGIN_REQ_LOGINOUT
  8, // 262 -> CID_LOGIN_RES_LOGINOUT
  0, // 263 -> CID_LOGIN_KICK_USER
  1, // 264 -> CID_LOGIN_REQ_DEVICETOKEN
  6, // 265 -> CID_LOGIN_RES_DEVICETOKEN
  2, // 266 -> CID_LOGIN_REQ_KICKPCCLIENT
  7, // 267 -> CID_LOGIN_RES_KICKPCCLIENT
};

const std::string& LoginCmdID_Name(
    LoginCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginCmdID_entries,
          LoginCmdID_entries_by_number,
          11, LoginCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginCmdID_entries,
      LoginCmdID_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginCmdID_strings[idx].get();
}
bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginCmdID_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<LoginCmdID>(int_value);
  }
  return success;
}
bool BuddyListCmdID_IsValid(int value) {
  switch (value) {
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BuddyListCmdID_strings[17] = {};

static const char BuddyListCmdID_names[] =
  "CID_BUDDY_LIST_ALL_USER_REQUEST"
  "CID_BUDDY_LIST_ALL_USER_RESPONSE"
  "CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST"
  "CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE"
  "CID_BUDDY_LIST_DEPARTMENT_REQUEST"
  "CID_BUDDY_LIST_DEPARTMENT_RESPONSE"
  "CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST"
  "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE"
  "CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY"
  "CID_BUDDY_LIST_REMOVE_SESSION_REQ"
  "CID_BUDDY_LIST_REMOVE_SESSION_RES"
  "CID_BUDDY_LIST_STATUS_NOTIFY"
  "CID_BUDDY_LIST_USERS_STATUS_REQUEST"
  "CID_BUDDY_LIST_USERS_STATUS_RESPONSE"
  "CID_BUDDY_LIST_USER_INFO_REQUEST"
  "CID_BUDDY_LIST_USER_INFO_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BuddyListCmdID_entries[] = {
  { {BuddyListCmdID_names + 0, 31}, 520 },
  { {BuddyListCmdID_names + 31, 32}, 521 },
  { {BuddyListCmdID_names + 63, 36}, 524 },
  { {BuddyListCmdID_names + 99, 37}, 525 },
  { {BuddyListCmdID_names + 136, 33}, 528 },
  { {BuddyListCmdID_names + 169, 34}, 529 },
  { {BuddyListCmdID_names + 203, 37}, 526 },
  { {BuddyListCmdID_names + 240, 45}, 513 },
  { {BuddyListCmdID_names + 285, 46}, 514 },
  { {BuddyListCmdID_names + 331, 36}, 527 },
  { {BuddyListCmdID_names + 367, 33}, 518 },
  { {BuddyListCmdID_names + 400, 33}, 519 },
  { {BuddyListCmdID_names + 433, 28}, 515 },
  { {BuddyListCmdID_names + 461, 35}, 522 },
  { {BuddyListCmdID_names + 496, 36}, 523 },
  { {BuddyListCmdID_names + 532, 32}, 516 },
  { {BuddyListCmdID_names + 564, 33}, 517 },
};

static const int BuddyListCmdID_entries_by_number[] = {
  7, // 513 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST
  8, // 514 -> CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE
  12, // 515 -> CID_BUDDY_LIST_STATUS_NOTIFY
  15, // 516 -> CID_BUDDY_LIST_USER_INFO_REQUEST
  16, // 517 -> CID_BUDDY_LIST_USER_INFO_RESPONSE
  10, // 518 -> CID_BUDDY_LIST_REMOVE_SESSION_REQ
  11, // 519 -> CID_BUDDY_LIST_REMOVE_SESSION_RES
  0, // 520 -> CID_BUDDY_LIST_ALL_USER_REQUEST
  1, // 521 -> CID_BUDDY_LIST_ALL_USER_RESPONSE
  13, // 522 -> CID_BUDDY_LIST_USERS_STATUS_REQUEST
  14, // 523 -> CID_BUDDY_LIST_USERS_STATUS_RESPONSE
  2, // 524 -> CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST
  3, // 525 -> CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE
  6, // 526 -> CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY
  9, // 527 -> CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY
  4, // 528 -> CID_BUDDY_LIST_DEPARTMENT_REQUEST
  5, // 529 -> CID_BUDDY_LIST_DEPARTMENT_RESPONSE
};

const std::string& BuddyListCmdID_Name(
    BuddyListCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BuddyListCmdID_entries,
          BuddyListCmdID_entries_by_number,
          17, BuddyListCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BuddyListCmdID_entries,
      BuddyListCmdID_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BuddyListCmdID_strings[idx].get();
}
bool BuddyListCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyListCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BuddyListCmdID_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<BuddyListCmdID>(int_value);
  }
  return success;
}
bool MessageCmdID_IsValid(int value) {
  switch (value) {
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessageCmdID_strings[14] = {};

static const char MessageCmdID_names[] =
  "CID_MSG_DATA"
  "CID_MSG_DATA_ACK"
  "CID_MSG_GET_BY_MSG_ID_REQ"
  "CID_MSG_GET_BY_MSG_ID_RES"
  "CID_MSG_GET_LATEST_MSG_ID_REQ"
  "CID_MSG_GET_LATEST_MSG_ID_RSP"
  "CID_MSG_LIST_REQUEST"
  "CID_MSG_LIST_RESPONSE"
  "CID_MSG_READ_ACK"
  "CID_MSG_READ_NOTIFY"
  "CID_MSG_TIME_REQUEST"
  "CID_MSG_TIME_RESPONSE"
  "CID_MSG_UNREAD_CNT_REQUEST"
  "CID_MSG_UNREAD_CNT_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessageCmdID_entries[] = {
  { {MessageCmdID_names + 0, 12}, 769 },
  { {MessageCmdID_names + 12, 16}, 770 },
  { {MessageCmdID_names + 28, 25}, 781 },
  { {MessageCmdID_names + 53, 25}, 782 },
  { {MessageCmdID_names + 78, 29}, 779 },
  { {MessageCmdID_names + 107, 29}, 780 },
  { {MessageCmdID_names + 136, 20}, 777 },
  { {MessageCmdID_names + 156, 21}, 778 },
  { {MessageCmdID_names + 177, 16}, 771 },
  { {MessageCmdID_names + 193, 19}, 772 },
  { {MessageCmdID_names + 212, 20}, 773 },
  { {MessageCmdID_names + 232, 21}, 774 },
  { {MessageCmdID_names + 253, 26}, 775 },
  { {MessageCmdID_names + 279, 27}, 776 },
};

static const int MessageCmdID_entries_by_number[] = {
  0, // 769 -> CID_MSG_DATA
  1, // 770 -> CID_MSG_DATA_ACK
  8, // 771 -> CID_MSG_READ_ACK
  9, // 772 -> CID_MSG_READ_NOTIFY
  10, // 773 -> CID_MSG_TIME_REQUEST
  11, // 774 -> CID_MSG_TIME_RESPONSE
  12, // 775 -> CID_MSG_UNREAD_CNT_REQUEST
  13, // 776 -> CID_MSG_UNREAD_CNT_RESPONSE
  6, // 777 -> CID_MSG_LIST_REQUEST
  7, // 778 -> CID_MSG_LIST_RESPONSE
  4, // 779 -> CID_MSG_GET_LATEST_MSG_ID_REQ
  5, // 780 -> CID_MSG_GET_LATEST_MSG_ID_RSP
  2, // 781 -> CID_MSG_GET_BY_MSG_ID_REQ
  3, // 782 -> CID_MSG_GET_BY_MSG_ID_RES
};

const std::string& MessageCmdID_Name(
    MessageCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MessageCmdID_entries,
          MessageCmdID_entries_by_number,
          14, MessageCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MessageCmdID_entries,
      MessageCmdID_entries_by_number,
      14, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MessageCmdID_strings[idx].get();
}
bool MessageCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MessageCmdID_entries, 14, name, &int_value);
  if (success) {
    *value = static_cast<MessageCmdID>(int_value);
  }
  return success;
}
bool GroupCmdID_IsValid(int value) {
  switch (value) {
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupCmdID_strings[11] = {};

static const char GroupCmdID_names[] =
  "CID_GROUP_CHANGE_MEMBER_NOTIFY"
  "CID_GROUP_CHANGE_MEMBER_REQUEST"
  "CID_GROUP_CHANGE_MEMBER_RESPONSE"
  "CID_GROUP_CREATE_REQUEST"
  "CID_GROUP_CREATE_RESPONSE"
  "CID_GROUP_INFO_REQUEST"
  "CID_GROUP_INFO_RESPONSE"
  "CID_GROUP_NORMAL_LIST_REQUEST"
  "CID_GROUP_NORMAL_LIST_RESPONSE"
  "CID_GROUP_SHIELD_GROUP_REQUEST"
  "CID_GROUP_SHIELD_GROUP_RESPONSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupCmdID_entries[] = {
  { {GroupCmdID_names + 0, 30}, 1035 },
  { {GroupCmdID_names + 30, 31}, 1031 },
  { {GroupCmdID_names + 61, 32}, 1032 },
  { {GroupCmdID_names + 93, 24}, 1029 },
  { {GroupCmdID_names + 117, 25}, 1030 },
  { {GroupCmdID_names + 142, 22}, 1027 },
  { {GroupCmdID_names + 164, 23}, 1028 },
  { {GroupCmdID_names + 187, 29}, 1025 },
  { {GroupCmdID_names + 216, 30}, 1026 },
  { {GroupCmdID_names + 246, 30}, 1033 },
  { {GroupCmdID_names + 276, 31}, 1034 },
};

static const int GroupCmdID_entries_by_number[] = {
  7, // 1025 -> CID_GROUP_NORMAL_LIST_REQUEST
  8, // 1026 -> CID_GROUP_NORMAL_LIST_RESPONSE
  5, // 1027 -> CID_GROUP_INFO_REQUEST
  6, // 1028 -> CID_GROUP_INFO_RESPONSE
  3, // 1029 -> CID_GROUP_CREATE_REQUEST
  4, // 1030 -> CID_GROUP_CREATE_RESPONSE
  1, // 1031 -> CID_GROUP_CHANGE_MEMBER_REQUEST
  2, // 1032 -> CID_GROUP_CHANGE_MEMBER_RESPONSE
  9, // 1033 -> CID_GROUP_SHIELD_GROUP_REQUEST
  10, // 1034 -> CID_GROUP_SHIELD_GROUP_RESPONSE
  0, // 1035 -> CID_GROUP_CHANGE_MEMBER_NOTIFY
};

const std::string& GroupCmdID_Name(
    GroupCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupCmdID_entries,
          GroupCmdID_entries_by_number,
          11, GroupCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupCmdID_entries,
      GroupCmdID_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupCmdID_strings[idx].get();
}
bool GroupCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupCmdID_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<GroupCmdID>(int_value);
  }
  return success;
}
bool FileCmdID_IsValid(int value) {
  switch (value) {
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileCmdID_strings[12] = {};

static const char FileCmdID_names[] =
  "CID_FILE_ADD_OFFLINE_REQ"
  "CID_FILE_DEL_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_REQ"
  "CID_FILE_HAS_OFFLINE_RES"
  "CID_FILE_LOGIN_REQ"
  "CID_FILE_LOGIN_RES"
  "CID_FILE_NOTIFY"
  "CID_FILE_PULL_DATA_REQ"
  "CID_FILE_PULL_DATA_RSP"
  "CID_FILE_REQUEST"
  "CID_FILE_RESPONSE"
  "CID_FILE_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileCmdID_entries[] = {
  { {FileCmdID_names + 0, 24}, 1291 },
  { {FileCmdID_names + 24, 24}, 1292 },
  { {FileCmdID_names + 48, 24}, 1289 },
  { {FileCmdID_names + 72, 24}, 1290 },
  { {FileCmdID_names + 96, 18}, 1281 },
  { {FileCmdID_names + 114, 18}, 1282 },
  { {FileCmdID_names + 132, 15}, 1288 },
  { {FileCmdID_names + 147, 22}, 1284 },
  { {FileCmdID_names + 169, 22}, 1285 },
  { {FileCmdID_names + 191, 16}, 1286 },
  { {FileCmdID_names + 207, 17}, 1287 },
  { {FileCmdID_names + 224, 14}, 1283 },
};

static const int FileCmdID_entries_by_number[] = {
  4, // 1281 -> CID_FILE_LOGIN_REQ
  5, // 1282 -> CID_FILE_LOGIN_RES
  11, // 1283 -> CID_FILE_STATE
  7, // 1284 -> CID_FILE_PULL_DATA_REQ
  8, // 1285 -> CID_FILE_PULL_DATA_RSP
  9, // 1286 -> CID_FILE_REQUEST
  10, // 1287 -> CID_FILE_RESPONSE
  6, // 1288 -> CID_FILE_NOTIFY
  2, // 1289 -> CID_FILE_HAS_OFFLINE_REQ
  3, // 1290 -> CID_FILE_HAS_OFFLINE_RES
  0, // 1291 -> CID_FILE_ADD_OFFLINE_REQ
  1, // 1292 -> CID_FILE_DEL_OFFLINE_REQ
};

const std::string& FileCmdID_Name(
    FileCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileCmdID_entries,
          FileCmdID_entries_by_number,
          12, FileCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileCmdID_entries,
      FileCmdID_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileCmdID_strings[idx].get();
}
bool FileCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileCmdID_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<FileCmdID>(int_value);
  }
  return success;
}
bool SwitchServiceCmdID_IsValid(int value) {
  switch (value) {
    case 1537:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SwitchServiceCmdID_strings[1] = {};

static const char SwitchServiceCmdID_names[] =
  "CID_SWITCH_P2P_CMD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SwitchServiceCmdID_entries[] = {
  { {SwitchServiceCmdID_names + 0, 18}, 1537 },
};

static const int SwitchServiceCmdID_entries_by_number[] = {
  0, // 1537 -> CID_SWITCH_P2P_CMD
};

const std::string& SwitchServiceCmdID_Name(
    SwitchServiceCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SwitchServiceCmdID_entries,
          SwitchServiceCmdID_entries_by_number,
          1, SwitchServiceCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SwitchServiceCmdID_entries,
      SwitchServiceCmdID_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SwitchServiceCmdID_strings[idx].get();
}
bool SwitchServiceCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchServiceCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SwitchServiceCmdID_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<SwitchServiceCmdID>(int_value);
  }
  return success;
}
bool OtherCmdID_IsValid(int value) {
  switch (value) {
    case 1793:
    case 1795:
    case 1796:
    case 1797:
    case 1798:
    case 1799:
    case 1800:
    case 1801:
    case 1802:
    case 1803:
    case 1805:
    case 1806:
    case 1807:
    case 1808:
    case 1809:
    case 1810:
    case 1841:
    case 1842:
    case 1843:
    case 1844:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OtherCmdID_strings[20] = {};

static const char OtherCmdID_names[] =
  "CID_OTHER_FILE_SERVER_IP_REQ"
  "CID_OTHER_FILE_SERVER_IP_RSP"
  "CID_OTHER_FILE_TRANSFER_REQ"
  "CID_OTHER_FILE_TRANSFER_RSP"
  "CID_OTHER_GET_DEVICE_TOKEN_REQ"
  "CID_OTHER_GET_DEVICE_TOKEN_RSP"
  "CID_OTHER_GET_SHIELD_REQ"
  "CID_OTHER_GET_SHIELD_RSP"
  "CID_OTHER_HEARTBEAT"
  "CID_OTHER_LOGIN_STATUS_NOTIFY"
  "CID_OTHER_MSG_SERV_INFO"
  "CID_OTHER_ONLINE_USER_INFO"
  "CID_OTHER_PUSH_TO_USER_REQ"
  "CID_OTHER_PUSH_TO_USER_RSP"
  "CID_OTHER_ROLE_SET"
  "CID_OTHER_SERVER_KICK_USER"
  "CID_OTHER_STOP_RECV_PACKET"
  "CID_OTHER_USER_CNT_UPDATE"
  "CID_OTHER_USER_STATUS_UPDATE"
  "CID_OTHER_VALIDATE_RSP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OtherCmdID_entries[] = {
  { {OtherCmdID_names + 0, 28}, 1843 },
  { {OtherCmdID_names + 28, 28}, 1844 },
  { {OtherCmdID_names + 56, 27}, 1841 },
  { {OtherCmdID_names + 83, 27}, 1842 },
  { {OtherCmdID_names + 110, 30}, 1797 },
  { {OtherCmdID_names + 140, 30}, 1798 },
  { {OtherCmdID_names + 170, 24}, 1809 },
  { {OtherCmdID_names + 194, 24}, 1810 },
  { {OtherCmdID_names + 218, 19}, 1793 },
  { {OtherCmdID_names + 237, 29}, 1806 },
  { {OtherCmdID_names + 266, 23}, 1801 },
  { {OtherCmdID_names + 289, 26}, 1800 },
  { {OtherCmdID_names + 315, 26}, 1807 },
  { {OtherCmdID_names + 341, 26}, 1808 },
  { {OtherCmdID_names + 367, 18}, 1799 },
  { {OtherCmdID_names + 385, 26}, 1805 },
  { {OtherCmdID_names + 411, 26}, 1795 },
  { {OtherCmdID_names + 437, 25}, 1803 },
  { {OtherCmdID_names + 462, 28}, 1802 },
  { {OtherCmdID_names + 490, 22}, 1796 },
};

static const int OtherCmdID_entries_by_number[] = {
  8, // 1793 -> CID_OTHER_HEARTBEAT
  16, // 1795 -> CID_OTHER_STOP_RECV_PACKET
  19, // 1796 -> CID_OTHER_VALIDATE_RSP
  4, // 1797 -> CID_OTHER_GET_DEVICE_TOKEN_REQ
  5, // 1798 -> CID_OTHER_GET_DEVICE_TOKEN_RSP
  14, // 1799 -> CID_OTHER_ROLE_SET
  11, // 1800 -> CID_OTHER_ONLINE_USER_INFO
  10, // 1801 -> CID_OTHER_MSG_SERV_INFO
  18, // 1802 -> CID_OTHER_USER_STATUS_UPDATE
  17, // 1803 -> CID_OTHER_USER_CNT_UPDATE
  15, // 1805 -> CID_OTHER_SERVER_KICK_USER
  9, // 1806 -> CID_OTHER_LOGIN_STATUS_NOTIFY
  12, // 1807 -> CID_OTHER_PUSH_TO_USER_REQ
  13, // 1808 -> CID_OTHER_PUSH_TO_USER_RSP
  6, // 1809 -> CID_OTHER_GET_SHIELD_REQ
  7, // 1810 -> CID_OTHER_GET_SHIELD_RSP
  2, // 1841 -> CID_OTHER_FILE_TRANSFER_REQ
  3, // 1842 -> CID_OTHER_FILE_TRANSFER_RSP
  0, // 1843 -> CID_OTHER_FILE_SERVER_IP_REQ
  1, // 1844 -> CID_OTHER_FILE_SERVER_IP_RSP
};

const std::string& OtherCmdID_Name(
    OtherCmdID value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OtherCmdID_entries,
          OtherCmdID_entries_by_number,
          20, OtherCmdID_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OtherCmdID_entries,
      OtherCmdID_entries_by_number,
      20, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OtherCmdID_strings[idx].get();
}
bool OtherCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OtherCmdID* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OtherCmdID_entries, 20, name, &int_value);
  if (success) {
    *value = static_cast<OtherCmdID>(int_value);
  }
  return success;
}
bool ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResultType_strings[8] = {};

static const char ResultType_names[] =
  "REFUSE_REASON_DB_VALIDATE_FAILED"
  "REFUSE_REASON_MSG_SERVER_FULL"
  "REFUSE_REASON_NONE"
  "REFUSE_REASON_NO_DB_SERVER"
  "REFUSE_REASON_NO_LOGIN_SERVER"
  "REFUSE_REASON_NO_MSG_SERVER"
  "REFUSE_REASON_NO_ROUTE_SERVER"
  "REFUSE_REASON_VERSION_TOO_OLD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResultType_entries[] = {
  { {ResultType_names + 0, 32}, 6 },
  { {ResultType_names + 32, 29}, 2 },
  { {ResultType_names + 61, 18}, 0 },
  { {ResultType_names + 79, 26}, 3 },
  { {ResultType_names + 105, 29}, 4 },
  { {ResultType_names + 134, 27}, 1 },
  { {ResultType_names + 161, 29}, 5 },
  { {ResultType_names + 190, 29}, 7 },
};

static const int ResultType_entries_by_number[] = {
  2, // 0 -> REFUSE_REASON_NONE
  5, // 1 -> REFUSE_REASON_NO_MSG_SERVER
  1, // 2 -> REFUSE_REASON_MSG_SERVER_FULL
  3, // 3 -> REFUSE_REASON_NO_DB_SERVER
  4, // 4 -> REFUSE_REASON_NO_LOGIN_SERVER
  6, // 5 -> REFUSE_REASON_NO_ROUTE_SERVER
  0, // 6 -> REFUSE_REASON_DB_VALIDATE_FAILED
  7, // 7 -> REFUSE_REASON_VERSION_TOO_OLD
};

const std::string& ResultType_Name(
    ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ResultType_entries,
          ResultType_entries_by_number,
          8, ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ResultType_entries,
      ResultType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ResultType_strings[idx].get();
}
bool ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ResultType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<ResultType>(int_value);
  }
  return success;
}
bool KickReasonType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KickReasonType_strings[2] = {};

static const char KickReasonType_names[] =
  "KICK_REASON_DUPLICATE_USER"
  "KICK_REASON_MOBILE_KICK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KickReasonType_entries[] = {
  { {KickReasonType_names + 0, 26}, 1 },
  { {KickReasonType_names + 26, 23}, 2 },
};

static const int KickReasonType_entries_by_number[] = {
  0, // 1 -> KICK_REASON_DUPLICATE_USER
  1, // 2 -> KICK_REASON_MOBILE_KICK
};

const std::string& KickReasonType_Name(
    KickReasonType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KickReasonType_entries,
          KickReasonType_entries_by_number,
          2, KickReasonType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KickReasonType_entries,
      KickReasonType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KickReasonType_strings[idx].get();
}
bool KickReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickReasonType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KickReasonType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<KickReasonType>(int_value);
  }
  return success;
}
bool OnlineListType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OnlineListType_strings[1] = {};

static const char OnlineListType_names[] =
  "ONLINE_LIST_TYPE_FRIEND_LIST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OnlineListType_entries[] = {
  { {OnlineListType_names + 0, 28}, 1 },
};

static const int OnlineListType_entries_by_number[] = {
  0, // 1 -> ONLINE_LIST_TYPE_FRIEND_LIST
};

const std::string& OnlineListType_Name(
    OnlineListType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OnlineListType_entries,
          OnlineListType_entries_by_number,
          1, OnlineListType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OnlineListType_entries,
      OnlineListType_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OnlineListType_strings[idx].get();
}
bool OnlineListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineListType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OnlineListType_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<OnlineListType>(int_value);
  }
  return success;
}
bool UserStatType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserStatType_strings[3] = {};

static const char UserStatType_names[] =
  "USER_STATUS_LEAVE"
  "USER_STATUS_OFFLINE"
  "USER_STATUS_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserStatType_entries[] = {
  { {UserStatType_names + 0, 17}, 3 },
  { {UserStatType_names + 17, 19}, 2 },
  { {UserStatType_names + 36, 18}, 1 },
};

static const int UserStatType_entries_by_number[] = {
  2, // 1 -> USER_STATUS_ONLINE
  1, // 2 -> USER_STATUS_OFFLINE
  0, // 3 -> USER_STATUS_LEAVE
};

const std::string& UserStatType_Name(
    UserStatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserStatType_entries,
          UserStatType_entries_by_number,
          3, UserStatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserStatType_entries,
      UserStatType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserStatType_strings[idx].get();
}
bool UserStatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserStatType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UserStatType>(int_value);
  }
  return success;
}
bool SessionType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionType_strings[2] = {};

static const char SessionType_names[] =
  "SESSION_TYPE_GROUP"
  "SESSION_TYPE_SINGLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionType_entries[] = {
  { {SessionType_names + 0, 18}, 2 },
  { {SessionType_names + 18, 19}, 1 },
};

static const int SessionType_entries_by_number[] = {
  1, // 1 -> SESSION_TYPE_SINGLE
  0, // 2 -> SESSION_TYPE_GROUP
};

const std::string& SessionType_Name(
    SessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionType_entries,
          SessionType_entries_by_number,
          2, SessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionType_entries,
      SessionType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionType_strings[idx].get();
}
bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionType>(int_value);
  }
  return success;
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MsgType_strings[4] = {};

static const char MsgType_names[] =
  "MSG_TYPE_GROUP_AUDIO"
  "MSG_TYPE_GROUP_TEXT"
  "MSG_TYPE_SINGLE_AUDIO"
  "MSG_TYPE_SINGLE_TEXT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MsgType_entries[] = {
  { {MsgType_names + 0, 20}, 18 },
  { {MsgType_names + 20, 19}, 17 },
  { {MsgType_names + 39, 21}, 2 },
  { {MsgType_names + 60, 20}, 1 },
};

static const int MsgType_entries_by_number[] = {
  3, // 1 -> MSG_TYPE_SINGLE_TEXT
  2, // 2 -> MSG_TYPE_SINGLE_AUDIO
  1, // 17 -> MSG_TYPE_GROUP_TEXT
  0, // 18 -> MSG_TYPE_GROUP_AUDIO
};

const std::string& MsgType_Name(
    MsgType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MsgType_entries,
          MsgType_entries_by_number,
          4, MsgType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MsgType_entries,
      MsgType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MsgType_strings[idx].get();
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MsgType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<MsgType>(int_value);
  }
  return success;
}
bool ClientType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientType_strings[4] = {};

static const char ClientType_names[] =
  "CLIENT_TYPE_ANDROID"
  "CLIENT_TYPE_IOS"
  "CLIENT_TYPE_MAC"
  "CLIENT_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientType_entries[] = {
  { {ClientType_names + 0, 19}, 18 },
  { {ClientType_names + 19, 15}, 17 },
  { {ClientType_names + 34, 15}, 2 },
  { {ClientType_names + 49, 19}, 1 },
};

static const int ClientType_entries_by_number[] = {
  3, // 1 -> CLIENT_TYPE_WINDOWS
  2, // 2 -> CLIENT_TYPE_MAC
  1, // 17 -> CLIENT_TYPE_IOS
  0, // 18 -> CLIENT_TYPE_ANDROID
};

const std::string& ClientType_Name(
    ClientType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientType_entries,
          ClientType_entries_by_number,
          4, ClientType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientType_entries,
      ClientType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientType_strings[idx].get();
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientType>(int_value);
  }
  return success;
}
bool GroupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupType_strings[2] = {};

static const char GroupType_names[] =
  "GROUP_TYPE_NORMAL"
  "GROUP_TYPE_TMP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupType_entries[] = {
  { {GroupType_names + 0, 17}, 0 },
  { {GroupType_names + 17, 14}, 1 },
};

static const int GroupType_entries_by_number[] = {
  0, // 0 -> GROUP_TYPE_NORMAL
  1, // 1 -> GROUP_TYPE_TMP
};

const std::string& GroupType_Name(
    GroupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupType_entries,
          GroupType_entries_by_number,
          2, GroupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupType_entries,
      GroupType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupType_strings[idx].get();
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupType>(int_value);
  }
  return success;
}
bool GroupModifyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupModifyType_strings[2] = {};

static const char GroupModifyType_names[] =
  "GROUP_MODIFY_TYPE_ADD"
  "GROUP_MODIFY_TYPE_DEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupModifyType_entries[] = {
  { {GroupModifyType_names + 0, 21}, 0 },
  { {GroupModifyType_names + 21, 21}, 1 },
};

static const int GroupModifyType_entries_by_number[] = {
  0, // 0 -> GROUP_MODIFY_TYPE_ADD
  1, // 1 -> GROUP_MODIFY_TYPE_DEL
};

const std::string& GroupModifyType_Name(
    GroupModifyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupModifyType_entries,
          GroupModifyType_entries_by_number,
          2, GroupModifyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupModifyType_entries,
      GroupModifyType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupModifyType_strings[idx].get();
}
bool GroupModifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupModifyType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupModifyType>(int_value);
  }
  return success;
}
bool FileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileType_strings[2] = {};

static const char FileType_names[] =
  "FILE_TYPE_OFFLINE"
  "FILE_TYPE_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileType_entries[] = {
  { {FileType_names + 0, 17}, 2 },
  { {FileType_names + 17, 16}, 0 },
};

static const int FileType_entries_by_number[] = {
  1, // 0 -> FILE_TYPE_ONLINE
  0, // 2 -> FILE_TYPE_OFFLINE
};

const std::string& FileType_Name(
    FileType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileType_entries,
          FileType_entries_by_number,
          2, FileType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileType_entries,
      FileType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileType_strings[idx].get();
}
bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FileType>(int_value);
  }
  return success;
}
bool ClientFileState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileState_strings[4] = {};

static const char ClientFileState_names[] =
  "CLIENT_FILE_CANCEL"
  "CLIENT_FILE_DONE"
  "CLIENT_FILE_PEER_READY"
  "CLIENT_FILE_REFUSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileState_entries[] = {
  { {ClientFileState_names + 0, 18}, 1 },
  { {ClientFileState_names + 18, 16}, 3 },
  { {ClientFileState_names + 34, 22}, 0 },
  { {ClientFileState_names + 56, 18}, 2 },
};

static const int ClientFileState_entries_by_number[] = {
  2, // 0 -> CLIENT_FILE_PEER_READY
  0, // 1 -> CLIENT_FILE_CANCEL
  3, // 2 -> CLIENT_FILE_REFUSE
  1, // 3 -> CLIENT_FILE_DONE
};

const std::string& ClientFileState_Name(
    ClientFileState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileState_entries,
          ClientFileState_entries_by_number,
          4, ClientFileState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileState_entries,
      ClientFileState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileState_strings[idx].get();
}
bool ClientFileState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileState>(int_value);
  }
  return success;
}
bool ClientFileRole_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFileRole_strings[4] = {};

static const char ClientFileRole_names[] =
  "CLIENT_OFFLINE_DOWNLOAD"
  "CLIENT_OFFLINE_UPLOAD"
  "CLIENT_REALTIME_RECVER"
  "CLIENT_REALTIME_SENDER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFileRole_entries[] = {
  { {ClientFileRole_names + 0, 23}, 4 },
  { {ClientFileRole_names + 23, 21}, 3 },
  { {ClientFileRole_names + 44, 22}, 2 },
  { {ClientFileRole_names + 66, 22}, 1 },
};

static const int ClientFileRole_entries_by_number[] = {
  3, // 1 -> CLIENT_REALTIME_SENDER
  2, // 2 -> CLIENT_REALTIME_RECVER
  1, // 3 -> CLIENT_OFFLINE_UPLOAD
  0, // 4 -> CLIENT_OFFLINE_DOWNLOAD
};

const std::string& ClientFileRole_Name(
    ClientFileRole value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFileRole_entries,
          ClientFileRole_entries_by_number,
          4, ClientFileRole_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFileRole_entries,
      ClientFileRole_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFileRole_strings[idx].get();
}
bool ClientFileRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileRole* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFileRole_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientFileRole>(int_value);
  }
  return success;
}
bool FileServerError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FileServerError_strings[13] = {};

static const char FileServerError_names[] =
  "FILE_SERVER_ERRNO_CREATE_TASK_ERROR"
  "FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR"
  "FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK"
  "FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN"
  "FILE_SERVER_ERRNO_OK"
  "FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_FINISHED"
  "FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER"
  "FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR"
  "FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileServerError_entries[] = {
  { {FileServerError_names + 0, 35}, 2 },
  { {FileServerError_names + 35, 38}, 1 },
  { {FileServerError_names + 73, 39}, 4 },
  { {FileServerError_names + 112, 37}, 3 },
  { {FileServerError_names + 149, 20}, 0 },
  { {FileServerError_names + 169, 43}, 10 },
  { {FileServerError_names + 212, 36}, 12 },
  { {FileServerError_names + 248, 41}, 6 },
  { {FileServerError_names + 289, 39}, 7 },
  { {FileServerError_names + 328, 43}, 8 },
  { {FileServerError_names + 371, 50}, 9 },
  { {FileServerError_names + 421, 45}, 11 },
  { {FileServerError_names + 466, 48}, 5 },
};

static const int FileServerError_entries_by_number[] = {
  4, // 0 -> FILE_SERVER_ERRNO_OK
  1, // 1 -> FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR
  0, // 2 -> FILE_SERVER_ERRNO_CREATE_TASK_ERROR
  3, // 3 -> FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN
  2, // 4 -> FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK
  12, // 5 -> FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID
  7, // 6 -> FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER
  8, // 7 -> FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR
  9, // 8 -> FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR
  10, // 9 -> FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR
  5, // 10 -> FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR
  11, // 11 -> FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR
  6, // 12 -> FILE_SERVER_ERRNO_PULL_DATA_FINISHED
};

const std::string& FileServerError_Name(
    FileServerError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileServerError_entries,
          FileServerError_entries_by_number,
          13, FileServerError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileServerError_entries,
      FileServerError_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FileServerError_strings[idx].get();
}
bool FileServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileServerError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileServerError_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<FileServerError>(int_value);
  }
  return success;
}
bool SessionStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStatusType_strings[2] = {};

static const char SessionStatusType_names[] =
  "SESSION_STATUS_DELETE"
  "SESSION_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStatusType_entries[] = {
  { {SessionStatusType_names + 0, 21}, 1 },
  { {SessionStatusType_names + 21, 17}, 0 },
};

static const int SessionStatusType_entries_by_number[] = {
  1, // 0 -> SESSION_STATUS_OK
  0, // 1 -> SESSION_STATUS_DELETE
};

const std::string& SessionStatusType_Name(
    SessionStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStatusType_entries,
          SessionStatusType_entries_by_number,
          2, SessionStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStatusType_entries,
      SessionStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStatusType_strings[idx].get();
}
bool SessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionStatusType>(int_value);
  }
  return success;
}
bool DepartmentStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DepartmentStatusType_strings[2] = {};

static const char DepartmentStatusType_names[] =
  "DEPT_STATUS_DELETE"
  "DEPT_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DepartmentStatusType_entries[] = {
  { {DepartmentStatusType_names + 0, 18}, 1 },
  { {DepartmentStatusType_names + 18, 14}, 0 },
};

static const int DepartmentStatusType_entries_by_number[] = {
  1, // 0 -> DEPT_STATUS_OK
  0, // 1 -> DEPT_STATUS_DELETE
};

const std::string& DepartmentStatusType_Name(
    DepartmentStatusType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DepartmentStatusType_entries,
          DepartmentStatusType_entries_by_number,
          2, DepartmentStatusType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DepartmentStatusType_entries,
      DepartmentStatusType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DepartmentStatusType_strings[idx].get();
}
bool DepartmentStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepartmentStatusType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DepartmentStatusType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DepartmentStatusType>(int_value);
  }
  return success;
}

// ===================================================================

class IpAddr::_Internal {
 public:
  using HasBits = decltype(std::declval<IpAddr>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IpAddr::IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.IpAddr)
}
IpAddr::IpAddr(const IpAddr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IpAddr* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.IpAddr)
}

inline void IpAddr::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){0u}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.IpAddr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IpAddr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
}

void IpAddr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IpAddr::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ip_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IpAddr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpAddr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.IpAddr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required uint32 port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.IpAddr)
  return target;
}

size_t IpAddr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_port()) {
    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return total_size;
}
size_t IpAddr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.IpAddr)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IpAddr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IpAddr*>(
      &from));
}

void IpAddr::MergeFrom(const IpAddr& from) {
  IpAddr* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.IpAddr)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IpAddr::CopyFrom(const IpAddr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.IpAddr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void IpAddr::InternalSwap(IpAddr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

std::string IpAddr::GetTypeName() const {
  return "Bohan.BaseDefine.IpAddr";
}


// ===================================================================

class UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserInfo>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gender(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_nick_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_department_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_real_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_tel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_user_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000003ff) ^ 0x000003ff) != 0;
  }
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nick_name_){}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.user_real_name_){}
    , decltype(_impl_.user_tel_){}
    , decltype(_impl_.user_domain_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.gender_){}
    , decltype(_impl_.department_id_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nick_name()) {
    _this->_impl_.nick_name_.Set(from._internal_nick_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    _this->_impl_.avatar_url_.Set(from._internal_avatar_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_real_name()) {
    _this->_impl_.user_real_name_.Set(from._internal_user_real_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_tel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_tel()) {
    _this->_impl_.user_tel_.Set(from._internal_user_tel(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_domain()) {
    _this->_impl_.user_domain_.Set(from._internal_user_domain(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.UserInfo)
}

inline void UserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nick_name_){}
    , decltype(_impl_.avatar_url_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.user_real_name_){}
    , decltype(_impl_.user_tel_){}
    , decltype(_impl_.user_domain_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.gender_){0u}
    , decltype(_impl_.department_id_){0u}
    , decltype(_impl_.status_){0u}
  };
  _impl_.nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_real_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_tel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.UserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nick_name_.Destroy();
  _impl_.avatar_url_.Destroy();
  _impl_.email_.Destroy();
  _impl_.user_real_name_.Destroy();
  _impl_.user_tel_.Destroy();
  _impl_.user_domain_.Destroy();
}

void UserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.nick_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.avatar_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.user_real_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.user_tel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.user_domain_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gender_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.gender_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.department_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.department_id_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 gender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gender(&has_bits);
          _impl_.gender_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string nick_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nick_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 department_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_department_id(&has_bits);
          _impl_.department_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string email = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_real_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_user_real_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_tel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_user_tel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string user_domain = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_user_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 status = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 gender = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_gender(), target);
  }

  // required string nick_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nick_name(), target);
  }

  // required string avatar_url = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_avatar_url(), target);
  }

  // required uint32 department_id = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_department_id(), target);
  }

  // required string email = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_email(), target);
  }

  // required string user_real_name = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_user_real_name(), target);
  }

  // required string user_tel = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_user_tel(), target);
  }

  // required string user_domain = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_user_domain(), target);
  }

  // required uint32 status = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.UserInfo)
  return target;
}

size_t UserInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (_internal_has_nick_name()) {
    // required string nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nick_name());
  }

  if (_internal_has_avatar_url()) {
    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());
  }

  if (_internal_has_email()) {
    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  if (_internal_has_user_real_name()) {
    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());
  }

  if (_internal_has_user_tel()) {
    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());
  }

  if (_internal_has_user_domain()) {
    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_gender()) {
    // required uint32 gender = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gender());
  }

  if (_internal_has_department_id()) {
    // required uint32 department_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());
  }

  if (_internal_has_status()) {
    // required uint32 status = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  return total_size;
}
size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.UserInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000003ff) ^ 0x000003ff) == 0) {  // All required fields are present.
    // required string nick_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nick_name());

    // required string avatar_url = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar_url());

    // required string email = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());

    // required string user_real_name = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_real_name());

    // required string user_tel = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_tel());

    // required string user_domain = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_domain());

    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 gender = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gender());

    // required uint32 department_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_department_id());

    // required uint32 status = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserInfo*>(
      &from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  UserInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.UserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_nick_name(from._internal_nick_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_user_real_name(from._internal_user_real_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_user_tel(from._internal_user_tel());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_user_domain(from._internal_user_domain());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gender_ = from._impl_.gender_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.department_id_ = from._impl_.department_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nick_name_, lhs_arena,
      &other->_impl_.nick_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_url_, lhs_arena,
      &other->_impl_.avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_real_name_, lhs_arena,
      &other->_impl_.user_real_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_tel_, lhs_arena,
      &other->_impl_.user_tel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_domain_, lhs_arena,
      &other->_impl_.user_domain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.status_)
      + sizeof(UserInfo::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string UserInfo::GetTypeName() const {
  return "Bohan.BaseDefine.UserInfo";
}


// ===================================================================

class ContactSessionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactSessionInfo>()._impl_._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_session_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

ContactSessionInfo::ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.ContactSessionInfo)
}
ContactSessionInfo::ContactSessionInfo(const ContactSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ContactSessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.session_status_){}
    , decltype(_impl_.updated_time_){}
    , decltype(_impl_.latest_msg_id_){}
    , decltype(_impl_.latest_msg_from_user_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.latest_msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    _this->_impl_.latest_msg_data_.Set(from._internal_latest_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_msg_type_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.ContactSessionInfo)
}

inline void ContactSessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){0u}
    , decltype(_impl_.session_status_){0}
    , decltype(_impl_.updated_time_){0u}
    , decltype(_impl_.latest_msg_id_){0u}
    , decltype(_impl_.latest_msg_from_user_id_){0u}
    , decltype(_impl_.session_type_){1}
    , decltype(_impl_.latest_msg_type_){1}
  };
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContactSessionInfo::~ContactSessionInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.ContactSessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContactSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latest_msg_data_.Destroy();
}

void ContactSessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContactSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
    _impl_.session_type_ = 1;
    _impl_.latest_msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContactSessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::Bohan::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.SessionStatusType session_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::SessionStatusType_IsValid(val))) {
            _internal_set_session_status(static_cast<::Bohan::BaseDefine::SessionStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 updated_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_updated_time(&has_bits);
          _impl_.updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          _impl_.latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::Bohan::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          _impl_.latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.ContactSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required .Bohan.BaseDefine.SessionStatusType session_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_session_status(), target);
  }

  // required uint32 updated_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_updated_time(), target);
  }

  // required uint32 latest_msg_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_latest_msg_data(), target);
  }

  // required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.ContactSessionInfo)
  return target;
}

size_t ContactSessionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_session_status()) {
    // required .Bohan.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_status());
  }

  if (_internal_has_updated_time()) {
    // required uint32 updated_time = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .Bohan.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t ContactSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.ContactSessionInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required .Bohan.BaseDefine.SessionStatusType session_status = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_status());

    // required uint32 updated_time = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());

    // required uint32 latest_msg_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .Bohan.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContactSessionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContactSessionInfo*>(
      &from));
}

void ContactSessionInfo::MergeFrom(const ContactSessionInfo& from) {
  ContactSessionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.ContactSessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.session_id_ = from._impl_.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.session_status_ = from._impl_.session_status_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.updated_time_ = from._impl_.updated_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.latest_msg_id_ = from._impl_.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.latest_msg_from_user_id_ = from._impl_.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.session_type_ = from._impl_.session_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.latest_msg_type_ = from._impl_.latest_msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContactSessionInfo::CopyFrom(const ContactSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.ContactSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactSessionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ContactSessionInfo::InternalSwap(ContactSessionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.latest_msg_data_, lhs_arena,
      &other->_impl_.latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContactSessionInfo, _impl_.latest_msg_from_user_id_)
      + sizeof(ContactSessionInfo::_impl_.latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(ContactSessionInfo, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
  swap(_impl_.session_type_, other->_impl_.session_type_);
  swap(_impl_.latest_msg_type_, other->_impl_.latest_msg_type_);
}

std::string ContactSessionInfo::GetTypeName() const {
  return "Bohan.BaseDefine.ContactSessionInfo";
}


// ===================================================================

class UserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<UserStat>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserStat::UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.UserStat)
}
UserStat::UserStat(const UserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserStat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.UserStat)
}

inline void UserStat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.status_){1}
  };
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.UserStat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.user_id_ = 0u;
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserStat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::Bohan::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.UserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .Bohan.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.UserStat)
  return target;
}

size_t UserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.UserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .Bohan.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t UserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.UserStat)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .Bohan.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserStat*>(
      &from));
}

void UserStat::MergeFrom(const UserStat& from) {
  UserStat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.UserStat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserStat::CopyFrom(const UserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.UserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserStat::InternalSwap(UserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.user_id_, other->_impl_.user_id_);
  swap(_impl_.status_, other->_impl_.status_);
}

std::string UserStat::GetTypeName() const {
  return "Bohan.BaseDefine.UserStat";
}


// ===================================================================

class ServerUserStat::_Internal {
 public:
  using HasBits = decltype(std::declval<ServerUserStat>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ServerUserStat::ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.ServerUserStat)
}
ServerUserStat::ServerUserStat(const ServerUserStat& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ServerUserStat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.client_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_type_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.client_type_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.ServerUserStat)
}

inline void ServerUserStat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.status_){1}
    , decltype(_impl_.client_type_){1}
  };
}

ServerUserStat::~ServerUserStat() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.ServerUserStat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServerUserStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServerUserStat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ServerUserStat::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    _impl_.user_id_ = 0u;
    _impl_.status_ = 1;
    _impl_.client_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServerUserStat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.UserStatType status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::UserStatType_IsValid(val))) {
            _internal_set_status(static_cast<::Bohan::BaseDefine::UserStatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.ClientType client_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_client_type(static_cast<::Bohan::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServerUserStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.ServerUserStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .Bohan.BaseDefine.UserStatType status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // required .Bohan.BaseDefine.ClientType client_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_client_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.ServerUserStat)
  return target;
}

size_t ServerUserStat::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_status()) {
    // required .Bohan.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (_internal_has_client_type()) {
    // required .Bohan.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_client_type());
  }

  return total_size;
}
size_t ServerUserStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.ServerUserStat)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required .Bohan.BaseDefine.UserStatType status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());

    // required .Bohan.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerUserStat::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServerUserStat*>(
      &from));
}

void ServerUserStat::MergeFrom(const ServerUserStat& from) {
  ServerUserStat* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.ServerUserStat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_type_ = from._impl_.client_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServerUserStat::CopyFrom(const ServerUserStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.ServerUserStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerUserStat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ServerUserStat::InternalSwap(ServerUserStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.user_id_, other->_impl_.user_id_);
  swap(_impl_.status_, other->_impl_.status_);
  swap(_impl_.client_type_, other->_impl_.client_type_);
}

std::string ServerUserStat::GetTypeName() const {
  return "Bohan.BaseDefine.ServerUserStat";
}


// ===================================================================

class UnreadInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UnreadInfo>()._impl_._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_unread_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_latest_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_latest_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_latest_msg_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

UnreadInfo::UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.UnreadInfo)
}
UnreadInfo::UnreadInfo(const UnreadInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UnreadInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.unread_cnt_){}
    , decltype(_impl_.latest_msg_id_){}
    , decltype(_impl_.latest_msg_from_user_id_){}
    , decltype(_impl_.session_type_){}
    , decltype(_impl_.latest_msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_latest_msg_data()) {
    _this->_impl_.latest_msg_data_.Set(from._internal_latest_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.session_id_, &from._impl_.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latest_msg_type_) -
    reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_type_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.UnreadInfo)
}

inline void UnreadInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latest_msg_data_){}
    , decltype(_impl_.session_id_){0u}
    , decltype(_impl_.unread_cnt_){0u}
    , decltype(_impl_.latest_msg_id_){0u}
    , decltype(_impl_.latest_msg_from_user_id_){0u}
    , decltype(_impl_.session_type_){1}
    , decltype(_impl_.latest_msg_type_){1}
  };
  _impl_.latest_msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnreadInfo::~UnreadInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.UnreadInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnreadInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.latest_msg_data_.Destroy();
}

void UnreadInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnreadInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.latest_msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.session_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.latest_msg_from_user_id_) -
        reinterpret_cast<char*>(&_impl_.session_id_)) + sizeof(_impl_.latest_msg_from_user_id_));
    _impl_.session_type_ = 1;
    _impl_.latest_msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnreadInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_session_id(&has_bits);
          _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.SessionType session_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::SessionType_IsValid(val))) {
            _internal_set_session_type(static_cast<::Bohan::BaseDefine::SessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 unread_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unread_cnt(&has_bits);
          _impl_.unread_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_latest_msg_id(&has_bits);
          _impl_.latest_msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes latest_msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_latest_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_latest_msg_type(static_cast<::Bohan::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 latest_msg_from_user_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_latest_msg_from_user_id(&has_bits);
          _impl_.latest_msg_from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnreadInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.UnreadInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 session_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_session_id(), target);
  }

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_session_type(), target);
  }

  // required uint32 unread_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unread_cnt(), target);
  }

  // required uint32 latest_msg_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latest_msg_id(), target);
  }

  // required bytes latest_msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_latest_msg_data(), target);
  }

  // required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_latest_msg_type(), target);
  }

  // required uint32 latest_msg_from_user_id = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_latest_msg_from_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.UnreadInfo)
  return target;
}

size_t UnreadInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (_internal_has_latest_msg_data()) {
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());
  }

  if (_internal_has_session_id()) {
    // required uint32 session_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());
  }

  if (_internal_has_unread_cnt()) {
    // required uint32 unread_cnt = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());
  }

  if (_internal_has_latest_msg_id()) {
    // required uint32 latest_msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());
  }

  if (_internal_has_latest_msg_from_user_id()) {
    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());
  }

  if (_internal_has_session_type()) {
    // required .Bohan.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
  }

  if (_internal_has_latest_msg_type()) {
    // required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());
  }

  return total_size;
}
size_t UnreadInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.UnreadInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required bytes latest_msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_latest_msg_data());

    // required uint32 session_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_session_id());

    // required uint32 unread_cnt = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());

    // required uint32 latest_msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_id());

    // required uint32 latest_msg_from_user_id = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latest_msg_from_user_id());

    // required .Bohan.BaseDefine.SessionType session_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());

    // required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_latest_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnreadInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UnreadInfo*>(
      &from));
}

void UnreadInfo::MergeFrom(const UnreadInfo& from) {
  UnreadInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.UnreadInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_latest_msg_data(from._internal_latest_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.session_id_ = from._impl_.session_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.unread_cnt_ = from._impl_.unread_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.latest_msg_id_ = from._impl_.latest_msg_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.latest_msg_from_user_id_ = from._impl_.latest_msg_from_user_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.session_type_ = from._impl_.session_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.latest_msg_type_ = from._impl_.latest_msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnreadInfo::CopyFrom(const UnreadInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.UnreadInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnreadInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UnreadInfo::InternalSwap(UnreadInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.latest_msg_data_, lhs_arena,
      &other->_impl_.latest_msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnreadInfo, _impl_.latest_msg_from_user_id_)
      + sizeof(UnreadInfo::_impl_.latest_msg_from_user_id_)
      - PROTOBUF_FIELD_OFFSET(UnreadInfo, _impl_.session_id_)>(
          reinterpret_cast<char*>(&_impl_.session_id_),
          reinterpret_cast<char*>(&other->_impl_.session_id_));
  swap(_impl_.session_type_, other->_impl_.session_type_);
  swap(_impl_.latest_msg_type_, other->_impl_.latest_msg_type_);
}

std::string UnreadInfo::GetTypeName() const {
  return "Bohan.BaseDefine.UnreadInfo";
}


// ===================================================================

class MsgInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgInfo>()._impl_._has_bits_);
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_create_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

MsgInfo::MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.MsgInfo)
}
MsgInfo::MsgInfo(const MsgInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.from_session_id_){}
    , decltype(_impl_.create_time_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_id_, &from._impl_.msg_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.MsgInfo)
}

inline void MsgInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.from_session_id_){0u}
    , decltype(_impl_.create_time_){0u}
    , decltype(_impl_.msg_type_){1}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.MsgInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void MsgInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.msg_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.create_time_) -
        reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.create_time_));
    _impl_.msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_session_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_from_session_id(&has_bits);
          _impl_.from_session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 create_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_create_time(&has_bits);
          _impl_.create_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.MsgType msg_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::Bohan::BaseDefine::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes msg_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.MsgInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 msg_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // required uint32 from_session_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_session_id(), target);
  }

  // required uint32 create_time = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_create_time(), target);
  }

  // required .Bohan.BaseDefine.MsgType msg_type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_msg_type(), target);
  }

  // required bytes msg_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.MsgInfo)
  return target;
}

size_t MsgInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (_internal_has_msg_data()) {
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  if (_internal_has_from_session_id()) {
    // required uint32 from_session_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());
  }

  if (_internal_has_create_time()) {
    // required uint32 create_time = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());
  }

  if (_internal_has_msg_type()) {
    // required .Bohan.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.MsgInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required bytes msg_data = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg_data());

    // required uint32 msg_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

    // required uint32 from_session_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_session_id());

    // required uint32 create_time = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_create_time());

    // required .Bohan.BaseDefine.MsgType msg_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgInfo*>(
      &from));
}

void MsgInfo::MergeFrom(const MsgInfo& from) {
  MsgInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.MsgInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_session_id_ = from._impl_.from_session_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.create_time_ = from._impl_.create_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.MsgInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgInfo::InternalSwap(MsgInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.create_time_)
      + sizeof(MsgInfo::_impl_.create_time_)
      - PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.msg_id_)>(
          reinterpret_cast<char*>(&_impl_.msg_id_),
          reinterpret_cast<char*>(&other->_impl_.msg_id_));
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

std::string MsgInfo::GetTypeName() const {
  return "Bohan.BaseDefine.MsgInfo";
}


// ===================================================================

class GroupVersionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupVersionInfo>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupVersionInfo::GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.GroupVersionInfo)
}
GroupVersionInfo::GroupVersionInfo(const GroupVersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupVersionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.GroupVersionInfo)
}

inline void GroupVersionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.version_){0u}
  };
}

GroupVersionInfo::~GroupVersionInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.GroupVersionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupVersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupVersionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupVersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupVersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupVersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.GroupVersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.GroupVersionInfo)
  return target;
}

size_t GroupVersionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  return total_size;
}
size_t GroupVersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.GroupVersionInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupVersionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupVersionInfo*>(
      &from));
}

void GroupVersionInfo::MergeFrom(const GroupVersionInfo& from) {
  GroupVersionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.GroupVersionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupVersionInfo::CopyFrom(const GroupVersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.GroupVersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupVersionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupVersionInfo::InternalSwap(GroupVersionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupVersionInfo, _impl_.version_)
      + sizeof(GroupVersionInfo::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(GroupVersionInfo, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupVersionInfo::GetTypeName() const {
  return "Bohan.BaseDefine.GroupVersionInfo";
}


// ===================================================================

class GroupInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupInfo>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_creator_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

GroupInfo::GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.GroupInfo)
}
GroupInfo::GroupInfo(const GroupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_member_list_){from._impl_.group_member_list_}
    , decltype(_impl_.group_name_){}
    , decltype(_impl_.group_avatar_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.group_creator_id_){}
    , decltype(_impl_.group_type_){}
    , decltype(_impl_.shield_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_name()) {
    _this->_impl_.group_name_.Set(from._internal_group_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.group_avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_avatar()) {
    _this->_impl_.group_avatar_.Set(from._internal_group_avatar(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shield_status_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.shield_status_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.GroupInfo)
}

inline void GroupInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_member_list_){arena}
    , decltype(_impl_.group_name_){}
    , decltype(_impl_.group_avatar_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.group_creator_id_){0u}
    , decltype(_impl_.group_type_){0}
    , decltype(_impl_.shield_status_){0u}
  };
  _impl_.group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.GroupInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_member_list_.~RepeatedField();
  _impl_.group_name_.Destroy();
  _impl_.group_avatar_.Destroy();
}

void GroupInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_member_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.group_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.group_avatar_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shield_status_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.shield_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_avatar = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_group_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_creator_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_group_creator_id(&has_bits);
          _impl_.group_creator_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.GroupType group_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::Bohan::BaseDefine::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_shield_status(&has_bits);
          _impl_.shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 group_member_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_group_member_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_group_member_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.GroupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 version = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version(), target);
  }

  // required string group_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_group_name(), target);
  }

  // required string group_avatar = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_group_avatar(), target);
  }

  // required uint32 group_creator_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_group_creator_id(), target);
  }

  // required .Bohan.BaseDefine.GroupType group_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_group_type(), target);
  }

  // required uint32 shield_status = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_shield_status(), target);
  }

  // repeated uint32 group_member_list = 8;
  for (int i = 0, n = this->_internal_group_member_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_group_member_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.GroupInfo)
  return target;
}

size_t GroupInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (_internal_has_group_name()) {
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());
  }

  if (_internal_has_group_avatar()) {
    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_version()) {
    // required uint32 version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  if (_internal_has_group_creator_id()) {
    // required uint32 group_creator_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());
  }

  if (_internal_has_group_type()) {
    // required .Bohan.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t GroupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.GroupInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string group_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_name());

    // required string group_avatar = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_avatar());

    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());

    // required uint32 group_creator_id = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_creator_id());

    // required .Bohan.BaseDefine.GroupType group_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());

    // required uint32 shield_status = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 group_member_list = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.group_member_list_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_group_member_list_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupInfo*>(
      &from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
  GroupInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.GroupInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_member_list_.MergeFrom(from._impl_.group_member_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_group_name(from._internal_group_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_group_avatar(from._internal_group_avatar());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.group_creator_id_ = from._impl_.group_creator_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.group_type_ = from._impl_.group_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shield_status_ = from._impl_.shield_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.GroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupInfo::InternalSwap(GroupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.group_member_list_.InternalSwap(&other->_impl_.group_member_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_name_, lhs_arena,
      &other->_impl_.group_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_avatar_, lhs_arena,
      &other->_impl_.group_avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.shield_status_)
      + sizeof(GroupInfo::_impl_.shield_status_)
      - PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupInfo::GetTypeName() const {
  return "Bohan.BaseDefine.GroupInfo";
}


// ===================================================================

class UserTokenInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserTokenInfo>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_push_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_push_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

UserTokenInfo::UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.UserTokenInfo)
}
UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserTokenInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.push_count_){}
    , decltype(_impl_.push_type_){}
    , decltype(_impl_.user_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_type_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.user_type_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.UserTokenInfo)
}

inline void UserTokenInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.push_count_){0u}
    , decltype(_impl_.push_type_){0u}
    , decltype(_impl_.user_type_){1}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.UserTokenInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserTokenInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
}

void UserTokenInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserTokenInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.push_type_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.push_type_));
    _impl_.user_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserTokenInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.ClientType user_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::ClientType_IsValid(val))) {
            _internal_set_user_type(static_cast<::Bohan::BaseDefine::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_push_count(&has_bits);
          _impl_.push_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 push_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_push_type(&has_bits);
          _impl_.push_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserTokenInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.UserTokenInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required .Bohan.BaseDefine.ClientType user_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_user_type(), target);
  }

  // required string token = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_token(), target);
  }

  // required uint32 push_count = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_push_count(), target);
  }

  // required uint32 push_type = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_push_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.UserTokenInfo)
  return target;
}

size_t UserTokenInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (_internal_has_token()) {
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_push_count()) {
    // required uint32 push_count = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());
  }

  if (_internal_has_push_type()) {
    // required uint32 push_type = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());
  }

  if (_internal_has_user_type()) {
    // required .Bohan.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_user_type());
  }

  return total_size;
}
size_t UserTokenInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.UserTokenInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string token = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());

    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 push_count = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_count());

    // required uint32 push_type = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_push_type());

    // required .Bohan.BaseDefine.ClientType user_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_user_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTokenInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserTokenInfo*>(
      &from));
}

void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
  UserTokenInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.UserTokenInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.push_count_ = from._impl_.push_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.push_type_ = from._impl_.push_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.user_type_ = from._impl_.user_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.UserTokenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserTokenInfo::InternalSwap(UserTokenInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserTokenInfo, _impl_.push_type_)
      + sizeof(UserTokenInfo::_impl_.push_type_)
      - PROTOBUF_FIELD_OFFSET(UserTokenInfo, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
  swap(_impl_.user_type_, other->_impl_.user_type_);
}

std::string UserTokenInfo::GetTypeName() const {
  return "Bohan.BaseDefine.UserTokenInfo";
}


// ===================================================================

class PushResult::_Internal {
 public:
  using HasBits = decltype(std::declval<PushResult>()._impl_._has_bits_);
  static void set_has_user_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PushResult::PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.PushResult)
}
PushResult::PushResult(const PushResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PushResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_token_){}
    , decltype(_impl_.result_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.user_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_token()) {
    _this->_impl_.user_token_.Set(from._internal_user_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.result_code_ = from._impl_.result_code_;
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.PushResult)
}

inline void PushResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_token_){}
    , decltype(_impl_.result_code_){0u}
  };
  _impl_.user_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.PushResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PushResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_token_.Destroy();
}

void PushResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PushResult::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.user_token_.ClearNonDefaultToEmpty();
  }
  _impl_.result_code_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PushResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string user_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          _impl_.result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.PushResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string user_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_token(), target);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_result_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.PushResult)
  return target;
}

size_t PushResult::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.PushResult)
  size_t total_size = 0;

  if (_internal_has_user_token()) {
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());
  }

  if (_internal_has_result_code()) {
    // required uint32 result_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());
  }

  return total_size;
}
size_t PushResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.PushResult)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_token());

    // required uint32 result_code = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PushResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PushResult*>(
      &from));
}

void PushResult::MergeFrom(const PushResult& from) {
  PushResult* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.PushResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_user_token(from._internal_user_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_code_ = from._impl_.result_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PushResult::CopyFrom(const PushResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.PushResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PushResult::InternalSwap(PushResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_token_, lhs_arena,
      &other->_impl_.user_token_, rhs_arena
  );
  swap(_impl_.result_code_, other->_impl_.result_code_);
}

std::string PushResult::GetTypeName() const {
  return "Bohan.BaseDefine.PushResult";
}


// ===================================================================

class ShieldStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ShieldStatus>()._impl_._has_bits_);
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shield_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ShieldStatus::ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.ShieldStatus)
}
ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ShieldStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.shield_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_id_, &from._impl_.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shield_status_) -
    reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.shield_status_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.ShieldStatus)
}

inline void ShieldStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_id_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.shield_status_){0u}
  };
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.ShieldStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShieldStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShieldStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShieldStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.shield_status_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.shield_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShieldStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_id(&has_bits);
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 shield_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shield_status(&has_bits);
          _impl_.shield_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShieldStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.ShieldStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_user_id(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // required uint32 shield_status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_shield_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.ShieldStatus)
  return target;
}

size_t ShieldStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (_internal_has_user_id()) {
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_shield_status()) {
    // required uint32 shield_status = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());
  }

  return total_size;
}
size_t ShieldStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.ShieldStatus)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_user_id());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 shield_status = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shield_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShieldStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShieldStatus*>(
      &from));
}

void ShieldStatus::MergeFrom(const ShieldStatus& from) {
  ShieldStatus* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.ShieldStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.shield_status_ = from._impl_.shield_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.ShieldStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ShieldStatus::InternalSwap(ShieldStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShieldStatus, _impl_.shield_status_)
      + sizeof(ShieldStatus::_impl_.shield_status_)
      - PROTOBUF_FIELD_OFFSET(ShieldStatus, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

std::string ShieldStatus::GetTypeName() const {
  return "Bohan.BaseDefine.ShieldStatus";
}


// ===================================================================

class OfflineFileInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OfflineFileInfo>()._impl_._has_bits_);
  static void set_has_from_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_task_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

OfflineFileInfo::OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.OfflineFileInfo)
}
OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OfflineFileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.task_id_){}
    , decltype(_impl_.file_name_){}
    , decltype(_impl_.from_user_id_){}
    , decltype(_impl_.file_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_task_id()) {
    _this->_impl_.task_id_.Set(from._internal_task_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_name()) {
    _this->_impl_.file_name_.Set(from._internal_file_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.from_user_id_, &from._impl_.from_user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.file_size_) -
    reinterpret_cast<char*>(&_impl_.from_user_id_)) + sizeof(_impl_.file_size_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.OfflineFileInfo)
}

inline void OfflineFileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.task_id_){}
    , decltype(_impl_.file_name_){}
    , decltype(_impl_.from_user_id_){0u}
    , decltype(_impl_.file_size_){0u}
  };
  _impl_.task_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.task_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.OfflineFileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OfflineFileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.task_id_.Destroy();
  _impl_.file_name_.Destroy();
}

void OfflineFileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OfflineFileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.task_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.from_user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.file_size_) -
        reinterpret_cast<char*>(&_impl_.from_user_id_)) + sizeof(_impl_.file_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OfflineFileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 from_user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_from_user_id(&has_bits);
          _impl_.from_user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_task_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_file_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 file_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_file_size(&has_bits);
          _impl_.file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfflineFileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.OfflineFileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 from_user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_from_user_id(), target);
  }

  // required string task_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_task_id(), target);
  }

  // required string file_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_file_name(), target);
  }

  // required uint32 file_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_file_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.OfflineFileInfo)
  return target;
}

size_t OfflineFileInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (_internal_has_task_id()) {
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());
  }

  if (_internal_has_file_name()) {
    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());
  }

  if (_internal_has_from_user_id()) {
    // required uint32 from_user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());
  }

  if (_internal_has_file_size()) {
    // required uint32 file_size = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());
  }

  return total_size;
}
size_t OfflineFileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.OfflineFileInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string task_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_task_id());

    // required string file_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_name());

    // required uint32 from_user_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_user_id());

    // required uint32 file_size = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OfflineFileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OfflineFileInfo*>(
      &from));
}

void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
  OfflineFileInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.OfflineFileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_task_id(from._internal_task_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_user_id_ = from._impl_.from_user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.file_size_ = from._impl_.file_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.OfflineFileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void OfflineFileInfo::InternalSwap(OfflineFileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.task_id_, lhs_arena,
      &other->_impl_.task_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_name_, lhs_arena,
      &other->_impl_.file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfflineFileInfo, _impl_.file_size_)
      + sizeof(OfflineFileInfo::_impl_.file_size_)
      - PROTOBUF_FIELD_OFFSET(OfflineFileInfo, _impl_.from_user_id_)>(
          reinterpret_cast<char*>(&_impl_.from_user_id_),
          reinterpret_cast<char*>(&other->_impl_.from_user_id_));
}

std::string OfflineFileInfo::GetTypeName() const {
  return "Bohan.BaseDefine.OfflineFileInfo";
}


// ===================================================================

class DepartInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DepartInfo>()._impl_._has_bits_);
  static void set_has_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dept_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_dept_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dept_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

DepartInfo::DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Bohan.BaseDefine.DepartInfo)
}
DepartInfo::DepartInfo(const DepartInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DepartInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dept_name_){}
    , decltype(_impl_.dept_id_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.parent_dept_id_){}
    , decltype(_impl_.dept_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.dept_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dept_name()) {
    _this->_impl_.dept_name_.Set(from._internal_dept_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dept_id_, &from._impl_.dept_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dept_status_) -
    reinterpret_cast<char*>(&_impl_.dept_id_)) + sizeof(_impl_.dept_status_));
  // @@protoc_insertion_point(copy_constructor:Bohan.BaseDefine.DepartInfo)
}

inline void DepartInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dept_name_){}
    , decltype(_impl_.dept_id_){0u}
    , decltype(_impl_.priority_){0u}
    , decltype(_impl_.parent_dept_id_){0u}
    , decltype(_impl_.dept_status_){0}
  };
  _impl_.dept_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DepartInfo::~DepartInfo() {
  // @@protoc_insertion_point(destructor:Bohan.BaseDefine.DepartInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DepartInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dept_name_.Destroy();
}

void DepartInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DepartInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Bohan.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.dept_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.dept_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dept_status_) -
        reinterpret_cast<char*>(&_impl_.dept_id_)) + sizeof(_impl_.dept_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DepartInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 dept_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dept_id(&has_bits);
          _impl_.dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string dept_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dept_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 parent_dept_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_parent_dept_id(&has_bits);
          _impl_.parent_dept_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Bohan::BaseDefine::DepartmentStatusType_IsValid(val))) {
            _internal_set_dept_status(static_cast<::Bohan::BaseDefine::DepartmentStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DepartInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Bohan.BaseDefine.DepartInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 dept_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dept_id(), target);
  }

  // required uint32 priority = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_priority(), target);
  }

  // required string dept_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dept_name(), target);
  }

  // required uint32 parent_dept_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_parent_dept_id(), target);
  }

  // required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_dept_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Bohan.BaseDefine.DepartInfo)
  return target;
}

size_t DepartInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Bohan.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (_internal_has_dept_name()) {
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());
  }

  if (_internal_has_dept_id()) {
    // required uint32 dept_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());
  }

  if (_internal_has_priority()) {
    // required uint32 priority = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
  }

  if (_internal_has_parent_dept_id()) {
    // required uint32 parent_dept_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());
  }

  if (_internal_has_dept_status()) {
    // required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dept_status());
  }

  return total_size;
}
size_t DepartInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Bohan.BaseDefine.DepartInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string dept_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dept_name());

    // required uint32 dept_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dept_id());

    // required uint32 priority = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());

    // required uint32 parent_dept_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_dept_id());

    // required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dept_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DepartInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DepartInfo*>(
      &from));
}

void DepartInfo::MergeFrom(const DepartInfo& from) {
  DepartInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:Bohan.BaseDefine.DepartInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dept_name(from._internal_dept_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dept_id_ = from._impl_.dept_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.parent_dept_id_ = from._impl_.parent_dept_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dept_status_ = from._impl_.dept_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DepartInfo::CopyFrom(const DepartInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Bohan.BaseDefine.DepartInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepartInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DepartInfo::InternalSwap(DepartInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dept_name_, lhs_arena,
      &other->_impl_.dept_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DepartInfo, _impl_.dept_status_)
      + sizeof(DepartInfo::_impl_.dept_status_)
      - PROTOBUF_FIELD_OFFSET(DepartInfo, _impl_.dept_id_)>(
          reinterpret_cast<char*>(&_impl_.dept_id_),
          reinterpret_cast<char*>(&other->_impl_.dept_id_));
}

std::string DepartInfo::GetTypeName() const {
  return "Bohan.BaseDefine.DepartInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace BaseDefine
}  // namespace Bohan
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::IpAddr*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::IpAddr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::IpAddr >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::UserInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::ContactSessionInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::ContactSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::ContactSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::UserStat*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::UserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::UserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::ServerUserStat*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::ServerUserStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::ServerUserStat >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::UnreadInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::UnreadInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::UnreadInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::MsgInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::MsgInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::MsgInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::GroupVersionInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::GroupVersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::GroupVersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::GroupInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::GroupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::GroupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::UserTokenInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::UserTokenInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::UserTokenInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::PushResult*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::PushResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::PushResult >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::ShieldStatus*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::ShieldStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::ShieldStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::OfflineFileInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::OfflineFileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::OfflineFileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Bohan::BaseDefine::DepartInfo*
Arena::CreateMaybeMessage< ::Bohan::BaseDefine::DepartInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Bohan::BaseDefine::DepartInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
