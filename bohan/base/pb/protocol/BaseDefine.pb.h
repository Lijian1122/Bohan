// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseDefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_BaseDefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_BaseDefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_BaseDefine_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_BaseDefine_2eproto {
  static const uint32_t offsets[];
};
namespace Bohan {
namespace BaseDefine {
class ContactSessionInfo;
struct ContactSessionInfoDefaultTypeInternal;
extern ContactSessionInfoDefaultTypeInternal _ContactSessionInfo_default_instance_;
class DepartInfo;
struct DepartInfoDefaultTypeInternal;
extern DepartInfoDefaultTypeInternal _DepartInfo_default_instance_;
class GroupInfo;
struct GroupInfoDefaultTypeInternal;
extern GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
class GroupVersionInfo;
struct GroupVersionInfoDefaultTypeInternal;
extern GroupVersionInfoDefaultTypeInternal _GroupVersionInfo_default_instance_;
class IpAddr;
struct IpAddrDefaultTypeInternal;
extern IpAddrDefaultTypeInternal _IpAddr_default_instance_;
class MsgInfo;
struct MsgInfoDefaultTypeInternal;
extern MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
class OfflineFileInfo;
struct OfflineFileInfoDefaultTypeInternal;
extern OfflineFileInfoDefaultTypeInternal _OfflineFileInfo_default_instance_;
class PushResult;
struct PushResultDefaultTypeInternal;
extern PushResultDefaultTypeInternal _PushResult_default_instance_;
class ServerUserStat;
struct ServerUserStatDefaultTypeInternal;
extern ServerUserStatDefaultTypeInternal _ServerUserStat_default_instance_;
class ShieldStatus;
struct ShieldStatusDefaultTypeInternal;
extern ShieldStatusDefaultTypeInternal _ShieldStatus_default_instance_;
class UnreadInfo;
struct UnreadInfoDefaultTypeInternal;
extern UnreadInfoDefaultTypeInternal _UnreadInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserStat;
struct UserStatDefaultTypeInternal;
extern UserStatDefaultTypeInternal _UserStat_default_instance_;
class UserTokenInfo;
struct UserTokenInfoDefaultTypeInternal;
extern UserTokenInfoDefaultTypeInternal _UserTokenInfo_default_instance_;
}  // namespace BaseDefine
}  // namespace Bohan
PROTOBUF_NAMESPACE_OPEN
template<> ::Bohan::BaseDefine::ContactSessionInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::ContactSessionInfo>(Arena*);
template<> ::Bohan::BaseDefine::DepartInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::DepartInfo>(Arena*);
template<> ::Bohan::BaseDefine::GroupInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::GroupInfo>(Arena*);
template<> ::Bohan::BaseDefine::GroupVersionInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::GroupVersionInfo>(Arena*);
template<> ::Bohan::BaseDefine::IpAddr* Arena::CreateMaybeMessage<::Bohan::BaseDefine::IpAddr>(Arena*);
template<> ::Bohan::BaseDefine::MsgInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::MsgInfo>(Arena*);
template<> ::Bohan::BaseDefine::OfflineFileInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::OfflineFileInfo>(Arena*);
template<> ::Bohan::BaseDefine::PushResult* Arena::CreateMaybeMessage<::Bohan::BaseDefine::PushResult>(Arena*);
template<> ::Bohan::BaseDefine::ServerUserStat* Arena::CreateMaybeMessage<::Bohan::BaseDefine::ServerUserStat>(Arena*);
template<> ::Bohan::BaseDefine::ShieldStatus* Arena::CreateMaybeMessage<::Bohan::BaseDefine::ShieldStatus>(Arena*);
template<> ::Bohan::BaseDefine::UnreadInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::UnreadInfo>(Arena*);
template<> ::Bohan::BaseDefine::UserInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::UserInfo>(Arena*);
template<> ::Bohan::BaseDefine::UserStat* Arena::CreateMaybeMessage<::Bohan::BaseDefine::UserStat>(Arena*);
template<> ::Bohan::BaseDefine::UserTokenInfo* Arena::CreateMaybeMessage<::Bohan::BaseDefine::UserTokenInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Bohan {
namespace BaseDefine {

enum ServiceID : int {
  SID_LOGIN = 1,
  SID_BUDDY_LIST = 2,
  SID_MSG = 3,
  SID_GROUP = 4,
  SID_FILE = 5,
  SID_SWITCH_SERVICE = 6,
  SID_OTHER = 7,
  SID_INTERNAL = 8
};
bool ServiceID_IsValid(int value);
constexpr ServiceID ServiceID_MIN = SID_LOGIN;
constexpr ServiceID ServiceID_MAX = SID_INTERNAL;
constexpr int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

const std::string& ServiceID_Name(ServiceID value);
template<typename T>
inline const std::string& ServiceID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceID_Name.");
  return ServiceID_Name(static_cast<ServiceID>(enum_t_value));
}
bool ServiceID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceID* value);
enum LoginCmdID : int {
  CID_LOGIN_REQ_MSGSERVER = 257,
  CID_LOGIN_RES_MSGSERVER = 258,
  CID_LOGIN_REQ_USERLOGIN = 259,
  CID_LOGIN_RES_USERLOGIN = 260,
  CID_LOGIN_REQ_LOGINOUT = 261,
  CID_LOGIN_RES_LOGINOUT = 262,
  CID_LOGIN_KICK_USER = 263,
  CID_LOGIN_REQ_DEVICETOKEN = 264,
  CID_LOGIN_RES_DEVICETOKEN = 265,
  CID_LOGIN_REQ_KICKPCCLIENT = 266,
  CID_LOGIN_RES_KICKPCCLIENT = 267
};
bool LoginCmdID_IsValid(int value);
constexpr LoginCmdID LoginCmdID_MIN = CID_LOGIN_REQ_MSGSERVER;
constexpr LoginCmdID LoginCmdID_MAX = CID_LOGIN_RES_KICKPCCLIENT;
constexpr int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

const std::string& LoginCmdID_Name(LoginCmdID value);
template<typename T>
inline const std::string& LoginCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginCmdID_Name.");
  return LoginCmdID_Name(static_cast<LoginCmdID>(enum_t_value));
}
bool LoginCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginCmdID* value);
enum BuddyListCmdID : int {
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST = 513,
  CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE = 514,
  CID_BUDDY_LIST_STATUS_NOTIFY = 515,
  CID_BUDDY_LIST_USER_INFO_REQUEST = 516,
  CID_BUDDY_LIST_USER_INFO_RESPONSE = 517,
  CID_BUDDY_LIST_REMOVE_SESSION_REQ = 518,
  CID_BUDDY_LIST_REMOVE_SESSION_RES = 519,
  CID_BUDDY_LIST_ALL_USER_REQUEST = 520,
  CID_BUDDY_LIST_ALL_USER_RESPONSE = 521,
  CID_BUDDY_LIST_USERS_STATUS_REQUEST = 522,
  CID_BUDDY_LIST_USERS_STATUS_RESPONSE = 523,
  CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 524,
  CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 525,
  CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY = 526,
  CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY = 527,
  CID_BUDDY_LIST_DEPARTMENT_REQUEST = 528,
  CID_BUDDY_LIST_DEPARTMENT_RESPONSE = 529
};
bool BuddyListCmdID_IsValid(int value);
constexpr BuddyListCmdID BuddyListCmdID_MIN = CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST;
constexpr BuddyListCmdID BuddyListCmdID_MAX = CID_BUDDY_LIST_DEPARTMENT_RESPONSE;
constexpr int BuddyListCmdID_ARRAYSIZE = BuddyListCmdID_MAX + 1;

const std::string& BuddyListCmdID_Name(BuddyListCmdID value);
template<typename T>
inline const std::string& BuddyListCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BuddyListCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BuddyListCmdID_Name.");
  return BuddyListCmdID_Name(static_cast<BuddyListCmdID>(enum_t_value));
}
bool BuddyListCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyListCmdID* value);
enum MessageCmdID : int {
  CID_MSG_DATA = 769,
  CID_MSG_DATA_ACK = 770,
  CID_MSG_READ_ACK = 771,
  CID_MSG_READ_NOTIFY = 772,
  CID_MSG_TIME_REQUEST = 773,
  CID_MSG_TIME_RESPONSE = 774,
  CID_MSG_UNREAD_CNT_REQUEST = 775,
  CID_MSG_UNREAD_CNT_RESPONSE = 776,
  CID_MSG_LIST_REQUEST = 777,
  CID_MSG_LIST_RESPONSE = 778,
  CID_MSG_GET_LATEST_MSG_ID_REQ = 779,
  CID_MSG_GET_LATEST_MSG_ID_RSP = 780,
  CID_MSG_GET_BY_MSG_ID_REQ = 781,
  CID_MSG_GET_BY_MSG_ID_RES = 782
};
bool MessageCmdID_IsValid(int value);
constexpr MessageCmdID MessageCmdID_MIN = CID_MSG_DATA;
constexpr MessageCmdID MessageCmdID_MAX = CID_MSG_GET_BY_MSG_ID_RES;
constexpr int MessageCmdID_ARRAYSIZE = MessageCmdID_MAX + 1;

const std::string& MessageCmdID_Name(MessageCmdID value);
template<typename T>
inline const std::string& MessageCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageCmdID_Name.");
  return MessageCmdID_Name(static_cast<MessageCmdID>(enum_t_value));
}
bool MessageCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageCmdID* value);
enum GroupCmdID : int {
  CID_GROUP_NORMAL_LIST_REQUEST = 1025,
  CID_GROUP_NORMAL_LIST_RESPONSE = 1026,
  CID_GROUP_INFO_REQUEST = 1027,
  CID_GROUP_INFO_RESPONSE = 1028,
  CID_GROUP_CREATE_REQUEST = 1029,
  CID_GROUP_CREATE_RESPONSE = 1030,
  CID_GROUP_CHANGE_MEMBER_REQUEST = 1031,
  CID_GROUP_CHANGE_MEMBER_RESPONSE = 1032,
  CID_GROUP_SHIELD_GROUP_REQUEST = 1033,
  CID_GROUP_SHIELD_GROUP_RESPONSE = 1034,
  CID_GROUP_CHANGE_MEMBER_NOTIFY = 1035
};
bool GroupCmdID_IsValid(int value);
constexpr GroupCmdID GroupCmdID_MIN = CID_GROUP_NORMAL_LIST_REQUEST;
constexpr GroupCmdID GroupCmdID_MAX = CID_GROUP_CHANGE_MEMBER_NOTIFY;
constexpr int GroupCmdID_ARRAYSIZE = GroupCmdID_MAX + 1;

const std::string& GroupCmdID_Name(GroupCmdID value);
template<typename T>
inline const std::string& GroupCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupCmdID_Name.");
  return GroupCmdID_Name(static_cast<GroupCmdID>(enum_t_value));
}
bool GroupCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupCmdID* value);
enum FileCmdID : int {
  CID_FILE_LOGIN_REQ = 1281,
  CID_FILE_LOGIN_RES = 1282,
  CID_FILE_STATE = 1283,
  CID_FILE_PULL_DATA_REQ = 1284,
  CID_FILE_PULL_DATA_RSP = 1285,
  CID_FILE_REQUEST = 1286,
  CID_FILE_RESPONSE = 1287,
  CID_FILE_NOTIFY = 1288,
  CID_FILE_HAS_OFFLINE_REQ = 1289,
  CID_FILE_HAS_OFFLINE_RES = 1290,
  CID_FILE_ADD_OFFLINE_REQ = 1291,
  CID_FILE_DEL_OFFLINE_REQ = 1292
};
bool FileCmdID_IsValid(int value);
constexpr FileCmdID FileCmdID_MIN = CID_FILE_LOGIN_REQ;
constexpr FileCmdID FileCmdID_MAX = CID_FILE_DEL_OFFLINE_REQ;
constexpr int FileCmdID_ARRAYSIZE = FileCmdID_MAX + 1;

const std::string& FileCmdID_Name(FileCmdID value);
template<typename T>
inline const std::string& FileCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileCmdID_Name.");
  return FileCmdID_Name(static_cast<FileCmdID>(enum_t_value));
}
bool FileCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileCmdID* value);
enum SwitchServiceCmdID : int {
  CID_SWITCH_P2P_CMD = 1537
};
bool SwitchServiceCmdID_IsValid(int value);
constexpr SwitchServiceCmdID SwitchServiceCmdID_MIN = CID_SWITCH_P2P_CMD;
constexpr SwitchServiceCmdID SwitchServiceCmdID_MAX = CID_SWITCH_P2P_CMD;
constexpr int SwitchServiceCmdID_ARRAYSIZE = SwitchServiceCmdID_MAX + 1;

const std::string& SwitchServiceCmdID_Name(SwitchServiceCmdID value);
template<typename T>
inline const std::string& SwitchServiceCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwitchServiceCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwitchServiceCmdID_Name.");
  return SwitchServiceCmdID_Name(static_cast<SwitchServiceCmdID>(enum_t_value));
}
bool SwitchServiceCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchServiceCmdID* value);
enum OtherCmdID : int {
  CID_OTHER_HEARTBEAT = 1793,
  CID_OTHER_STOP_RECV_PACKET = 1795,
  CID_OTHER_VALIDATE_RSP = 1796,
  CID_OTHER_GET_DEVICE_TOKEN_REQ = 1797,
  CID_OTHER_GET_DEVICE_TOKEN_RSP = 1798,
  CID_OTHER_ROLE_SET = 1799,
  CID_OTHER_ONLINE_USER_INFO = 1800,
  CID_OTHER_MSG_SERV_INFO = 1801,
  CID_OTHER_USER_STATUS_UPDATE = 1802,
  CID_OTHER_USER_CNT_UPDATE = 1803,
  CID_OTHER_SERVER_KICK_USER = 1805,
  CID_OTHER_LOGIN_STATUS_NOTIFY = 1806,
  CID_OTHER_PUSH_TO_USER_REQ = 1807,
  CID_OTHER_PUSH_TO_USER_RSP = 1808,
  CID_OTHER_GET_SHIELD_REQ = 1809,
  CID_OTHER_GET_SHIELD_RSP = 1810,
  CID_OTHER_FILE_TRANSFER_REQ = 1841,
  CID_OTHER_FILE_TRANSFER_RSP = 1842,
  CID_OTHER_FILE_SERVER_IP_REQ = 1843,
  CID_OTHER_FILE_SERVER_IP_RSP = 1844
};
bool OtherCmdID_IsValid(int value);
constexpr OtherCmdID OtherCmdID_MIN = CID_OTHER_HEARTBEAT;
constexpr OtherCmdID OtherCmdID_MAX = CID_OTHER_FILE_SERVER_IP_RSP;
constexpr int OtherCmdID_ARRAYSIZE = OtherCmdID_MAX + 1;

const std::string& OtherCmdID_Name(OtherCmdID value);
template<typename T>
inline const std::string& OtherCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OtherCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OtherCmdID_Name.");
  return OtherCmdID_Name(static_cast<OtherCmdID>(enum_t_value));
}
bool OtherCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OtherCmdID* value);
enum ResultType : int {
  REFUSE_REASON_NONE = 0,
  REFUSE_REASON_NO_MSG_SERVER = 1,
  REFUSE_REASON_MSG_SERVER_FULL = 2,
  REFUSE_REASON_NO_DB_SERVER = 3,
  REFUSE_REASON_NO_LOGIN_SERVER = 4,
  REFUSE_REASON_NO_ROUTE_SERVER = 5,
  REFUSE_REASON_DB_VALIDATE_FAILED = 6,
  REFUSE_REASON_VERSION_TOO_OLD = 7
};
bool ResultType_IsValid(int value);
constexpr ResultType ResultType_MIN = REFUSE_REASON_NONE;
constexpr ResultType ResultType_MAX = REFUSE_REASON_VERSION_TOO_OLD;
constexpr int ResultType_ARRAYSIZE = ResultType_MAX + 1;

const std::string& ResultType_Name(ResultType value);
template<typename T>
inline const std::string& ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultType_Name.");
  return ResultType_Name(static_cast<ResultType>(enum_t_value));
}
bool ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultType* value);
enum KickReasonType : int {
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_MOBILE_KICK = 2
};
bool KickReasonType_IsValid(int value);
constexpr KickReasonType KickReasonType_MIN = KICK_REASON_DUPLICATE_USER;
constexpr KickReasonType KickReasonType_MAX = KICK_REASON_MOBILE_KICK;
constexpr int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

const std::string& KickReasonType_Name(KickReasonType value);
template<typename T>
inline const std::string& KickReasonType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KickReasonType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KickReasonType_Name.");
  return KickReasonType_Name(static_cast<KickReasonType>(enum_t_value));
}
bool KickReasonType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickReasonType* value);
enum OnlineListType : int {
  ONLINE_LIST_TYPE_FRIEND_LIST = 1
};
bool OnlineListType_IsValid(int value);
constexpr OnlineListType OnlineListType_MIN = ONLINE_LIST_TYPE_FRIEND_LIST;
constexpr OnlineListType OnlineListType_MAX = ONLINE_LIST_TYPE_FRIEND_LIST;
constexpr int OnlineListType_ARRAYSIZE = OnlineListType_MAX + 1;

const std::string& OnlineListType_Name(OnlineListType value);
template<typename T>
inline const std::string& OnlineListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OnlineListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OnlineListType_Name.");
  return OnlineListType_Name(static_cast<OnlineListType>(enum_t_value));
}
bool OnlineListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnlineListType* value);
enum UserStatType : int {
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3
};
bool UserStatType_IsValid(int value);
constexpr UserStatType UserStatType_MIN = USER_STATUS_ONLINE;
constexpr UserStatType UserStatType_MAX = USER_STATUS_LEAVE;
constexpr int UserStatType_ARRAYSIZE = UserStatType_MAX + 1;

const std::string& UserStatType_Name(UserStatType value);
template<typename T>
inline const std::string& UserStatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatType_Name.");
  return UserStatType_Name(static_cast<UserStatType>(enum_t_value));
}
bool UserStatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatType* value);
enum SessionType : int {
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_GROUP = 2
};
bool SessionType_IsValid(int value);
constexpr SessionType SessionType_MIN = SESSION_TYPE_SINGLE;
constexpr SessionType SessionType_MAX = SESSION_TYPE_GROUP;
constexpr int SessionType_ARRAYSIZE = SessionType_MAX + 1;

const std::string& SessionType_Name(SessionType value);
template<typename T>
inline const std::string& SessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionType_Name.");
  return SessionType_Name(static_cast<SessionType>(enum_t_value));
}
bool SessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value);
enum MsgType : int {
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_GROUP_TEXT = 17,
  MSG_TYPE_GROUP_AUDIO = 18
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MSG_TYPE_SINGLE_TEXT;
constexpr MsgType MsgType_MAX = MSG_TYPE_GROUP_AUDIO;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const std::string& MsgType_Name(MsgType value);
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return MsgType_Name(static_cast<MsgType>(enum_t_value));
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value);
enum ClientType : int {
  CLIENT_TYPE_WINDOWS = 1,
  CLIENT_TYPE_MAC = 2,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = CLIENT_TYPE_WINDOWS;
constexpr ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const std::string& ClientType_Name(ClientType value);
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ClientType_Name(static_cast<ClientType>(enum_t_value));
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value);
enum GroupType : int {
  GROUP_TYPE_NORMAL = 0,
  GROUP_TYPE_TMP = 1
};
bool GroupType_IsValid(int value);
constexpr GroupType GroupType_MIN = GROUP_TYPE_NORMAL;
constexpr GroupType GroupType_MAX = GROUP_TYPE_TMP;
constexpr int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const std::string& GroupType_Name(GroupType value);
template<typename T>
inline const std::string& GroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupType_Name.");
  return GroupType_Name(static_cast<GroupType>(enum_t_value));
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value);
enum GroupModifyType : int {
  GROUP_MODIFY_TYPE_ADD = 0,
  GROUP_MODIFY_TYPE_DEL = 1
};
bool GroupModifyType_IsValid(int value);
constexpr GroupModifyType GroupModifyType_MIN = GROUP_MODIFY_TYPE_ADD;
constexpr GroupModifyType GroupModifyType_MAX = GROUP_MODIFY_TYPE_DEL;
constexpr int GroupModifyType_ARRAYSIZE = GroupModifyType_MAX + 1;

const std::string& GroupModifyType_Name(GroupModifyType value);
template<typename T>
inline const std::string& GroupModifyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupModifyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupModifyType_Name.");
  return GroupModifyType_Name(static_cast<GroupModifyType>(enum_t_value));
}
bool GroupModifyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyType* value);
enum FileType : int {
  FILE_TYPE_ONLINE = 0,
  FILE_TYPE_OFFLINE = 2
};
bool FileType_IsValid(int value);
constexpr FileType FileType_MIN = FILE_TYPE_ONLINE;
constexpr FileType FileType_MAX = FILE_TYPE_OFFLINE;
constexpr int FileType_ARRAYSIZE = FileType_MAX + 1;

const std::string& FileType_Name(FileType value);
template<typename T>
inline const std::string& FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileType_Name.");
  return FileType_Name(static_cast<FileType>(enum_t_value));
}
bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value);
enum ClientFileState : int {
  CLIENT_FILE_PEER_READY = 0,
  CLIENT_FILE_CANCEL = 1,
  CLIENT_FILE_REFUSE = 2,
  CLIENT_FILE_DONE = 3
};
bool ClientFileState_IsValid(int value);
constexpr ClientFileState ClientFileState_MIN = CLIENT_FILE_PEER_READY;
constexpr ClientFileState ClientFileState_MAX = CLIENT_FILE_DONE;
constexpr int ClientFileState_ARRAYSIZE = ClientFileState_MAX + 1;

const std::string& ClientFileState_Name(ClientFileState value);
template<typename T>
inline const std::string& ClientFileState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientFileState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientFileState_Name.");
  return ClientFileState_Name(static_cast<ClientFileState>(enum_t_value));
}
bool ClientFileState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileState* value);
enum ClientFileRole : int {
  CLIENT_REALTIME_SENDER = 1,
  CLIENT_REALTIME_RECVER = 2,
  CLIENT_OFFLINE_UPLOAD = 3,
  CLIENT_OFFLINE_DOWNLOAD = 4
};
bool ClientFileRole_IsValid(int value);
constexpr ClientFileRole ClientFileRole_MIN = CLIENT_REALTIME_SENDER;
constexpr ClientFileRole ClientFileRole_MAX = CLIENT_OFFLINE_DOWNLOAD;
constexpr int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

const std::string& ClientFileRole_Name(ClientFileRole value);
template<typename T>
inline const std::string& ClientFileRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientFileRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientFileRole_Name.");
  return ClientFileRole_Name(static_cast<ClientFileRole>(enum_t_value));
}
bool ClientFileRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFileRole* value);
enum FileServerError : int {
  FILE_SERVER_ERRNO_OK = 0,
  FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
  FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
  FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
  FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
  FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
  FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
  FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
  FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
  FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
  FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
  FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
  FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12
};
bool FileServerError_IsValid(int value);
constexpr FileServerError FileServerError_MIN = FILE_SERVER_ERRNO_OK;
constexpr FileServerError FileServerError_MAX = FILE_SERVER_ERRNO_PULL_DATA_FINISHED;
constexpr int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

const std::string& FileServerError_Name(FileServerError value);
template<typename T>
inline const std::string& FileServerError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileServerError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileServerError_Name.");
  return FileServerError_Name(static_cast<FileServerError>(enum_t_value));
}
bool FileServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileServerError* value);
enum SessionStatusType : int {
  SESSION_STATUS_OK = 0,
  SESSION_STATUS_DELETE = 1
};
bool SessionStatusType_IsValid(int value);
constexpr SessionStatusType SessionStatusType_MIN = SESSION_STATUS_OK;
constexpr SessionStatusType SessionStatusType_MAX = SESSION_STATUS_DELETE;
constexpr int SessionStatusType_ARRAYSIZE = SessionStatusType_MAX + 1;

const std::string& SessionStatusType_Name(SessionStatusType value);
template<typename T>
inline const std::string& SessionStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionStatusType_Name.");
  return SessionStatusType_Name(static_cast<SessionStatusType>(enum_t_value));
}
bool SessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStatusType* value);
enum DepartmentStatusType : int {
  DEPT_STATUS_OK = 0,
  DEPT_STATUS_DELETE = 1
};
bool DepartmentStatusType_IsValid(int value);
constexpr DepartmentStatusType DepartmentStatusType_MIN = DEPT_STATUS_OK;
constexpr DepartmentStatusType DepartmentStatusType_MAX = DEPT_STATUS_DELETE;
constexpr int DepartmentStatusType_ARRAYSIZE = DepartmentStatusType_MAX + 1;

const std::string& DepartmentStatusType_Name(DepartmentStatusType value);
template<typename T>
inline const std::string& DepartmentStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DepartmentStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DepartmentStatusType_Name.");
  return DepartmentStatusType_Name(static_cast<DepartmentStatusType>(enum_t_value));
}
bool DepartmentStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepartmentStatusType* value);
// ===================================================================

class IpAddr final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.IpAddr) */ {
 public:
  inline IpAddr() : IpAddr(nullptr) {}
  ~IpAddr() override;
  explicit PROTOBUF_CONSTEXPR IpAddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpAddr(const IpAddr& from);
  IpAddr(IpAddr&& from) noexcept
    : IpAddr() {
    *this = ::std::move(from);
  }

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpAddr& operator=(IpAddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IpAddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpAddr* internal_default_instance() {
    return reinterpret_cast<const IpAddr*>(
               &_IpAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IpAddr& a, IpAddr& b) {
    a.Swap(&b);
  }
  inline void Swap(IpAddr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpAddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpAddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpAddr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpAddr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.IpAddr";
  }
  protected:
  explicit IpAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // required string ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // required uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.IpAddr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    uint32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickNameFieldNumber = 3,
    kAvatarUrlFieldNumber = 4,
    kEmailFieldNumber = 6,
    kUserRealNameFieldNumber = 7,
    kUserTelFieldNumber = 8,
    kUserDomainFieldNumber = 9,
    kUserIdFieldNumber = 1,
    kGenderFieldNumber = 2,
    kDepartmentIdFieldNumber = 5,
    kStatusFieldNumber = 10,
  };
  // required string nick_name = 3;
  bool has_nick_name() const;
  private:
  bool _internal_has_nick_name() const;
  public:
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // required string avatar_url = 4;
  bool has_avatar_url() const;
  private:
  bool _internal_has_avatar_url() const;
  public:
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // required string email = 6;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // required string user_real_name = 7;
  bool has_user_real_name() const;
  private:
  bool _internal_has_user_real_name() const;
  public:
  void clear_user_real_name();
  const std::string& user_real_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_real_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_real_name();
  PROTOBUF_NODISCARD std::string* release_user_real_name();
  void set_allocated_user_real_name(std::string* user_real_name);
  private:
  const std::string& _internal_user_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_real_name(const std::string& value);
  std::string* _internal_mutable_user_real_name();
  public:

  // required string user_tel = 8;
  bool has_user_tel() const;
  private:
  bool _internal_has_user_tel() const;
  public:
  void clear_user_tel();
  const std::string& user_tel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_tel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_tel();
  PROTOBUF_NODISCARD std::string* release_user_tel();
  void set_allocated_user_tel(std::string* user_tel);
  private:
  const std::string& _internal_user_tel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_tel(const std::string& value);
  std::string* _internal_mutable_user_tel();
  public:

  // required string user_domain = 9;
  bool has_user_domain() const;
  private:
  bool _internal_has_user_domain() const;
  public:
  void clear_user_domain();
  const std::string& user_domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_domain();
  PROTOBUF_NODISCARD std::string* release_user_domain();
  void set_allocated_user_domain(std::string* user_domain);
  private:
  const std::string& _internal_user_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_domain(const std::string& value);
  std::string* _internal_mutable_user_domain();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 gender = 2;
  bool has_gender() const;
  private:
  bool _internal_has_gender() const;
  public:
  void clear_gender();
  uint32_t gender() const;
  void set_gender(uint32_t value);
  private:
  uint32_t _internal_gender() const;
  void _internal_set_gender(uint32_t value);
  public:

  // required uint32 department_id = 5;
  bool has_department_id() const;
  private:
  bool _internal_has_department_id() const;
  public:
  void clear_department_id();
  uint32_t department_id() const;
  void set_department_id(uint32_t value);
  private:
  uint32_t _internal_department_id() const;
  void _internal_set_department_id(uint32_t value);
  public:

  // required uint32 status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.UserInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_real_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_tel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_domain_;
    uint32_t user_id_;
    uint32_t gender_;
    uint32_t department_id_;
    uint32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ContactSessionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.ContactSessionInfo) */ {
 public:
  inline ContactSessionInfo() : ContactSessionInfo(nullptr) {}
  ~ContactSessionInfo() override;
  explicit PROTOBUF_CONSTEXPR ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactSessionInfo(const ContactSessionInfo& from);
  ContactSessionInfo(ContactSessionInfo&& from) noexcept
    : ContactSessionInfo() {
    *this = ::std::move(from);
  }

  inline ContactSessionInfo& operator=(const ContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactSessionInfo& operator=(ContactSessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContactSessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactSessionInfo* internal_default_instance() {
    return reinterpret_cast<const ContactSessionInfo*>(
               &_ContactSessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContactSessionInfo& a, ContactSessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactSessionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactSessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactSessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactSessionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContactSessionInfo& from);
  void MergeFrom(const ContactSessionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContactSessionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.ContactSessionInfo";
  }
  protected:
  explicit ContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestMsgDataFieldNumber = 6,
    kSessionIdFieldNumber = 1,
    kSessionStatusFieldNumber = 3,
    kUpdatedTimeFieldNumber = 4,
    kLatestMsgIdFieldNumber = 5,
    kLatestMsgFromUserIdFieldNumber = 8,
    kSessionTypeFieldNumber = 2,
    kLatestMsgTypeFieldNumber = 7,
  };
  // required bytes latest_msg_data = 6;
  bool has_latest_msg_data() const;
  private:
  bool _internal_has_latest_msg_data() const;
  public:
  void clear_latest_msg_data();
  const std::string& latest_msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latest_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latest_msg_data();
  PROTOBUF_NODISCARD std::string* release_latest_msg_data();
  void set_allocated_latest_msg_data(std::string* latest_msg_data);
  private:
  const std::string& _internal_latest_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_msg_data(const std::string& value);
  std::string* _internal_mutable_latest_msg_data();
  public:

  // required uint32 session_id = 1;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionStatusType session_status = 3;
  bool has_session_status() const;
  private:
  bool _internal_has_session_status() const;
  public:
  void clear_session_status();
  ::Bohan::BaseDefine::SessionStatusType session_status() const;
  void set_session_status(::Bohan::BaseDefine::SessionStatusType value);
  private:
  ::Bohan::BaseDefine::SessionStatusType _internal_session_status() const;
  void _internal_set_session_status(::Bohan::BaseDefine::SessionStatusType value);
  public:

  // required uint32 updated_time = 4;
  bool has_updated_time() const;
  private:
  bool _internal_has_updated_time() const;
  public:
  void clear_updated_time();
  uint32_t updated_time() const;
  void set_updated_time(uint32_t value);
  private:
  uint32_t _internal_updated_time() const;
  void _internal_set_updated_time(uint32_t value);
  public:

  // required uint32 latest_msg_id = 5;
  bool has_latest_msg_id() const;
  private:
  bool _internal_has_latest_msg_id() const;
  public:
  void clear_latest_msg_id();
  uint32_t latest_msg_id() const;
  void set_latest_msg_id(uint32_t value);
  private:
  uint32_t _internal_latest_msg_id() const;
  void _internal_set_latest_msg_id(uint32_t value);
  public:

  // required uint32 latest_msg_from_user_id = 8;
  bool has_latest_msg_from_user_id() const;
  private:
  bool _internal_has_latest_msg_from_user_id() const;
  public:
  void clear_latest_msg_from_user_id();
  uint32_t latest_msg_from_user_id() const;
  void set_latest_msg_from_user_id(uint32_t value);
  private:
  uint32_t _internal_latest_msg_from_user_id() const;
  void _internal_set_latest_msg_from_user_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
  bool has_latest_msg_type() const;
  private:
  bool _internal_has_latest_msg_type() const;
  public:
  void clear_latest_msg_type();
  ::Bohan::BaseDefine::MsgType latest_msg_type() const;
  void set_latest_msg_type(::Bohan::BaseDefine::MsgType value);
  private:
  ::Bohan::BaseDefine::MsgType _internal_latest_msg_type() const;
  void _internal_set_latest_msg_type(::Bohan::BaseDefine::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.ContactSessionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_msg_data_;
    uint32_t session_id_;
    int session_status_;
    uint32_t updated_time_;
    uint32_t latest_msg_id_;
    uint32_t latest_msg_from_user_id_;
    int session_type_;
    int latest_msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.UserStat) */ {
 public:
  inline UserStat() : UserStat(nullptr) {}
  ~UserStat() override;
  explicit PROTOBUF_CONSTEXPR UserStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStat(const UserStat& from);
  UserStat(UserStat&& from) noexcept
    : UserStat() {
    *this = ::std::move(from);
  }

  inline UserStat& operator=(const UserStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStat& operator=(UserStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStat* internal_default_instance() {
    return reinterpret_cast<const UserStat*>(
               &_UserStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserStat& a, UserStat& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserStat& from);
  void MergeFrom(const UserStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.UserStat";
  }
  protected:
  explicit UserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.UserStatType status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Bohan::BaseDefine::UserStatType status() const;
  void set_status(::Bohan::BaseDefine::UserStatType value);
  private:
  ::Bohan::BaseDefine::UserStatType _internal_status() const;
  void _internal_set_status(::Bohan::BaseDefine::UserStatType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.UserStat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ServerUserStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.ServerUserStat) */ {
 public:
  inline ServerUserStat() : ServerUserStat(nullptr) {}
  ~ServerUserStat() override;
  explicit PROTOBUF_CONSTEXPR ServerUserStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerUserStat(const ServerUserStat& from);
  ServerUserStat(ServerUserStat&& from) noexcept
    : ServerUserStat() {
    *this = ::std::move(from);
  }

  inline ServerUserStat& operator=(const ServerUserStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerUserStat& operator=(ServerUserStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ServerUserStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerUserStat* internal_default_instance() {
    return reinterpret_cast<const ServerUserStat*>(
               &_ServerUserStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerUserStat& a, ServerUserStat& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerUserStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerUserStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerUserStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerUserStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServerUserStat& from);
  void MergeFrom(const ServerUserStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerUserStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.ServerUserStat";
  }
  protected:
  explicit ServerUserStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kClientTypeFieldNumber = 3,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.UserStatType status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::Bohan::BaseDefine::UserStatType status() const;
  void set_status(::Bohan::BaseDefine::UserStatType value);
  private:
  ::Bohan::BaseDefine::UserStatType _internal_status() const;
  void _internal_set_status(::Bohan::BaseDefine::UserStatType value);
  public:

  // required .Bohan.BaseDefine.ClientType client_type = 3;
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  ::Bohan::BaseDefine::ClientType client_type() const;
  void set_client_type(::Bohan::BaseDefine::ClientType value);
  private:
  ::Bohan::BaseDefine::ClientType _internal_client_type() const;
  void _internal_set_client_type(::Bohan::BaseDefine::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.ServerUserStat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    int status_;
    int client_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UnreadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.UnreadInfo) */ {
 public:
  inline UnreadInfo() : UnreadInfo(nullptr) {}
  ~UnreadInfo() override;
  explicit PROTOBUF_CONSTEXPR UnreadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnreadInfo(const UnreadInfo& from);
  UnreadInfo(UnreadInfo&& from) noexcept
    : UnreadInfo() {
    *this = ::std::move(from);
  }

  inline UnreadInfo& operator=(const UnreadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnreadInfo& operator=(UnreadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnreadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnreadInfo* internal_default_instance() {
    return reinterpret_cast<const UnreadInfo*>(
               &_UnreadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UnreadInfo& a, UnreadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UnreadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnreadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnreadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnreadInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnreadInfo& from);
  void MergeFrom(const UnreadInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnreadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.UnreadInfo";
  }
  protected:
  explicit UnreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestMsgDataFieldNumber = 5,
    kSessionIdFieldNumber = 1,
    kUnreadCntFieldNumber = 3,
    kLatestMsgIdFieldNumber = 4,
    kLatestMsgFromUserIdFieldNumber = 7,
    kSessionTypeFieldNumber = 2,
    kLatestMsgTypeFieldNumber = 6,
  };
  // required bytes latest_msg_data = 5;
  bool has_latest_msg_data() const;
  private:
  bool _internal_has_latest_msg_data() const;
  public:
  void clear_latest_msg_data();
  const std::string& latest_msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latest_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latest_msg_data();
  PROTOBUF_NODISCARD std::string* release_latest_msg_data();
  void set_allocated_latest_msg_data(std::string* latest_msg_data);
  private:
  const std::string& _internal_latest_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_msg_data(const std::string& value);
  std::string* _internal_mutable_latest_msg_data();
  public:

  // required uint32 session_id = 1;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 unread_cnt = 3;
  bool has_unread_cnt() const;
  private:
  bool _internal_has_unread_cnt() const;
  public:
  void clear_unread_cnt();
  uint32_t unread_cnt() const;
  void set_unread_cnt(uint32_t value);
  private:
  uint32_t _internal_unread_cnt() const;
  void _internal_set_unread_cnt(uint32_t value);
  public:

  // required uint32 latest_msg_id = 4;
  bool has_latest_msg_id() const;
  private:
  bool _internal_has_latest_msg_id() const;
  public:
  void clear_latest_msg_id();
  uint32_t latest_msg_id() const;
  void set_latest_msg_id(uint32_t value);
  private:
  uint32_t _internal_latest_msg_id() const;
  void _internal_set_latest_msg_id(uint32_t value);
  public:

  // required uint32 latest_msg_from_user_id = 7;
  bool has_latest_msg_from_user_id() const;
  private:
  bool _internal_has_latest_msg_from_user_id() const;
  public:
  void clear_latest_msg_from_user_id();
  uint32_t latest_msg_from_user_id() const;
  void set_latest_msg_from_user_id(uint32_t value);
  private:
  uint32_t _internal_latest_msg_from_user_id() const;
  void _internal_set_latest_msg_from_user_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
  bool has_latest_msg_type() const;
  private:
  bool _internal_has_latest_msg_type() const;
  public:
  void clear_latest_msg_type();
  ::Bohan::BaseDefine::MsgType latest_msg_type() const;
  void set_latest_msg_type(::Bohan::BaseDefine::MsgType value);
  private:
  ::Bohan::BaseDefine::MsgType _internal_latest_msg_type() const;
  void _internal_set_latest_msg_type(::Bohan::BaseDefine::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.UnreadInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_msg_data_;
    uint32_t session_id_;
    uint32_t unread_cnt_;
    uint32_t latest_msg_id_;
    uint32_t latest_msg_from_user_id_;
    int session_type_;
    int latest_msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class MsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.MsgInfo) */ {
 public:
  inline MsgInfo() : MsgInfo(nullptr) {}
  ~MsgInfo() override;
  explicit PROTOBUF_CONSTEXPR MsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInfo(const MsgInfo& from);
  MsgInfo(MsgInfo&& from) noexcept
    : MsgInfo() {
    *this = ::std::move(from);
  }

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInfo& operator=(MsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInfo* internal_default_instance() {
    return reinterpret_cast<const MsgInfo*>(
               &_MsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgInfo& a, MsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.MsgInfo";
  }
  protected:
  explicit MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 5,
    kMsgIdFieldNumber = 1,
    kFromSessionIdFieldNumber = 2,
    kCreateTimeFieldNumber = 3,
    kMsgTypeFieldNumber = 4,
  };
  // required bytes msg_data = 5;
  bool has_msg_data() const;
  private:
  bool _internal_has_msg_data() const;
  public:
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // required uint32 msg_id = 1;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required uint32 from_session_id = 2;
  bool has_from_session_id() const;
  private:
  bool _internal_has_from_session_id() const;
  public:
  void clear_from_session_id();
  uint32_t from_session_id() const;
  void set_from_session_id(uint32_t value);
  private:
  uint32_t _internal_from_session_id() const;
  void _internal_set_from_session_id(uint32_t value);
  public:

  // required uint32 create_time = 3;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  uint32_t create_time() const;
  void set_create_time(uint32_t value);
  private:
  uint32_t _internal_create_time() const;
  void _internal_set_create_time(uint32_t value);
  public:

  // required .Bohan.BaseDefine.MsgType msg_type = 4;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::Bohan::BaseDefine::MsgType msg_type() const;
  void set_msg_type(::Bohan::BaseDefine::MsgType value);
  private:
  ::Bohan::BaseDefine::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::Bohan::BaseDefine::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.MsgInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
    uint32_t msg_id_;
    uint32_t from_session_id_;
    uint32_t create_time_;
    int msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class GroupVersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.GroupVersionInfo) */ {
 public:
  inline GroupVersionInfo() : GroupVersionInfo(nullptr) {}
  ~GroupVersionInfo() override;
  explicit PROTOBUF_CONSTEXPR GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupVersionInfo(const GroupVersionInfo& from);
  GroupVersionInfo(GroupVersionInfo&& from) noexcept
    : GroupVersionInfo() {
    *this = ::std::move(from);
  }

  inline GroupVersionInfo& operator=(const GroupVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupVersionInfo& operator=(GroupVersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GroupVersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupVersionInfo* internal_default_instance() {
    return reinterpret_cast<const GroupVersionInfo*>(
               &_GroupVersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GroupVersionInfo& a, GroupVersionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupVersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupVersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupVersionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GroupVersionInfo& from);
  void MergeFrom(const GroupVersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupVersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.GroupVersionInfo";
  }
  protected:
  explicit GroupVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.GroupVersionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t group_id_;
    uint32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class GroupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.GroupInfo) */ {
 public:
  inline GroupInfo() : GroupInfo(nullptr) {}
  ~GroupInfo() override;
  explicit PROTOBUF_CONSTEXPR GroupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupInfo(const GroupInfo& from);
  GroupInfo(GroupInfo&& from) noexcept
    : GroupInfo() {
    *this = ::std::move(from);
  }

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupInfo& operator=(GroupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GroupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupInfo* internal_default_instance() {
    return reinterpret_cast<const GroupInfo*>(
               &_GroupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GroupInfo& a, GroupInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.GroupInfo";
  }
  protected:
  explicit GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupMemberListFieldNumber = 8,
    kGroupNameFieldNumber = 3,
    kGroupAvatarFieldNumber = 4,
    kGroupIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kGroupCreatorIdFieldNumber = 5,
    kGroupTypeFieldNumber = 6,
    kShieldStatusFieldNumber = 7,
  };
  // repeated uint32 group_member_list = 8;
  int group_member_list_size() const;
  private:
  int _internal_group_member_list_size() const;
  public:
  void clear_group_member_list();
  private:
  uint32_t _internal_group_member_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_group_member_list() const;
  void _internal_add_group_member_list(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_group_member_list();
  public:
  uint32_t group_member_list(int index) const;
  void set_group_member_list(int index, uint32_t value);
  void add_group_member_list(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      group_member_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_group_member_list();

  // required string group_name = 3;
  bool has_group_name() const;
  private:
  bool _internal_has_group_name() const;
  public:
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // required string group_avatar = 4;
  bool has_group_avatar() const;
  private:
  bool _internal_has_group_avatar() const;
  public:
  void clear_group_avatar();
  const std::string& group_avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_avatar();
  PROTOBUF_NODISCARD std::string* release_group_avatar();
  void set_allocated_group_avatar(std::string* group_avatar);
  private:
  const std::string& _internal_group_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_avatar(const std::string& value);
  std::string* _internal_mutable_group_avatar();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // required uint32 group_creator_id = 5;
  bool has_group_creator_id() const;
  private:
  bool _internal_has_group_creator_id() const;
  public:
  void clear_group_creator_id();
  uint32_t group_creator_id() const;
  void set_group_creator_id(uint32_t value);
  private:
  uint32_t _internal_group_creator_id() const;
  void _internal_set_group_creator_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.GroupType group_type = 6;
  bool has_group_type() const;
  private:
  bool _internal_has_group_type() const;
  public:
  void clear_group_type();
  ::Bohan::BaseDefine::GroupType group_type() const;
  void set_group_type(::Bohan::BaseDefine::GroupType value);
  private:
  ::Bohan::BaseDefine::GroupType _internal_group_type() const;
  void _internal_set_group_type(::Bohan::BaseDefine::GroupType value);
  public:

  // required uint32 shield_status = 7;
  bool has_shield_status() const;
  private:
  bool _internal_has_shield_status() const;
  public:
  void clear_shield_status();
  uint32_t shield_status() const;
  void set_shield_status(uint32_t value);
  private:
  uint32_t _internal_shield_status() const;
  void _internal_set_shield_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.GroupInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > group_member_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_avatar_;
    uint32_t group_id_;
    uint32_t version_;
    uint32_t group_creator_id_;
    int group_type_;
    uint32_t shield_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class UserTokenInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.UserTokenInfo) */ {
 public:
  inline UserTokenInfo() : UserTokenInfo(nullptr) {}
  ~UserTokenInfo() override;
  explicit PROTOBUF_CONSTEXPR UserTokenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserTokenInfo(const UserTokenInfo& from);
  UserTokenInfo(UserTokenInfo&& from) noexcept
    : UserTokenInfo() {
    *this = ::std::move(from);
  }

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTokenInfo& operator=(UserTokenInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserTokenInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserTokenInfo* internal_default_instance() {
    return reinterpret_cast<const UserTokenInfo*>(
               &_UserTokenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserTokenInfo& a, UserTokenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserTokenInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserTokenInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserTokenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserTokenInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserTokenInfo& from);
  void MergeFrom(const UserTokenInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserTokenInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.UserTokenInfo";
  }
  protected:
  explicit UserTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kPushCountFieldNumber = 4,
    kPushTypeFieldNumber = 5,
    kUserTypeFieldNumber = 2,
  };
  // required string token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 push_count = 4;
  bool has_push_count() const;
  private:
  bool _internal_has_push_count() const;
  public:
  void clear_push_count();
  uint32_t push_count() const;
  void set_push_count(uint32_t value);
  private:
  uint32_t _internal_push_count() const;
  void _internal_set_push_count(uint32_t value);
  public:

  // required uint32 push_type = 5;
  bool has_push_type() const;
  private:
  bool _internal_has_push_type() const;
  public:
  void clear_push_type();
  uint32_t push_type() const;
  void set_push_type(uint32_t value);
  private:
  uint32_t _internal_push_type() const;
  void _internal_set_push_type(uint32_t value);
  public:

  // required .Bohan.BaseDefine.ClientType user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  ::Bohan::BaseDefine::ClientType user_type() const;
  void set_user_type(::Bohan::BaseDefine::ClientType value);
  private:
  ::Bohan::BaseDefine::ClientType _internal_user_type() const;
  void _internal_set_user_type(::Bohan::BaseDefine::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.UserTokenInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    uint32_t user_id_;
    uint32_t push_count_;
    uint32_t push_type_;
    int user_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class PushResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.PushResult) */ {
 public:
  inline PushResult() : PushResult(nullptr) {}
  ~PushResult() override;
  explicit PROTOBUF_CONSTEXPR PushResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushResult(const PushResult& from);
  PushResult(PushResult&& from) noexcept
    : PushResult() {
    *this = ::std::move(from);
  }

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushResult& operator=(PushResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PushResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushResult* internal_default_instance() {
    return reinterpret_cast<const PushResult*>(
               &_PushResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PushResult& a, PushResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PushResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PushResult& from);
  void MergeFrom(const PushResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.PushResult";
  }
  protected:
  explicit PushResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserTokenFieldNumber = 1,
    kResultCodeFieldNumber = 2,
  };
  // required string user_token = 1;
  bool has_user_token() const;
  private:
  bool _internal_has_user_token() const;
  public:
  void clear_user_token();
  const std::string& user_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_token();
  PROTOBUF_NODISCARD std::string* release_user_token();
  void set_allocated_user_token(std::string* user_token);
  private:
  const std::string& _internal_user_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_token(const std::string& value);
  std::string* _internal_mutable_user_token();
  public:

  // required uint32 result_code = 2;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.PushResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_token_;
    uint32_t result_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class ShieldStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.ShieldStatus) */ {
 public:
  inline ShieldStatus() : ShieldStatus(nullptr) {}
  ~ShieldStatus() override;
  explicit PROTOBUF_CONSTEXPR ShieldStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldStatus(const ShieldStatus& from);
  ShieldStatus(ShieldStatus&& from) noexcept
    : ShieldStatus() {
    *this = ::std::move(from);
  }

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldStatus& operator=(ShieldStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShieldStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldStatus* internal_default_instance() {
    return reinterpret_cast<const ShieldStatus*>(
               &_ShieldStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShieldStatus& a, ShieldStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShieldStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShieldStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShieldStatus& from);
  void MergeFrom(const ShieldStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShieldStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.ShieldStatus";
  }
  protected:
  explicit ShieldStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
    kShieldStatusFieldNumber = 3,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 group_id = 2;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 shield_status = 3;
  bool has_shield_status() const;
  private:
  bool _internal_has_shield_status() const;
  public:
  void clear_shield_status();
  uint32_t shield_status() const;
  void set_shield_status(uint32_t value);
  private:
  uint32_t _internal_shield_status() const;
  void _internal_set_shield_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.ShieldStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    uint32_t group_id_;
    uint32_t shield_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class OfflineFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.OfflineFileInfo) */ {
 public:
  inline OfflineFileInfo() : OfflineFileInfo(nullptr) {}
  ~OfflineFileInfo() override;
  explicit PROTOBUF_CONSTEXPR OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineFileInfo(const OfflineFileInfo& from);
  OfflineFileInfo(OfflineFileInfo&& from) noexcept
    : OfflineFileInfo() {
    *this = ::std::move(from);
  }

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineFileInfo& operator=(OfflineFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OfflineFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineFileInfo* internal_default_instance() {
    return reinterpret_cast<const OfflineFileInfo*>(
               &_OfflineFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OfflineFileInfo& a, OfflineFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineFileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfflineFileInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OfflineFileInfo& from);
  void MergeFrom(const OfflineFileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OfflineFileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.OfflineFileInfo";
  }
  protected:
  explicit OfflineFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kFromUserIdFieldNumber = 1,
    kFileSizeFieldNumber = 4,
  };
  // required string task_id = 2;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // required string file_name = 3;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  private:
  bool _internal_has_from_user_id() const;
  public:
  void clear_from_user_id();
  uint32_t from_user_id() const;
  void set_from_user_id(uint32_t value);
  private:
  uint32_t _internal_from_user_id() const;
  void _internal_set_from_user_id(uint32_t value);
  public:

  // required uint32 file_size = 4;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  uint32_t file_size() const;
  void set_file_size(uint32_t value);
  private:
  uint32_t _internal_file_size() const;
  void _internal_set_file_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.OfflineFileInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    uint32_t from_user_id_;
    uint32_t file_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// -------------------------------------------------------------------

class DepartInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.BaseDefine.DepartInfo) */ {
 public:
  inline DepartInfo() : DepartInfo(nullptr) {}
  ~DepartInfo() override;
  explicit PROTOBUF_CONSTEXPR DepartInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DepartInfo(const DepartInfo& from);
  DepartInfo(DepartInfo&& from) noexcept
    : DepartInfo() {
    *this = ::std::move(from);
  }

  inline DepartInfo& operator=(const DepartInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepartInfo& operator=(DepartInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DepartInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DepartInfo* internal_default_instance() {
    return reinterpret_cast<const DepartInfo*>(
               &_DepartInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DepartInfo& a, DepartInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DepartInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepartInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DepartInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DepartInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DepartInfo& from);
  void MergeFrom(const DepartInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DepartInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.BaseDefine.DepartInfo";
  }
  protected:
  explicit DepartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeptNameFieldNumber = 3,
    kDeptIdFieldNumber = 1,
    kPriorityFieldNumber = 2,
    kParentDeptIdFieldNumber = 4,
    kDeptStatusFieldNumber = 5,
  };
  // required string dept_name = 3;
  bool has_dept_name() const;
  private:
  bool _internal_has_dept_name() const;
  public:
  void clear_dept_name();
  const std::string& dept_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dept_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dept_name();
  PROTOBUF_NODISCARD std::string* release_dept_name();
  void set_allocated_dept_name(std::string* dept_name);
  private:
  const std::string& _internal_dept_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dept_name(const std::string& value);
  std::string* _internal_mutable_dept_name();
  public:

  // required uint32 dept_id = 1;
  bool has_dept_id() const;
  private:
  bool _internal_has_dept_id() const;
  public:
  void clear_dept_id();
  uint32_t dept_id() const;
  void set_dept_id(uint32_t value);
  private:
  uint32_t _internal_dept_id() const;
  void _internal_set_dept_id(uint32_t value);
  public:

  // required uint32 priority = 2;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // required uint32 parent_dept_id = 4;
  bool has_parent_dept_id() const;
  private:
  bool _internal_has_parent_dept_id() const;
  public:
  void clear_parent_dept_id();
  uint32_t parent_dept_id() const;
  void set_parent_dept_id(uint32_t value);
  private:
  uint32_t _internal_parent_dept_id() const;
  void _internal_set_parent_dept_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
  bool has_dept_status() const;
  private:
  bool _internal_has_dept_status() const;
  public:
  void clear_dept_status();
  ::Bohan::BaseDefine::DepartmentStatusType dept_status() const;
  void set_dept_status(::Bohan::BaseDefine::DepartmentStatusType value);
  private:
  ::Bohan::BaseDefine::DepartmentStatusType _internal_dept_status() const;
  void _internal_set_dept_status(::Bohan::BaseDefine::DepartmentStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.BaseDefine.DepartInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dept_name_;
    uint32_t dept_id_;
    uint32_t priority_;
    uint32_t parent_dept_id_;
    int dept_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BaseDefine_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IpAddr

// required string ip = 1;
inline bool IpAddr::_internal_has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IpAddr::has_ip() const {
  return _internal_has_ip();
}
inline void IpAddr::clear_ip() {
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IpAddr::ip() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.IpAddr.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IpAddr::set_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.IpAddr.ip)
}
inline std::string* IpAddr::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.IpAddr.ip)
  return _s;
}
inline const std::string& IpAddr::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void IpAddr::_internal_set_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* IpAddr::_internal_mutable_ip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* IpAddr::release_ip() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.IpAddr.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IpAddr::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.IpAddr.ip)
}

// required uint32 port = 2;
inline bool IpAddr::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IpAddr::has_port() const {
  return _internal_has_port();
}
inline void IpAddr::clear_port() {
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t IpAddr::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t IpAddr::port() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.IpAddr.port)
  return _internal_port();
}
inline void IpAddr::_internal_set_port(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.port_ = value;
}
inline void IpAddr::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// required uint32 user_id = 1;
inline bool UserInfo::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfo::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserInfo::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t UserInfo::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.user_id)
  return _internal_user_id();
}
inline void UserInfo::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.user_id_ = value;
}
inline void UserInfo::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.user_id)
}

// required uint32 gender = 2;
inline bool UserInfo::_internal_has_gender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfo::has_gender() const {
  return _internal_has_gender();
}
inline void UserInfo::clear_gender() {
  _impl_.gender_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t UserInfo::_internal_gender() const {
  return _impl_.gender_;
}
inline uint32_t UserInfo::gender() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.gender)
  return _internal_gender();
}
inline void UserInfo::_internal_set_gender(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.gender_ = value;
}
inline void UserInfo::set_gender(uint32_t value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.gender)
}

// required string nick_name = 3;
inline bool UserInfo::_internal_has_nick_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_nick_name() const {
  return _internal_has_nick_name();
}
inline void UserInfo::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::nick_name() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_nick_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.nick_name)
}
inline std::string* UserInfo::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.nick_name)
  return _s;
}
inline const std::string& UserInfo::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void UserInfo::_internal_set_nick_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_nick_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_nick_name() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.nick_name)
  if (!_internal_has_nick_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.nick_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.nick_name)
}

// required string avatar_url = 4;
inline bool UserInfo::_internal_has_avatar_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_avatar_url() const {
  return _internal_has_avatar_url();
}
inline void UserInfo::clear_avatar_url() {
  _impl_.avatar_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.avatar_url)
}
inline std::string* UserInfo::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.avatar_url)
  return _s;
}
inline const std::string& UserInfo::_internal_avatar_url() const {
  return _impl_.avatar_url_.Get();
}
inline void UserInfo::_internal_set_avatar_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_avatar_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_avatar_url() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.avatar_url)
  if (!_internal_has_avatar_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.avatar_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_url_.IsDefault()) {
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.avatar_url)
}

// required uint32 department_id = 5;
inline bool UserInfo::_internal_has_department_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfo::has_department_id() const {
  return _internal_has_department_id();
}
inline void UserInfo::clear_department_id() {
  _impl_.department_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t UserInfo::_internal_department_id() const {
  return _impl_.department_id_;
}
inline uint32_t UserInfo::department_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.department_id)
  return _internal_department_id();
}
inline void UserInfo::_internal_set_department_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.department_id_ = value;
}
inline void UserInfo::set_department_id(uint32_t value) {
  _internal_set_department_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.department_id)
}

// required string email = 6;
inline bool UserInfo::_internal_has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_email() const {
  return _internal_has_email();
}
inline void UserInfo::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::email() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.email)
}
inline std::string* UserInfo::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.email)
  return _s;
}
inline const std::string& UserInfo::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserInfo::_internal_set_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_email() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_email() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.email)
}

// required string user_real_name = 7;
inline bool UserInfo::_internal_has_user_real_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfo::has_user_real_name() const {
  return _internal_has_user_real_name();
}
inline void UserInfo::clear_user_real_name() {
  _impl_.user_real_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserInfo::user_real_name() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.user_real_name)
  return _internal_user_real_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_real_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.user_real_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.user_real_name)
}
inline std::string* UserInfo::mutable_user_real_name() {
  std::string* _s = _internal_mutable_user_real_name();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.user_real_name)
  return _s;
}
inline const std::string& UserInfo::_internal_user_real_name() const {
  return _impl_.user_real_name_.Get();
}
inline void UserInfo::_internal_set_user_real_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_real_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_real_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.user_real_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_real_name() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.user_real_name)
  if (!_internal_has_user_real_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.user_real_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_real_name_.IsDefault()) {
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_user_real_name(std::string* user_real_name) {
  if (user_real_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.user_real_name_.SetAllocated(user_real_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_real_name_.IsDefault()) {
    _impl_.user_real_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.user_real_name)
}

// required string user_tel = 8;
inline bool UserInfo::_internal_has_user_tel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfo::has_user_tel() const {
  return _internal_has_user_tel();
}
inline void UserInfo::clear_user_tel() {
  _impl_.user_tel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserInfo::user_tel() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.user_tel)
  return _internal_user_tel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_tel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.user_tel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.user_tel)
}
inline std::string* UserInfo::mutable_user_tel() {
  std::string* _s = _internal_mutable_user_tel();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.user_tel)
  return _s;
}
inline const std::string& UserInfo::_internal_user_tel() const {
  return _impl_.user_tel_.Get();
}
inline void UserInfo::_internal_set_user_tel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_tel_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_tel() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.user_tel_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_tel() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.user_tel)
  if (!_internal_has_user_tel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.user_tel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_tel_.IsDefault()) {
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_user_tel(std::string* user_tel) {
  if (user_tel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.user_tel_.SetAllocated(user_tel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_tel_.IsDefault()) {
    _impl_.user_tel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.user_tel)
}

// required string user_domain = 9;
inline bool UserInfo::_internal_has_user_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfo::has_user_domain() const {
  return _internal_has_user_domain();
}
inline void UserInfo::clear_user_domain() {
  _impl_.user_domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserInfo::user_domain() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.user_domain)
  return _internal_user_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_domain(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.user_domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.user_domain)
}
inline std::string* UserInfo::mutable_user_domain() {
  std::string* _s = _internal_mutable_user_domain();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserInfo.user_domain)
  return _s;
}
inline const std::string& UserInfo::_internal_user_domain() const {
  return _impl_.user_domain_.Get();
}
inline void UserInfo::_internal_set_user_domain(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_domain() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.user_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_domain() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserInfo.user_domain)
  if (!_internal_has_user_domain()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.user_domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_domain_.IsDefault()) {
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_user_domain(std::string* user_domain) {
  if (user_domain != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.user_domain_.SetAllocated(user_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_domain_.IsDefault()) {
    _impl_.user_domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserInfo.user_domain)
}

// required uint32 status = 10;
inline bool UserInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserInfo::has_status() const {
  return _internal_has_status();
}
inline void UserInfo::clear_status() {
  _impl_.status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t UserInfo::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t UserInfo::status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserInfo.status)
  return _internal_status();
}
inline void UserInfo::_internal_set_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.status_ = value;
}
inline void UserInfo::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserInfo.status)
}

// -------------------------------------------------------------------

// ContactSessionInfo

// required uint32 session_id = 1;
inline bool ContactSessionInfo::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_session_id() const {
  return _internal_has_session_id();
}
inline void ContactSessionInfo::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ContactSessionInfo::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t ContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.session_id)
  return _internal_session_id();
}
inline void ContactSessionInfo::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void ContactSessionInfo::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.session_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool ContactSessionInfo::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_session_type() const {
  return _internal_has_session_type();
}
inline void ContactSessionInfo::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::Bohan::BaseDefine::SessionType ContactSessionInfo::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType ContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.session_type)
  return _internal_session_type();
}
inline void ContactSessionInfo::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.session_type_ = value;
}
inline void ContactSessionInfo::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.session_type)
}

// required .Bohan.BaseDefine.SessionStatusType session_status = 3;
inline bool ContactSessionInfo::_internal_has_session_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_session_status() const {
  return _internal_has_session_status();
}
inline void ContactSessionInfo::clear_session_status() {
  _impl_.session_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Bohan::BaseDefine::SessionStatusType ContactSessionInfo::_internal_session_status() const {
  return static_cast< ::Bohan::BaseDefine::SessionStatusType >(_impl_.session_status_);
}
inline ::Bohan::BaseDefine::SessionStatusType ContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.session_status)
  return _internal_session_status();
}
inline void ContactSessionInfo::_internal_set_session_status(::Bohan::BaseDefine::SessionStatusType value) {
  assert(::Bohan::BaseDefine::SessionStatusType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_status_ = value;
}
inline void ContactSessionInfo::set_session_status(::Bohan::BaseDefine::SessionStatusType value) {
  _internal_set_session_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.session_status)
}

// required uint32 updated_time = 4;
inline bool ContactSessionInfo::_internal_has_updated_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_updated_time() const {
  return _internal_has_updated_time();
}
inline void ContactSessionInfo::clear_updated_time() {
  _impl_.updated_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ContactSessionInfo::_internal_updated_time() const {
  return _impl_.updated_time_;
}
inline uint32_t ContactSessionInfo::updated_time() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.updated_time)
  return _internal_updated_time();
}
inline void ContactSessionInfo::_internal_set_updated_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.updated_time_ = value;
}
inline void ContactSessionInfo::set_updated_time(uint32_t value) {
  _internal_set_updated_time(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.updated_time)
}

// required uint32 latest_msg_id = 5;
inline bool ContactSessionInfo::_internal_has_latest_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_latest_msg_id() const {
  return _internal_has_latest_msg_id();
}
inline void ContactSessionInfo::clear_latest_msg_id() {
  _impl_.latest_msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ContactSessionInfo::_internal_latest_msg_id() const {
  return _impl_.latest_msg_id_;
}
inline uint32_t ContactSessionInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.latest_msg_id)
  return _internal_latest_msg_id();
}
inline void ContactSessionInfo::_internal_set_latest_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.latest_msg_id_ = value;
}
inline void ContactSessionInfo::set_latest_msg_id(uint32_t value) {
  _internal_set_latest_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.latest_msg_id)
}

// required bytes latest_msg_data = 6;
inline bool ContactSessionInfo::_internal_has_latest_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_latest_msg_data() const {
  return _internal_has_latest_msg_data();
}
inline void ContactSessionInfo::clear_latest_msg_data() {
  _impl_.latest_msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContactSessionInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.latest_msg_data)
  return _internal_latest_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactSessionInfo::set_latest_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.latest_msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline std::string* ContactSessionInfo::mutable_latest_msg_data() {
  std::string* _s = _internal_mutable_latest_msg_data();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.ContactSessionInfo.latest_msg_data)
  return _s;
}
inline const std::string& ContactSessionInfo::_internal_latest_msg_data() const {
  return _impl_.latest_msg_data_.Get();
}
inline void ContactSessionInfo::_internal_set_latest_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latest_msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactSessionInfo::_internal_mutable_latest_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.latest_msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactSessionInfo::release_latest_msg_data() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.ContactSessionInfo.latest_msg_data)
  if (!_internal_has_latest_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.latest_msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.latest_msg_data_.IsDefault()) {
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactSessionInfo::set_allocated_latest_msg_data(std::string* latest_msg_data) {
  if (latest_msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.latest_msg_data_.SetAllocated(latest_msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.latest_msg_data_.IsDefault()) {
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.ContactSessionInfo.latest_msg_data)
}

// required .Bohan.BaseDefine.MsgType latest_msg_type = 7;
inline bool ContactSessionInfo::_internal_has_latest_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_latest_msg_type() const {
  return _internal_has_latest_msg_type();
}
inline void ContactSessionInfo::clear_latest_msg_type() {
  _impl_.latest_msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::Bohan::BaseDefine::MsgType ContactSessionInfo::_internal_latest_msg_type() const {
  return static_cast< ::Bohan::BaseDefine::MsgType >(_impl_.latest_msg_type_);
}
inline ::Bohan::BaseDefine::MsgType ContactSessionInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.latest_msg_type)
  return _internal_latest_msg_type();
}
inline void ContactSessionInfo::_internal_set_latest_msg_type(::Bohan::BaseDefine::MsgType value) {
  assert(::Bohan::BaseDefine::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.latest_msg_type_ = value;
}
inline void ContactSessionInfo::set_latest_msg_type(::Bohan::BaseDefine::MsgType value) {
  _internal_set_latest_msg_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 8;
inline bool ContactSessionInfo::_internal_has_latest_msg_from_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContactSessionInfo::has_latest_msg_from_user_id() const {
  return _internal_has_latest_msg_from_user_id();
}
inline void ContactSessionInfo::clear_latest_msg_from_user_id() {
  _impl_.latest_msg_from_user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ContactSessionInfo::_internal_latest_msg_from_user_id() const {
  return _impl_.latest_msg_from_user_id_;
}
inline uint32_t ContactSessionInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
  return _internal_latest_msg_from_user_id();
}
inline void ContactSessionInfo::_internal_set_latest_msg_from_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.latest_msg_from_user_id_ = value;
}
inline void ContactSessionInfo::set_latest_msg_from_user_id(uint32_t value) {
  _internal_set_latest_msg_from_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// UserStat

// required uint32 user_id = 1;
inline bool UserStat::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserStat::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserStat::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UserStat::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserStat::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserStat.user_id)
  return _internal_user_id();
}
inline void UserStat::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void UserStat::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserStat.user_id)
}

// required .Bohan.BaseDefine.UserStatType status = 2;
inline bool UserStat::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserStat::has_status() const {
  return _internal_has_status();
}
inline void UserStat::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Bohan::BaseDefine::UserStatType UserStat::_internal_status() const {
  return static_cast< ::Bohan::BaseDefine::UserStatType >(_impl_.status_);
}
inline ::Bohan::BaseDefine::UserStatType UserStat::status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserStat.status)
  return _internal_status();
}
inline void UserStat::_internal_set_status(::Bohan::BaseDefine::UserStatType value) {
  assert(::Bohan::BaseDefine::UserStatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void UserStat::set_status(::Bohan::BaseDefine::UserStatType value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserStat.status)
}

// -------------------------------------------------------------------

// ServerUserStat

// required uint32 user_id = 1;
inline bool ServerUserStat::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerUserStat::has_user_id() const {
  return _internal_has_user_id();
}
inline void ServerUserStat::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ServerUserStat::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t ServerUserStat::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ServerUserStat.user_id)
  return _internal_user_id();
}
inline void ServerUserStat::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void ServerUserStat::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ServerUserStat.user_id)
}

// required .Bohan.BaseDefine.UserStatType status = 2;
inline bool ServerUserStat::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerUserStat::has_status() const {
  return _internal_has_status();
}
inline void ServerUserStat::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Bohan::BaseDefine::UserStatType ServerUserStat::_internal_status() const {
  return static_cast< ::Bohan::BaseDefine::UserStatType >(_impl_.status_);
}
inline ::Bohan::BaseDefine::UserStatType ServerUserStat::status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ServerUserStat.status)
  return _internal_status();
}
inline void ServerUserStat::_internal_set_status(::Bohan::BaseDefine::UserStatType value) {
  assert(::Bohan::BaseDefine::UserStatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void ServerUserStat::set_status(::Bohan::BaseDefine::UserStatType value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ServerUserStat.status)
}

// required .Bohan.BaseDefine.ClientType client_type = 3;
inline bool ServerUserStat::_internal_has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServerUserStat::has_client_type() const {
  return _internal_has_client_type();
}
inline void ServerUserStat::clear_client_type() {
  _impl_.client_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Bohan::BaseDefine::ClientType ServerUserStat::_internal_client_type() const {
  return static_cast< ::Bohan::BaseDefine::ClientType >(_impl_.client_type_);
}
inline ::Bohan::BaseDefine::ClientType ServerUserStat::client_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ServerUserStat.client_type)
  return _internal_client_type();
}
inline void ServerUserStat::_internal_set_client_type(::Bohan::BaseDefine::ClientType value) {
  assert(::Bohan::BaseDefine::ClientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_type_ = value;
}
inline void ServerUserStat::set_client_type(::Bohan::BaseDefine::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ServerUserStat.client_type)
}

// -------------------------------------------------------------------

// UnreadInfo

// required uint32 session_id = 1;
inline bool UnreadInfo::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnreadInfo::has_session_id() const {
  return _internal_has_session_id();
}
inline void UnreadInfo::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UnreadInfo::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t UnreadInfo::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.session_id)
  return _internal_session_id();
}
inline void UnreadInfo::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void UnreadInfo::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.session_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool UnreadInfo::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UnreadInfo::has_session_type() const {
  return _internal_has_session_type();
}
inline void UnreadInfo::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Bohan::BaseDefine::SessionType UnreadInfo::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType UnreadInfo::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.session_type)
  return _internal_session_type();
}
inline void UnreadInfo::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.session_type_ = value;
}
inline void UnreadInfo::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.session_type)
}

// required uint32 unread_cnt = 3;
inline bool UnreadInfo::_internal_has_unread_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnreadInfo::has_unread_cnt() const {
  return _internal_has_unread_cnt();
}
inline void UnreadInfo::clear_unread_cnt() {
  _impl_.unread_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnreadInfo::_internal_unread_cnt() const {
  return _impl_.unread_cnt_;
}
inline uint32_t UnreadInfo::unread_cnt() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.unread_cnt)
  return _internal_unread_cnt();
}
inline void UnreadInfo::_internal_set_unread_cnt(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unread_cnt_ = value;
}
inline void UnreadInfo::set_unread_cnt(uint32_t value) {
  _internal_set_unread_cnt(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.unread_cnt)
}

// required uint32 latest_msg_id = 4;
inline bool UnreadInfo::_internal_has_latest_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnreadInfo::has_latest_msg_id() const {
  return _internal_has_latest_msg_id();
}
inline void UnreadInfo::clear_latest_msg_id() {
  _impl_.latest_msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnreadInfo::_internal_latest_msg_id() const {
  return _impl_.latest_msg_id_;
}
inline uint32_t UnreadInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.latest_msg_id)
  return _internal_latest_msg_id();
}
inline void UnreadInfo::_internal_set_latest_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.latest_msg_id_ = value;
}
inline void UnreadInfo::set_latest_msg_id(uint32_t value) {
  _internal_set_latest_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.latest_msg_id)
}

// required bytes latest_msg_data = 5;
inline bool UnreadInfo::_internal_has_latest_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnreadInfo::has_latest_msg_data() const {
  return _internal_has_latest_msg_data();
}
inline void UnreadInfo::clear_latest_msg_data() {
  _impl_.latest_msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnreadInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.latest_msg_data)
  return _internal_latest_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnreadInfo::set_latest_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.latest_msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.latest_msg_data)
}
inline std::string* UnreadInfo::mutable_latest_msg_data() {
  std::string* _s = _internal_mutable_latest_msg_data();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UnreadInfo.latest_msg_data)
  return _s;
}
inline const std::string& UnreadInfo::_internal_latest_msg_data() const {
  return _impl_.latest_msg_data_.Get();
}
inline void UnreadInfo::_internal_set_latest_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latest_msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UnreadInfo::_internal_mutable_latest_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.latest_msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UnreadInfo::release_latest_msg_data() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UnreadInfo.latest_msg_data)
  if (!_internal_has_latest_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.latest_msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.latest_msg_data_.IsDefault()) {
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnreadInfo::set_allocated_latest_msg_data(std::string* latest_msg_data) {
  if (latest_msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.latest_msg_data_.SetAllocated(latest_msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.latest_msg_data_.IsDefault()) {
    _impl_.latest_msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UnreadInfo.latest_msg_data)
}

// required .Bohan.BaseDefine.MsgType latest_msg_type = 6;
inline bool UnreadInfo::_internal_has_latest_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UnreadInfo::has_latest_msg_type() const {
  return _internal_has_latest_msg_type();
}
inline void UnreadInfo::clear_latest_msg_type() {
  _impl_.latest_msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::Bohan::BaseDefine::MsgType UnreadInfo::_internal_latest_msg_type() const {
  return static_cast< ::Bohan::BaseDefine::MsgType >(_impl_.latest_msg_type_);
}
inline ::Bohan::BaseDefine::MsgType UnreadInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.latest_msg_type)
  return _internal_latest_msg_type();
}
inline void UnreadInfo::_internal_set_latest_msg_type(::Bohan::BaseDefine::MsgType value) {
  assert(::Bohan::BaseDefine::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.latest_msg_type_ = value;
}
inline void UnreadInfo::set_latest_msg_type(::Bohan::BaseDefine::MsgType value) {
  _internal_set_latest_msg_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 7;
inline bool UnreadInfo::_internal_has_latest_msg_from_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnreadInfo::has_latest_msg_from_user_id() const {
  return _internal_has_latest_msg_from_user_id();
}
inline void UnreadInfo::clear_latest_msg_from_user_id() {
  _impl_.latest_msg_from_user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnreadInfo::_internal_latest_msg_from_user_id() const {
  return _impl_.latest_msg_from_user_id_;
}
inline uint32_t UnreadInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UnreadInfo.latest_msg_from_user_id)
  return _internal_latest_msg_from_user_id();
}
inline void UnreadInfo::_internal_set_latest_msg_from_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.latest_msg_from_user_id_ = value;
}
inline void UnreadInfo::set_latest_msg_from_user_id(uint32_t value) {
  _internal_set_latest_msg_from_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UnreadInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 msg_id = 1;
inline bool MsgInfo::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgInfo::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgInfo::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.MsgInfo.msg_id)
  return _internal_msg_id();
}
inline void MsgInfo::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_id_ = value;
}
inline void MsgInfo::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.MsgInfo.msg_id)
}

// required uint32 from_session_id = 2;
inline bool MsgInfo::_internal_has_from_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgInfo::has_from_session_id() const {
  return _internal_has_from_session_id();
}
inline void MsgInfo::clear_from_session_id() {
  _impl_.from_session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgInfo::_internal_from_session_id() const {
  return _impl_.from_session_id_;
}
inline uint32_t MsgInfo::from_session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.MsgInfo.from_session_id)
  return _internal_from_session_id();
}
inline void MsgInfo::_internal_set_from_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_session_id_ = value;
}
inline void MsgInfo::set_from_session_id(uint32_t value) {
  _internal_set_from_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.MsgInfo.from_session_id)
}

// required uint32 create_time = 3;
inline bool MsgInfo::_internal_has_create_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgInfo::has_create_time() const {
  return _internal_has_create_time();
}
inline void MsgInfo::clear_create_time() {
  _impl_.create_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgInfo::_internal_create_time() const {
  return _impl_.create_time_;
}
inline uint32_t MsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.MsgInfo.create_time)
  return _internal_create_time();
}
inline void MsgInfo::_internal_set_create_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_time_ = value;
}
inline void MsgInfo::set_create_time(uint32_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.MsgInfo.create_time)
}

// required .Bohan.BaseDefine.MsgType msg_type = 4;
inline bool MsgInfo::_internal_has_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void MsgInfo::clear_msg_type() {
  _impl_.msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::MsgType MsgInfo::_internal_msg_type() const {
  return static_cast< ::Bohan::BaseDefine::MsgType >(_impl_.msg_type_);
}
inline ::Bohan::BaseDefine::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.MsgInfo.msg_type)
  return _internal_msg_type();
}
inline void MsgInfo::_internal_set_msg_type(::Bohan::BaseDefine::MsgType value) {
  assert(::Bohan::BaseDefine::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.msg_type_ = value;
}
inline void MsgInfo::set_msg_type(::Bohan::BaseDefine::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.MsgInfo.msg_type)
}

// required bytes msg_data = 5;
inline bool MsgInfo::_internal_has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_data() const {
  return _internal_has_msg_data();
}
inline void MsgInfo::clear_msg_data() {
  _impl_.msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.MsgInfo.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.MsgInfo.msg_data)
}
inline std::string* MsgInfo::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.MsgInfo.msg_data)
  return _s;
}
inline const std::string& MsgInfo::_internal_msg_data() const {
  return _impl_.msg_data_.Get();
}
inline void MsgInfo::_internal_set_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.MsgInfo.msg_data)
  if (!_internal_has_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgInfo::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// GroupVersionInfo

// required uint32 group_id = 1;
inline bool GroupVersionInfo::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupVersionInfo::has_group_id() const {
  return _internal_has_group_id();
}
inline void GroupVersionInfo::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GroupVersionInfo::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t GroupVersionInfo::group_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupVersionInfo.group_id)
  return _internal_group_id();
}
inline void GroupVersionInfo::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_id_ = value;
}
inline void GroupVersionInfo::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupVersionInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupVersionInfo::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupVersionInfo::has_version() const {
  return _internal_has_version();
}
inline void GroupVersionInfo::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GroupVersionInfo::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t GroupVersionInfo::version() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupVersionInfo.version)
  return _internal_version();
}
inline void GroupVersionInfo::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}
inline void GroupVersionInfo::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupVersionInfo.version)
}

// -------------------------------------------------------------------

// GroupInfo

// required uint32 group_id = 1;
inline bool GroupInfo::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupInfo::has_group_id() const {
  return _internal_has_group_id();
}
inline void GroupInfo::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GroupInfo::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_id)
  return _internal_group_id();
}
inline void GroupInfo::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.group_id_ = value;
}
inline void GroupInfo::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupInfo::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GroupInfo::has_version() const {
  return _internal_has_version();
}
inline void GroupInfo::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GroupInfo::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t GroupInfo::version() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.version)
  return _internal_version();
}
inline void GroupInfo::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.version_ = value;
}
inline void GroupInfo::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.version)
}

// required string group_name = 3;
inline bool GroupInfo::_internal_has_group_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupInfo::has_group_name() const {
  return _internal_has_group_name();
}
inline void GroupInfo::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_group_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_name)
}
inline std::string* GroupInfo::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.GroupInfo.group_name)
  return _s;
}
inline const std::string& GroupInfo::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void GroupInfo::_internal_set_group_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_group_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInfo::release_group_name() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.GroupInfo.group_name)
  if (!_internal_has_group_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInfo::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.GroupInfo.group_name)
}

// required string group_avatar = 4;
inline bool GroupInfo::_internal_has_group_avatar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupInfo::has_group_avatar() const {
  return _internal_has_group_avatar();
}
inline void GroupInfo::clear_group_avatar() {
  _impl_.group_avatar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_avatar)
  return _internal_group_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_group_avatar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.group_avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_avatar)
}
inline std::string* GroupInfo::mutable_group_avatar() {
  std::string* _s = _internal_mutable_group_avatar();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.GroupInfo.group_avatar)
  return _s;
}
inline const std::string& GroupInfo::_internal_group_avatar() const {
  return _impl_.group_avatar_.Get();
}
inline void GroupInfo::_internal_set_group_avatar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_group_avatar() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.group_avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInfo::release_group_avatar() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.GroupInfo.group_avatar)
  if (!_internal_has_group_avatar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.group_avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_avatar_.IsDefault()) {
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInfo::set_allocated_group_avatar(std::string* group_avatar) {
  if (group_avatar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.group_avatar_.SetAllocated(group_avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_avatar_.IsDefault()) {
    _impl_.group_avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.GroupInfo.group_avatar)
}

// required uint32 group_creator_id = 5;
inline bool GroupInfo::_internal_has_group_creator_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GroupInfo::has_group_creator_id() const {
  return _internal_has_group_creator_id();
}
inline void GroupInfo::clear_group_creator_id() {
  _impl_.group_creator_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t GroupInfo::_internal_group_creator_id() const {
  return _impl_.group_creator_id_;
}
inline uint32_t GroupInfo::group_creator_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_creator_id)
  return _internal_group_creator_id();
}
inline void GroupInfo::_internal_set_group_creator_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.group_creator_id_ = value;
}
inline void GroupInfo::set_group_creator_id(uint32_t value) {
  _internal_set_group_creator_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_creator_id)
}

// required .Bohan.BaseDefine.GroupType group_type = 6;
inline bool GroupInfo::_internal_has_group_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GroupInfo::has_group_type() const {
  return _internal_has_group_type();
}
inline void GroupInfo::clear_group_type() {
  _impl_.group_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Bohan::BaseDefine::GroupType GroupInfo::_internal_group_type() const {
  return static_cast< ::Bohan::BaseDefine::GroupType >(_impl_.group_type_);
}
inline ::Bohan::BaseDefine::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_type)
  return _internal_group_type();
}
inline void GroupInfo::_internal_set_group_type(::Bohan::BaseDefine::GroupType value) {
  assert(::Bohan::BaseDefine::GroupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.group_type_ = value;
}
inline void GroupInfo::set_group_type(::Bohan::BaseDefine::GroupType value) {
  _internal_set_group_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_type)
}

// required uint32 shield_status = 7;
inline bool GroupInfo::_internal_has_shield_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GroupInfo::has_shield_status() const {
  return _internal_has_shield_status();
}
inline void GroupInfo::clear_shield_status() {
  _impl_.shield_status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t GroupInfo::_internal_shield_status() const {
  return _impl_.shield_status_;
}
inline uint32_t GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.shield_status)
  return _internal_shield_status();
}
inline void GroupInfo::_internal_set_shield_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shield_status_ = value;
}
inline void GroupInfo::set_shield_status(uint32_t value) {
  _internal_set_shield_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.shield_status)
}

// repeated uint32 group_member_list = 8;
inline int GroupInfo::_internal_group_member_list_size() const {
  return _impl_.group_member_list_.size();
}
inline int GroupInfo::group_member_list_size() const {
  return _internal_group_member_list_size();
}
inline void GroupInfo::clear_group_member_list() {
  _impl_.group_member_list_.Clear();
}
inline uint32_t GroupInfo::_internal_group_member_list(int index) const {
  return _impl_.group_member_list_.Get(index);
}
inline uint32_t GroupInfo::group_member_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.GroupInfo.group_member_list)
  return _internal_group_member_list(index);
}
inline void GroupInfo::set_group_member_list(int index, uint32_t value) {
  _impl_.group_member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.GroupInfo.group_member_list)
}
inline void GroupInfo::_internal_add_group_member_list(uint32_t value) {
  _impl_.group_member_list_.Add(value);
}
inline void GroupInfo::add_group_member_list(uint32_t value) {
  _internal_add_group_member_list(value);
  // @@protoc_insertion_point(field_add:Bohan.BaseDefine.GroupInfo.group_member_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GroupInfo::_internal_group_member_list() const {
  return _impl_.group_member_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GroupInfo::group_member_list() const {
  // @@protoc_insertion_point(field_list:Bohan.BaseDefine.GroupInfo.group_member_list)
  return _internal_group_member_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GroupInfo::_internal_mutable_group_member_list() {
  return &_impl_.group_member_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GroupInfo::mutable_group_member_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.BaseDefine.GroupInfo.group_member_list)
  return _internal_mutable_group_member_list();
}

// -------------------------------------------------------------------

// UserTokenInfo

// required uint32 user_id = 1;
inline bool UserTokenInfo::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserTokenInfo::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserTokenInfo::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserTokenInfo::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserTokenInfo.user_id)
  return _internal_user_id();
}
inline void UserTokenInfo::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UserTokenInfo::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserTokenInfo.user_id)
}

// required .Bohan.BaseDefine.ClientType user_type = 2;
inline bool UserTokenInfo::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserTokenInfo::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserTokenInfo::clear_user_type() {
  _impl_.user_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::ClientType UserTokenInfo::_internal_user_type() const {
  return static_cast< ::Bohan::BaseDefine::ClientType >(_impl_.user_type_);
}
inline ::Bohan::BaseDefine::ClientType UserTokenInfo::user_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserTokenInfo.user_type)
  return _internal_user_type();
}
inline void UserTokenInfo::_internal_set_user_type(::Bohan::BaseDefine::ClientType value) {
  assert(::Bohan::BaseDefine::ClientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void UserTokenInfo::set_user_type(::Bohan::BaseDefine::ClientType value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserTokenInfo.user_type)
}

// required string token = 3;
inline bool UserTokenInfo::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserTokenInfo::has_token() const {
  return _internal_has_token();
}
inline void UserTokenInfo::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserTokenInfo.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserTokenInfo::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserTokenInfo.token)
}
inline std::string* UserTokenInfo::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.UserTokenInfo.token)
  return _s;
}
inline const std::string& UserTokenInfo::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserTokenInfo::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserTokenInfo::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserTokenInfo::release_token() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.UserTokenInfo.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserTokenInfo::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.UserTokenInfo.token)
}

// required uint32 push_count = 4;
inline bool UserTokenInfo::_internal_has_push_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserTokenInfo::has_push_count() const {
  return _internal_has_push_count();
}
inline void UserTokenInfo::clear_push_count() {
  _impl_.push_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserTokenInfo::_internal_push_count() const {
  return _impl_.push_count_;
}
inline uint32_t UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserTokenInfo.push_count)
  return _internal_push_count();
}
inline void UserTokenInfo::_internal_set_push_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.push_count_ = value;
}
inline void UserTokenInfo::set_push_count(uint32_t value) {
  _internal_set_push_count(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserTokenInfo.push_count)
}

// required uint32 push_type = 5;
inline bool UserTokenInfo::_internal_has_push_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserTokenInfo::has_push_type() const {
  return _internal_has_push_type();
}
inline void UserTokenInfo::clear_push_type() {
  _impl_.push_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserTokenInfo::_internal_push_type() const {
  return _impl_.push_type_;
}
inline uint32_t UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.UserTokenInfo.push_type)
  return _internal_push_type();
}
inline void UserTokenInfo::_internal_set_push_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.push_type_ = value;
}
inline void UserTokenInfo::set_push_type(uint32_t value) {
  _internal_set_push_type(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.UserTokenInfo.push_type)
}

// -------------------------------------------------------------------

// PushResult

// required string user_token = 1;
inline bool PushResult::_internal_has_user_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PushResult::has_user_token() const {
  return _internal_has_user_token();
}
inline void PushResult::clear_user_token() {
  _impl_.user_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.PushResult.user_token)
  return _internal_user_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushResult::set_user_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.PushResult.user_token)
}
inline std::string* PushResult::mutable_user_token() {
  std::string* _s = _internal_mutable_user_token();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.PushResult.user_token)
  return _s;
}
inline const std::string& PushResult::_internal_user_token() const {
  return _impl_.user_token_.Get();
}
inline void PushResult::_internal_set_user_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PushResult::_internal_mutable_user_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PushResult::release_user_token() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.PushResult.user_token)
  if (!_internal_has_user_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_token_.IsDefault()) {
    _impl_.user_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PushResult::set_allocated_user_token(std::string* user_token) {
  if (user_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_token_.SetAllocated(user_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_token_.IsDefault()) {
    _impl_.user_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.PushResult.user_token)
}

// required uint32 result_code = 2;
inline bool PushResult::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PushResult::has_result_code() const {
  return _internal_has_result_code();
}
inline void PushResult::clear_result_code() {
  _impl_.result_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PushResult::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.PushResult.result_code)
  return _internal_result_code();
}
inline void PushResult::_internal_set_result_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_code_ = value;
}
inline void PushResult::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// required uint32 user_id = 1;
inline bool ShieldStatus::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShieldStatus::has_user_id() const {
  return _internal_has_user_id();
}
inline void ShieldStatus::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ShieldStatus::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ShieldStatus.user_id)
  return _internal_user_id();
}
inline void ShieldStatus::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void ShieldStatus::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ShieldStatus.user_id)
}

// required uint32 group_id = 2;
inline bool ShieldStatus::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShieldStatus::has_group_id() const {
  return _internal_has_group_id();
}
inline void ShieldStatus::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ShieldStatus::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ShieldStatus.group_id)
  return _internal_group_id();
}
inline void ShieldStatus::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void ShieldStatus::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ShieldStatus.group_id)
}

// required uint32 shield_status = 3;
inline bool ShieldStatus::_internal_has_shield_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShieldStatus::has_shield_status() const {
  return _internal_has_shield_status();
}
inline void ShieldStatus::clear_shield_status() {
  _impl_.shield_status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ShieldStatus::_internal_shield_status() const {
  return _impl_.shield_status_;
}
inline uint32_t ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.ShieldStatus.shield_status)
  return _internal_shield_status();
}
inline void ShieldStatus::_internal_set_shield_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.shield_status_ = value;
}
inline void ShieldStatus::set_shield_status(uint32_t value) {
  _internal_set_shield_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// required uint32 from_user_id = 1;
inline bool OfflineFileInfo::_internal_has_from_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OfflineFileInfo::has_from_user_id() const {
  return _internal_has_from_user_id();
}
inline void OfflineFileInfo::clear_from_user_id() {
  _impl_.from_user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t OfflineFileInfo::_internal_from_user_id() const {
  return _impl_.from_user_id_;
}
inline uint32_t OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.OfflineFileInfo.from_user_id)
  return _internal_from_user_id();
}
inline void OfflineFileInfo::_internal_set_from_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_user_id_ = value;
}
inline void OfflineFileInfo::set_from_user_id(uint32_t value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.OfflineFileInfo.from_user_id)
}

// required string task_id = 2;
inline bool OfflineFileInfo::_internal_has_task_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OfflineFileInfo::has_task_id() const {
  return _internal_has_task_id();
}
inline void OfflineFileInfo::clear_task_id() {
  _impl_.task_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.OfflineFileInfo.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineFileInfo::set_task_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.task_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.OfflineFileInfo.task_id)
}
inline std::string* OfflineFileInfo::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.OfflineFileInfo.task_id)
  return _s;
}
inline const std::string& OfflineFileInfo::_internal_task_id() const {
  return _impl_.task_id_.Get();
}
inline void OfflineFileInfo::_internal_set_task_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::_internal_mutable_task_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.task_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.OfflineFileInfo.task_id)
  if (!_internal_has_task_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.task_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OfflineFileInfo::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.task_id_.SetAllocated(task_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.OfflineFileInfo.task_id)
}

// required string file_name = 3;
inline bool OfflineFileInfo::_internal_has_file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OfflineFileInfo::has_file_name() const {
  return _internal_has_file_name();
}
inline void OfflineFileInfo::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.OfflineFileInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfflineFileInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.OfflineFileInfo.file_name)
}
inline std::string* OfflineFileInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.OfflineFileInfo.file_name)
  return _s;
}
inline const std::string& OfflineFileInfo::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void OfflineFileInfo::_internal_set_file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::_internal_mutable_file_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OfflineFileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.OfflineFileInfo.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OfflineFileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.OfflineFileInfo.file_name)
}

// required uint32 file_size = 4;
inline bool OfflineFileInfo::_internal_has_file_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OfflineFileInfo::has_file_size() const {
  return _internal_has_file_size();
}
inline void OfflineFileInfo::clear_file_size() {
  _impl_.file_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t OfflineFileInfo::_internal_file_size() const {
  return _impl_.file_size_;
}
inline uint32_t OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.OfflineFileInfo.file_size)
  return _internal_file_size();
}
inline void OfflineFileInfo::_internal_set_file_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.file_size_ = value;
}
inline void OfflineFileInfo::set_file_size(uint32_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.OfflineFileInfo.file_size)
}

// -------------------------------------------------------------------

// DepartInfo

// required uint32 dept_id = 1;
inline bool DepartInfo::_internal_has_dept_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DepartInfo::has_dept_id() const {
  return _internal_has_dept_id();
}
inline void DepartInfo::clear_dept_id() {
  _impl_.dept_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DepartInfo::_internal_dept_id() const {
  return _impl_.dept_id_;
}
inline uint32_t DepartInfo::dept_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.DepartInfo.dept_id)
  return _internal_dept_id();
}
inline void DepartInfo::_internal_set_dept_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dept_id_ = value;
}
inline void DepartInfo::set_dept_id(uint32_t value) {
  _internal_set_dept_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.DepartInfo.dept_id)
}

// required uint32 priority = 2;
inline bool DepartInfo::_internal_has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DepartInfo::has_priority() const {
  return _internal_has_priority();
}
inline void DepartInfo::clear_priority() {
  _impl_.priority_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DepartInfo::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t DepartInfo::priority() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.DepartInfo.priority)
  return _internal_priority();
}
inline void DepartInfo::_internal_set_priority(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.priority_ = value;
}
inline void DepartInfo::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.DepartInfo.priority)
}

// required string dept_name = 3;
inline bool DepartInfo::_internal_has_dept_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DepartInfo::has_dept_name() const {
  return _internal_has_dept_name();
}
inline void DepartInfo::clear_dept_name() {
  _impl_.dept_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DepartInfo::dept_name() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.DepartInfo.dept_name)
  return _internal_dept_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DepartInfo::set_dept_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dept_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.DepartInfo.dept_name)
}
inline std::string* DepartInfo::mutable_dept_name() {
  std::string* _s = _internal_mutable_dept_name();
  // @@protoc_insertion_point(field_mutable:Bohan.BaseDefine.DepartInfo.dept_name)
  return _s;
}
inline const std::string& DepartInfo::_internal_dept_name() const {
  return _impl_.dept_name_.Get();
}
inline void DepartInfo::_internal_set_dept_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dept_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DepartInfo::_internal_mutable_dept_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dept_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DepartInfo::release_dept_name() {
  // @@protoc_insertion_point(field_release:Bohan.BaseDefine.DepartInfo.dept_name)
  if (!_internal_has_dept_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dept_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dept_name_.IsDefault()) {
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DepartInfo::set_allocated_dept_name(std::string* dept_name) {
  if (dept_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dept_name_.SetAllocated(dept_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dept_name_.IsDefault()) {
    _impl_.dept_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.BaseDefine.DepartInfo.dept_name)
}

// required uint32 parent_dept_id = 4;
inline bool DepartInfo::_internal_has_parent_dept_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DepartInfo::has_parent_dept_id() const {
  return _internal_has_parent_dept_id();
}
inline void DepartInfo::clear_parent_dept_id() {
  _impl_.parent_dept_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DepartInfo::_internal_parent_dept_id() const {
  return _impl_.parent_dept_id_;
}
inline uint32_t DepartInfo::parent_dept_id() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.DepartInfo.parent_dept_id)
  return _internal_parent_dept_id();
}
inline void DepartInfo::_internal_set_parent_dept_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.parent_dept_id_ = value;
}
inline void DepartInfo::set_parent_dept_id(uint32_t value) {
  _internal_set_parent_dept_id(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.DepartInfo.parent_dept_id)
}

// required .Bohan.BaseDefine.DepartmentStatusType dept_status = 5;
inline bool DepartInfo::_internal_has_dept_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DepartInfo::has_dept_status() const {
  return _internal_has_dept_status();
}
inline void DepartInfo::clear_dept_status() {
  _impl_.dept_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::DepartmentStatusType DepartInfo::_internal_dept_status() const {
  return static_cast< ::Bohan::BaseDefine::DepartmentStatusType >(_impl_.dept_status_);
}
inline ::Bohan::BaseDefine::DepartmentStatusType DepartInfo::dept_status() const {
  // @@protoc_insertion_point(field_get:Bohan.BaseDefine.DepartInfo.dept_status)
  return _internal_dept_status();
}
inline void DepartInfo::_internal_set_dept_status(::Bohan::BaseDefine::DepartmentStatusType value) {
  assert(::Bohan::BaseDefine::DepartmentStatusType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dept_status_ = value;
}
inline void DepartInfo::set_dept_status(::Bohan::BaseDefine::DepartmentStatusType value) {
  _internal_set_dept_status(value);
  // @@protoc_insertion_point(field_set:Bohan.BaseDefine.DepartInfo.dept_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace Bohan

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Bohan::BaseDefine::ServiceID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::LoginCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::BuddyListCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::MessageCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::GroupCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::FileCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::SwitchServiceCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::OtherCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::KickReasonType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::OnlineListType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::UserStatType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::SessionType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::MsgType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::ClientType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::GroupType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::GroupModifyType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::FileType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::ClientFileState> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::ClientFileRole> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::FileServerError> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::SessionStatusType> : ::std::true_type {};
template <> struct is_proto_enum< ::Bohan::BaseDefine::DepartmentStatusType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_BaseDefine_2eproto
