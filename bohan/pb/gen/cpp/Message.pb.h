// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "BaseDefine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Message_2eproto {
  static const uint32_t offsets[];
};
namespace Bohan {
namespace Message {
class ClientTimeReq;
struct ClientTimeReqDefaultTypeInternal;
extern ClientTimeReqDefaultTypeInternal _ClientTimeReq_default_instance_;
class ClientTimeRsp;
struct ClientTimeRspDefaultTypeInternal;
extern ClientTimeRspDefaultTypeInternal _ClientTimeRsp_default_instance_;
class GetLatestMsgIdReq;
struct GetLatestMsgIdReqDefaultTypeInternal;
extern GetLatestMsgIdReqDefaultTypeInternal _GetLatestMsgIdReq_default_instance_;
class GetLatestMsgIdRsp;
struct GetLatestMsgIdRspDefaultTypeInternal;
extern GetLatestMsgIdRspDefaultTypeInternal _GetLatestMsgIdRsp_default_instance_;
class GetMsgByIdReq;
struct GetMsgByIdReqDefaultTypeInternal;
extern GetMsgByIdReqDefaultTypeInternal _GetMsgByIdReq_default_instance_;
class GetMsgListReq;
struct GetMsgListReqDefaultTypeInternal;
extern GetMsgListReqDefaultTypeInternal _GetMsgListReq_default_instance_;
class GetMsgListRsp;
struct GetMsgListRspDefaultTypeInternal;
extern GetMsgListRspDefaultTypeInternal _GetMsgListRsp_default_instance_;
class IMGetMsgByIdRsp;
struct IMGetMsgByIdRspDefaultTypeInternal;
extern IMGetMsgByIdRspDefaultTypeInternal _IMGetMsgByIdRsp_default_instance_;
class MsgData;
struct MsgDataDefaultTypeInternal;
extern MsgDataDefaultTypeInternal _MsgData_default_instance_;
class MsgDataAck;
struct MsgDataAckDefaultTypeInternal;
extern MsgDataAckDefaultTypeInternal _MsgDataAck_default_instance_;
class MsgDataReadAck;
struct MsgDataReadAckDefaultTypeInternal;
extern MsgDataReadAckDefaultTypeInternal _MsgDataReadAck_default_instance_;
class MsgDataReadNotify;
struct MsgDataReadNotifyDefaultTypeInternal;
extern MsgDataReadNotifyDefaultTypeInternal _MsgDataReadNotify_default_instance_;
class UnreadMsgCntReq;
struct UnreadMsgCntReqDefaultTypeInternal;
extern UnreadMsgCntReqDefaultTypeInternal _UnreadMsgCntReq_default_instance_;
class UnreadMsgCntRsp;
struct UnreadMsgCntRspDefaultTypeInternal;
extern UnreadMsgCntRspDefaultTypeInternal _UnreadMsgCntRsp_default_instance_;
}  // namespace Message
}  // namespace Bohan
PROTOBUF_NAMESPACE_OPEN
template<> ::Bohan::Message::ClientTimeReq* Arena::CreateMaybeMessage<::Bohan::Message::ClientTimeReq>(Arena*);
template<> ::Bohan::Message::ClientTimeRsp* Arena::CreateMaybeMessage<::Bohan::Message::ClientTimeRsp>(Arena*);
template<> ::Bohan::Message::GetLatestMsgIdReq* Arena::CreateMaybeMessage<::Bohan::Message::GetLatestMsgIdReq>(Arena*);
template<> ::Bohan::Message::GetLatestMsgIdRsp* Arena::CreateMaybeMessage<::Bohan::Message::GetLatestMsgIdRsp>(Arena*);
template<> ::Bohan::Message::GetMsgByIdReq* Arena::CreateMaybeMessage<::Bohan::Message::GetMsgByIdReq>(Arena*);
template<> ::Bohan::Message::GetMsgListReq* Arena::CreateMaybeMessage<::Bohan::Message::GetMsgListReq>(Arena*);
template<> ::Bohan::Message::GetMsgListRsp* Arena::CreateMaybeMessage<::Bohan::Message::GetMsgListRsp>(Arena*);
template<> ::Bohan::Message::IMGetMsgByIdRsp* Arena::CreateMaybeMessage<::Bohan::Message::IMGetMsgByIdRsp>(Arena*);
template<> ::Bohan::Message::MsgData* Arena::CreateMaybeMessage<::Bohan::Message::MsgData>(Arena*);
template<> ::Bohan::Message::MsgDataAck* Arena::CreateMaybeMessage<::Bohan::Message::MsgDataAck>(Arena*);
template<> ::Bohan::Message::MsgDataReadAck* Arena::CreateMaybeMessage<::Bohan::Message::MsgDataReadAck>(Arena*);
template<> ::Bohan::Message::MsgDataReadNotify* Arena::CreateMaybeMessage<::Bohan::Message::MsgDataReadNotify>(Arena*);
template<> ::Bohan::Message::UnreadMsgCntReq* Arena::CreateMaybeMessage<::Bohan::Message::UnreadMsgCntReq>(Arena*);
template<> ::Bohan::Message::UnreadMsgCntRsp* Arena::CreateMaybeMessage<::Bohan::Message::UnreadMsgCntRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Bohan {
namespace Message {

// ===================================================================

class MsgData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.MsgData) */ {
 public:
  inline MsgData() : MsgData(nullptr) {}
  ~MsgData() override;
  explicit PROTOBUF_CONSTEXPR MsgData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgData(const MsgData& from);
  MsgData(MsgData&& from) noexcept
    : MsgData() {
    *this = ::std::move(from);
  }

  inline MsgData& operator=(const MsgData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgData& operator=(MsgData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgData* internal_default_instance() {
    return reinterpret_cast<const MsgData*>(
               &_MsgData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgData& a, MsgData& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgData& from);
  void MergeFrom(const MsgData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.MsgData";
  }
  protected:
  explicit MsgData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 6,
    kAttachDataFieldNumber = 20,
    kFromUserIdFieldNumber = 1,
    kToSessionIdFieldNumber = 2,
    kMsgIdFieldNumber = 3,
    kCreateTimeFieldNumber = 4,
    kMsgTypeFieldNumber = 5,
  };
  // required bytes msg_data = 6;
  bool has_msg_data() const;
  private:
  bool _internal_has_msg_data() const;
  public:
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  private:
  bool _internal_has_from_user_id() const;
  public:
  void clear_from_user_id();
  uint32_t from_user_id() const;
  void set_from_user_id(uint32_t value);
  private:
  uint32_t _internal_from_user_id() const;
  void _internal_set_from_user_id(uint32_t value);
  public:

  // required uint32 to_session_id = 2;
  bool has_to_session_id() const;
  private:
  bool _internal_has_to_session_id() const;
  public:
  void clear_to_session_id();
  uint32_t to_session_id() const;
  void set_to_session_id(uint32_t value);
  private:
  uint32_t _internal_to_session_id() const;
  void _internal_set_to_session_id(uint32_t value);
  public:

  // required uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required uint32 create_time = 4;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  uint32_t create_time() const;
  void set_create_time(uint32_t value);
  private:
  uint32_t _internal_create_time() const;
  void _internal_set_create_time(uint32_t value);
  public:

  // required .Bohan.BaseDefine.MsgType msg_type = 5;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::Bohan::BaseDefine::MsgType msg_type() const;
  void set_msg_type(::Bohan::BaseDefine::MsgType value);
  private:
  ::Bohan::BaseDefine::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::Bohan::BaseDefine::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.MsgData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t from_user_id_;
    uint32_t to_session_id_;
    uint32_t msg_id_;
    uint32_t create_time_;
    int msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class MsgDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.MsgDataAck) */ {
 public:
  inline MsgDataAck() : MsgDataAck(nullptr) {}
  ~MsgDataAck() override;
  explicit PROTOBUF_CONSTEXPR MsgDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataAck(const MsgDataAck& from);
  MsgDataAck(MsgDataAck&& from) noexcept
    : MsgDataAck() {
    *this = ::std::move(from);
  }

  inline MsgDataAck& operator=(const MsgDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataAck& operator=(MsgDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataAck* internal_default_instance() {
    return reinterpret_cast<const MsgDataAck*>(
               &_MsgDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgDataAck& a, MsgDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgDataAck& from);
  void MergeFrom(const MsgDataAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.MsgDataAck";
  }
  protected:
  explicit MsgDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kMsgIdFieldNumber = 3,
    kSessionTypeFieldNumber = 4,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 2;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 4;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.MsgDataAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t msg_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class MsgDataReadAck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.MsgDataReadAck) */ {
 public:
  inline MsgDataReadAck() : MsgDataReadAck(nullptr) {}
  ~MsgDataReadAck() override;
  explicit PROTOBUF_CONSTEXPR MsgDataReadAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataReadAck(const MsgDataReadAck& from);
  MsgDataReadAck(MsgDataReadAck&& from) noexcept
    : MsgDataReadAck() {
    *this = ::std::move(from);
  }

  inline MsgDataReadAck& operator=(const MsgDataReadAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataReadAck& operator=(MsgDataReadAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgDataReadAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataReadAck* internal_default_instance() {
    return reinterpret_cast<const MsgDataReadAck*>(
               &_MsgDataReadAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgDataReadAck& a, MsgDataReadAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataReadAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataReadAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataReadAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataReadAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgDataReadAck& from);
  void MergeFrom(const MsgDataReadAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgDataReadAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.MsgDataReadAck";
  }
  protected:
  explicit MsgDataReadAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kMsgIdFieldNumber = 3,
    kSessionTypeFieldNumber = 4,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 2;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 4;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.MsgDataReadAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t msg_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class MsgDataReadNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.MsgDataReadNotify) */ {
 public:
  inline MsgDataReadNotify() : MsgDataReadNotify(nullptr) {}
  ~MsgDataReadNotify() override;
  explicit PROTOBUF_CONSTEXPR MsgDataReadNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgDataReadNotify(const MsgDataReadNotify& from);
  MsgDataReadNotify(MsgDataReadNotify&& from) noexcept
    : MsgDataReadNotify() {
    *this = ::std::move(from);
  }

  inline MsgDataReadNotify& operator=(const MsgDataReadNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgDataReadNotify& operator=(MsgDataReadNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgDataReadNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgDataReadNotify* internal_default_instance() {
    return reinterpret_cast<const MsgDataReadNotify*>(
               &_MsgDataReadNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgDataReadNotify& a, MsgDataReadNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgDataReadNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgDataReadNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgDataReadNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgDataReadNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgDataReadNotify& from);
  void MergeFrom(const MsgDataReadNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgDataReadNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.MsgDataReadNotify";
  }
  protected:
  explicit MsgDataReadNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kMsgIdFieldNumber = 3,
    kSessionTypeFieldNumber = 4,
  };
  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 2;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 4;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.MsgDataReadNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t msg_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class ClientTimeReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.ClientTimeReq) */ {
 public:
  inline ClientTimeReq() : ClientTimeReq(nullptr) {}
  ~ClientTimeReq() override;
  explicit PROTOBUF_CONSTEXPR ClientTimeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientTimeReq(const ClientTimeReq& from);
  ClientTimeReq(ClientTimeReq&& from) noexcept
    : ClientTimeReq() {
    *this = ::std::move(from);
  }

  inline ClientTimeReq& operator=(const ClientTimeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientTimeReq& operator=(ClientTimeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientTimeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientTimeReq* internal_default_instance() {
    return reinterpret_cast<const ClientTimeReq*>(
               &_ClientTimeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientTimeReq& a, ClientTimeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientTimeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientTimeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientTimeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientTimeReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientTimeReq& from);
  void MergeFrom(const ClientTimeReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientTimeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.ClientTimeReq";
  }
  protected:
  explicit ClientTimeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Bohan.Message.ClientTimeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class ClientTimeRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.ClientTimeRsp) */ {
 public:
  inline ClientTimeRsp() : ClientTimeRsp(nullptr) {}
  ~ClientTimeRsp() override;
  explicit PROTOBUF_CONSTEXPR ClientTimeRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientTimeRsp(const ClientTimeRsp& from);
  ClientTimeRsp(ClientTimeRsp&& from) noexcept
    : ClientTimeRsp() {
    *this = ::std::move(from);
  }

  inline ClientTimeRsp& operator=(const ClientTimeRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientTimeRsp& operator=(ClientTimeRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientTimeRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientTimeRsp* internal_default_instance() {
    return reinterpret_cast<const ClientTimeRsp*>(
               &_ClientTimeRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientTimeRsp& a, ClientTimeRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientTimeRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientTimeRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientTimeRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientTimeRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientTimeRsp& from);
  void MergeFrom(const ClientTimeRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientTimeRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.ClientTimeRsp";
  }
  protected:
  explicit ClientTimeRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTimeFieldNumber = 1,
  };
  // required uint32 server_time = 1;
  bool has_server_time() const;
  private:
  bool _internal_has_server_time() const;
  public:
  void clear_server_time();
  uint32_t server_time() const;
  void set_server_time(uint32_t value);
  private:
  uint32_t _internal_server_time() const;
  void _internal_set_server_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.ClientTimeRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t server_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class UnreadMsgCntReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.UnreadMsgCntReq) */ {
 public:
  inline UnreadMsgCntReq() : UnreadMsgCntReq(nullptr) {}
  ~UnreadMsgCntReq() override;
  explicit PROTOBUF_CONSTEXPR UnreadMsgCntReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnreadMsgCntReq(const UnreadMsgCntReq& from);
  UnreadMsgCntReq(UnreadMsgCntReq&& from) noexcept
    : UnreadMsgCntReq() {
    *this = ::std::move(from);
  }

  inline UnreadMsgCntReq& operator=(const UnreadMsgCntReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnreadMsgCntReq& operator=(UnreadMsgCntReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnreadMsgCntReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnreadMsgCntReq* internal_default_instance() {
    return reinterpret_cast<const UnreadMsgCntReq*>(
               &_UnreadMsgCntReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UnreadMsgCntReq& a, UnreadMsgCntReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnreadMsgCntReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnreadMsgCntReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnreadMsgCntReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnreadMsgCntReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnreadMsgCntReq& from);
  void MergeFrom(const UnreadMsgCntReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnreadMsgCntReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.UnreadMsgCntReq";
  }
  protected:
  explicit UnreadMsgCntReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.UnreadMsgCntReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class UnreadMsgCntRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.UnreadMsgCntRsp) */ {
 public:
  inline UnreadMsgCntRsp() : UnreadMsgCntRsp(nullptr) {}
  ~UnreadMsgCntRsp() override;
  explicit PROTOBUF_CONSTEXPR UnreadMsgCntRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnreadMsgCntRsp(const UnreadMsgCntRsp& from);
  UnreadMsgCntRsp(UnreadMsgCntRsp&& from) noexcept
    : UnreadMsgCntRsp() {
    *this = ::std::move(from);
  }

  inline UnreadMsgCntRsp& operator=(const UnreadMsgCntRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnreadMsgCntRsp& operator=(UnreadMsgCntRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnreadMsgCntRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnreadMsgCntRsp* internal_default_instance() {
    return reinterpret_cast<const UnreadMsgCntRsp*>(
               &_UnreadMsgCntRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnreadMsgCntRsp& a, UnreadMsgCntRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UnreadMsgCntRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnreadMsgCntRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnreadMsgCntRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnreadMsgCntRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnreadMsgCntRsp& from);
  void MergeFrom(const UnreadMsgCntRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnreadMsgCntRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.UnreadMsgCntRsp";
  }
  protected:
  explicit UnreadMsgCntRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnreadinfoListFieldNumber = 3,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kTotalCntFieldNumber = 2,
  };
  // repeated .Bohan.BaseDefine.UnreadInfo unreadinfo_list = 3;
  int unreadinfo_list_size() const;
  private:
  int _internal_unreadinfo_list_size() const;
  public:
  void clear_unreadinfo_list();
  ::Bohan::BaseDefine::UnreadInfo* mutable_unreadinfo_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UnreadInfo >*
      mutable_unreadinfo_list();
  private:
  const ::Bohan::BaseDefine::UnreadInfo& _internal_unreadinfo_list(int index) const;
  ::Bohan::BaseDefine::UnreadInfo* _internal_add_unreadinfo_list();
  public:
  const ::Bohan::BaseDefine::UnreadInfo& unreadinfo_list(int index) const;
  ::Bohan::BaseDefine::UnreadInfo* add_unreadinfo_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UnreadInfo >&
      unreadinfo_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 total_cnt = 2;
  bool has_total_cnt() const;
  private:
  bool _internal_has_total_cnt() const;
  public:
  void clear_total_cnt();
  uint32_t total_cnt() const;
  void set_total_cnt(uint32_t value);
  private:
  uint32_t _internal_total_cnt() const;
  void _internal_set_total_cnt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.UnreadMsgCntRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UnreadInfo > unreadinfo_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t total_cnt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class GetMsgListReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.GetMsgListReq) */ {
 public:
  inline GetMsgListReq() : GetMsgListReq(nullptr) {}
  ~GetMsgListReq() override;
  explicit PROTOBUF_CONSTEXPR GetMsgListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMsgListReq(const GetMsgListReq& from);
  GetMsgListReq(GetMsgListReq&& from) noexcept
    : GetMsgListReq() {
    *this = ::std::move(from);
  }

  inline GetMsgListReq& operator=(const GetMsgListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMsgListReq& operator=(GetMsgListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetMsgListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMsgListReq* internal_default_instance() {
    return reinterpret_cast<const GetMsgListReq*>(
               &_GetMsgListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetMsgListReq& a, GetMsgListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMsgListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMsgListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMsgListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMsgListReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetMsgListReq& from);
  void MergeFrom(const GetMsgListReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetMsgListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.GetMsgListReq";
  }
  protected:
  explicit GetMsgListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kMsgIdBeginFieldNumber = 4,
    kMsgCntFieldNumber = 5,
    kSessionTypeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 msg_id_begin = 4;
  bool has_msg_id_begin() const;
  private:
  bool _internal_has_msg_id_begin() const;
  public:
  void clear_msg_id_begin();
  uint32_t msg_id_begin() const;
  void set_msg_id_begin(uint32_t value);
  private:
  uint32_t _internal_msg_id_begin() const;
  void _internal_set_msg_id_begin(uint32_t value);
  public:

  // required uint32 msg_cnt = 5;
  bool has_msg_cnt() const;
  private:
  bool _internal_has_msg_cnt() const;
  public:
  void clear_msg_cnt();
  uint32_t msg_cnt() const;
  void set_msg_cnt(uint32_t value);
  private:
  uint32_t _internal_msg_cnt() const;
  void _internal_set_msg_cnt(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.GetMsgListReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t msg_id_begin_;
    uint32_t msg_cnt_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class GetMsgListRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.GetMsgListRsp) */ {
 public:
  inline GetMsgListRsp() : GetMsgListRsp(nullptr) {}
  ~GetMsgListRsp() override;
  explicit PROTOBUF_CONSTEXPR GetMsgListRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMsgListRsp(const GetMsgListRsp& from);
  GetMsgListRsp(GetMsgListRsp&& from) noexcept
    : GetMsgListRsp() {
    *this = ::std::move(from);
  }

  inline GetMsgListRsp& operator=(const GetMsgListRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMsgListRsp& operator=(GetMsgListRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetMsgListRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMsgListRsp* internal_default_instance() {
    return reinterpret_cast<const GetMsgListRsp*>(
               &_GetMsgListRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetMsgListRsp& a, GetMsgListRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMsgListRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMsgListRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMsgListRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMsgListRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetMsgListRsp& from);
  void MergeFrom(const GetMsgListRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetMsgListRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.GetMsgListRsp";
  }
  protected:
  explicit GetMsgListRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgListFieldNumber = 5,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kMsgIdBeginFieldNumber = 4,
    kSessionTypeFieldNumber = 2,
  };
  // repeated .Bohan.BaseDefine.MsgInfo msg_list = 5;
  int msg_list_size() const;
  private:
  int _internal_msg_list_size() const;
  public:
  void clear_msg_list();
  ::Bohan::BaseDefine::MsgInfo* mutable_msg_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >*
      mutable_msg_list();
  private:
  const ::Bohan::BaseDefine::MsgInfo& _internal_msg_list(int index) const;
  ::Bohan::BaseDefine::MsgInfo* _internal_add_msg_list();
  public:
  const ::Bohan::BaseDefine::MsgInfo& msg_list(int index) const;
  ::Bohan::BaseDefine::MsgInfo* add_msg_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >&
      msg_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 msg_id_begin = 4;
  bool has_msg_id_begin() const;
  private:
  bool _internal_has_msg_id_begin() const;
  public:
  void clear_msg_id_begin();
  uint32_t msg_id_begin() const;
  void set_msg_id_begin(uint32_t value);
  private:
  uint32_t _internal_msg_id_begin() const;
  void _internal_set_msg_id_begin(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.GetMsgListRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo > msg_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t msg_id_begin_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class GetLatestMsgIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.GetLatestMsgIdReq) */ {
 public:
  inline GetLatestMsgIdReq() : GetLatestMsgIdReq(nullptr) {}
  ~GetLatestMsgIdReq() override;
  explicit PROTOBUF_CONSTEXPR GetLatestMsgIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestMsgIdReq(const GetLatestMsgIdReq& from);
  GetLatestMsgIdReq(GetLatestMsgIdReq&& from) noexcept
    : GetLatestMsgIdReq() {
    *this = ::std::move(from);
  }

  inline GetLatestMsgIdReq& operator=(const GetLatestMsgIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestMsgIdReq& operator=(GetLatestMsgIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetLatestMsgIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestMsgIdReq* internal_default_instance() {
    return reinterpret_cast<const GetLatestMsgIdReq*>(
               &_GetLatestMsgIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetLatestMsgIdReq& a, GetLatestMsgIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestMsgIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestMsgIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestMsgIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLatestMsgIdReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetLatestMsgIdReq& from);
  void MergeFrom(const GetLatestMsgIdReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetLatestMsgIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.GetLatestMsgIdReq";
  }
  protected:
  explicit GetLatestMsgIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kSessionTypeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.GetLatestMsgIdReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class GetLatestMsgIdRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.GetLatestMsgIdRsp) */ {
 public:
  inline GetLatestMsgIdRsp() : GetLatestMsgIdRsp(nullptr) {}
  ~GetLatestMsgIdRsp() override;
  explicit PROTOBUF_CONSTEXPR GetLatestMsgIdRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestMsgIdRsp(const GetLatestMsgIdRsp& from);
  GetLatestMsgIdRsp(GetLatestMsgIdRsp&& from) noexcept
    : GetLatestMsgIdRsp() {
    *this = ::std::move(from);
  }

  inline GetLatestMsgIdRsp& operator=(const GetLatestMsgIdRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestMsgIdRsp& operator=(GetLatestMsgIdRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetLatestMsgIdRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestMsgIdRsp* internal_default_instance() {
    return reinterpret_cast<const GetLatestMsgIdRsp*>(
               &_GetLatestMsgIdRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetLatestMsgIdRsp& a, GetLatestMsgIdRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestMsgIdRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestMsgIdRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLatestMsgIdRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLatestMsgIdRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetLatestMsgIdRsp& from);
  void MergeFrom(const GetLatestMsgIdRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetLatestMsgIdRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.GetLatestMsgIdRsp";
  }
  protected:
  explicit GetLatestMsgIdRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kLatestMsgIdFieldNumber = 4,
    kSessionTypeFieldNumber = 2,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required uint32 latest_msg_id = 4;
  bool has_latest_msg_id() const;
  private:
  bool _internal_has_latest_msg_id() const;
  public:
  void clear_latest_msg_id();
  uint32_t latest_msg_id() const;
  void set_latest_msg_id(uint32_t value);
  private:
  uint32_t _internal_latest_msg_id() const;
  void _internal_set_latest_msg_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.GetLatestMsgIdRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    uint32_t latest_msg_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class GetMsgByIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.GetMsgByIdReq) */ {
 public:
  inline GetMsgByIdReq() : GetMsgByIdReq(nullptr) {}
  ~GetMsgByIdReq() override;
  explicit PROTOBUF_CONSTEXPR GetMsgByIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMsgByIdReq(const GetMsgByIdReq& from);
  GetMsgByIdReq(GetMsgByIdReq&& from) noexcept
    : GetMsgByIdReq() {
    *this = ::std::move(from);
  }

  inline GetMsgByIdReq& operator=(const GetMsgByIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMsgByIdReq& operator=(GetMsgByIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetMsgByIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMsgByIdReq* internal_default_instance() {
    return reinterpret_cast<const GetMsgByIdReq*>(
               &_GetMsgByIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetMsgByIdReq& a, GetMsgByIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMsgByIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMsgByIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMsgByIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMsgByIdReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetMsgByIdReq& from);
  void MergeFrom(const GetMsgByIdReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetMsgByIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.GetMsgByIdReq";
  }
  protected:
  explicit GetMsgByIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgIdListFieldNumber = 4,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kSessionTypeFieldNumber = 2,
  };
  // repeated uint32 msg_id_list = 4;
  int msg_id_list_size() const;
  private:
  int _internal_msg_id_list_size() const;
  public:
  void clear_msg_id_list();
  private:
  uint32_t _internal_msg_id_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_msg_id_list() const;
  void _internal_add_msg_id_list(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_msg_id_list();
  public:
  uint32_t msg_id_list(int index) const;
  void set_msg_id_list(int index, uint32_t value);
  void add_msg_id_list(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      msg_id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_msg_id_list();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.GetMsgByIdReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > msg_id_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// -------------------------------------------------------------------

class IMGetMsgByIdRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Message.IMGetMsgByIdRsp) */ {
 public:
  inline IMGetMsgByIdRsp() : IMGetMsgByIdRsp(nullptr) {}
  ~IMGetMsgByIdRsp() override;
  explicit PROTOBUF_CONSTEXPR IMGetMsgByIdRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMGetMsgByIdRsp(const IMGetMsgByIdRsp& from);
  IMGetMsgByIdRsp(IMGetMsgByIdRsp&& from) noexcept
    : IMGetMsgByIdRsp() {
    *this = ::std::move(from);
  }

  inline IMGetMsgByIdRsp& operator=(const IMGetMsgByIdRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMGetMsgByIdRsp& operator=(IMGetMsgByIdRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IMGetMsgByIdRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMGetMsgByIdRsp* internal_default_instance() {
    return reinterpret_cast<const IMGetMsgByIdRsp*>(
               &_IMGetMsgByIdRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IMGetMsgByIdRsp& a, IMGetMsgByIdRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(IMGetMsgByIdRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMGetMsgByIdRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMGetMsgByIdRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMGetMsgByIdRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IMGetMsgByIdRsp& from);
  void MergeFrom(const IMGetMsgByIdRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMGetMsgByIdRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Message.IMGetMsgByIdRsp";
  }
  protected:
  explicit IMGetMsgByIdRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgListFieldNumber = 4,
    kAttachDataFieldNumber = 20,
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 3,
    kSessionTypeFieldNumber = 2,
  };
  // repeated .Bohan.BaseDefine.MsgInfo msg_list = 4;
  int msg_list_size() const;
  private:
  int _internal_msg_list_size() const;
  public:
  void clear_msg_list();
  ::Bohan::BaseDefine::MsgInfo* mutable_msg_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >*
      mutable_msg_list();
  private:
  const ::Bohan::BaseDefine::MsgInfo& _internal_msg_list(int index) const;
  ::Bohan::BaseDefine::MsgInfo* _internal_add_msg_list();
  public:
  const ::Bohan::BaseDefine::MsgInfo& msg_list(int index) const;
  ::Bohan::BaseDefine::MsgInfo* add_msg_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >&
      msg_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // required .Bohan.BaseDefine.SessionType session_type = 2;
  bool has_session_type() const;
  private:
  bool _internal_has_session_type() const;
  public:
  void clear_session_type();
  ::Bohan::BaseDefine::SessionType session_type() const;
  void set_session_type(::Bohan::BaseDefine::SessionType value);
  private:
  ::Bohan::BaseDefine::SessionType _internal_session_type() const;
  void _internal_set_session_type(::Bohan::BaseDefine::SessionType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Message.IMGetMsgByIdRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo > msg_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t user_id_;
    uint32_t session_id_;
    int session_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgData

// required uint32 from_user_id = 1;
inline bool MsgData::_internal_has_from_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgData::has_from_user_id() const {
  return _internal_has_from_user_id();
}
inline void MsgData::clear_from_user_id() {
  _impl_.from_user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgData::_internal_from_user_id() const {
  return _impl_.from_user_id_;
}
inline uint32_t MsgData::from_user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.from_user_id)
  return _internal_from_user_id();
}
inline void MsgData::_internal_set_from_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_user_id_ = value;
}
inline void MsgData::set_from_user_id(uint32_t value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.from_user_id)
}

// required uint32 to_session_id = 2;
inline bool MsgData::_internal_has_to_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgData::has_to_session_id() const {
  return _internal_has_to_session_id();
}
inline void MsgData::clear_to_session_id() {
  _impl_.to_session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgData::_internal_to_session_id() const {
  return _impl_.to_session_id_;
}
inline uint32_t MsgData::to_session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.to_session_id)
  return _internal_to_session_id();
}
inline void MsgData::_internal_set_to_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.to_session_id_ = value;
}
inline void MsgData::set_to_session_id(uint32_t value) {
  _internal_set_to_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.to_session_id)
}

// required uint32 msg_id = 3;
inline bool MsgData::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgData::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgData::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgData::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgData::msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.msg_id)
  return _internal_msg_id();
}
inline void MsgData::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.msg_id_ = value;
}
inline void MsgData::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.msg_id)
}

// required uint32 create_time = 4;
inline bool MsgData::_internal_has_create_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MsgData::has_create_time() const {
  return _internal_has_create_time();
}
inline void MsgData::clear_create_time() {
  _impl_.create_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MsgData::_internal_create_time() const {
  return _impl_.create_time_;
}
inline uint32_t MsgData::create_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.create_time)
  return _internal_create_time();
}
inline void MsgData::_internal_set_create_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.create_time_ = value;
}
inline void MsgData::set_create_time(uint32_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.create_time)
}

// required .Bohan.BaseDefine.MsgType msg_type = 5;
inline bool MsgData::_internal_has_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MsgData::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void MsgData::clear_msg_type() {
  _impl_.msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::Bohan::BaseDefine::MsgType MsgData::_internal_msg_type() const {
  return static_cast< ::Bohan::BaseDefine::MsgType >(_impl_.msg_type_);
}
inline ::Bohan::BaseDefine::MsgType MsgData::msg_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.msg_type)
  return _internal_msg_type();
}
inline void MsgData::_internal_set_msg_type(::Bohan::BaseDefine::MsgType value) {
  assert(::Bohan::BaseDefine::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.msg_type_ = value;
}
inline void MsgData::set_msg_type(::Bohan::BaseDefine::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.msg_type)
}

// required bytes msg_data = 6;
inline bool MsgData::_internal_has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgData::has_msg_data() const {
  return _internal_has_msg_data();
}
inline void MsgData::clear_msg_data() {
  _impl_.msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgData::msg_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgData::set_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.msg_data)
}
inline std::string* MsgData::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.MsgData.msg_data)
  return _s;
}
inline const std::string& MsgData::_internal_msg_data() const {
  return _impl_.msg_data_.Get();
}
inline void MsgData::_internal_set_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgData::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgData::release_msg_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.MsgData.msg_data)
  if (!_internal_has_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgData::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.MsgData.msg_data)
}

// optional bytes attach_data = 20;
inline bool MsgData::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgData::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgData::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MsgData::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgData.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgData::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgData.attach_data)
}
inline std::string* MsgData::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.MsgData.attach_data)
  return _s;
}
inline const std::string& MsgData::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgData::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgData::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgData::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.MsgData.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgData::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.MsgData.attach_data)
}

// -------------------------------------------------------------------

// MsgDataAck

// required uint32 user_id = 1;
inline bool MsgDataAck::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgDataAck::has_user_id() const {
  return _internal_has_user_id();
}
inline void MsgDataAck::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MsgDataAck::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t MsgDataAck::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataAck.user_id)
  return _internal_user_id();
}
inline void MsgDataAck::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void MsgDataAck::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataAck.user_id)
}

// required uint32 session_id = 2;
inline bool MsgDataAck::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgDataAck::has_session_id() const {
  return _internal_has_session_id();
}
inline void MsgDataAck::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgDataAck::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t MsgDataAck::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataAck.session_id)
  return _internal_session_id();
}
inline void MsgDataAck::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void MsgDataAck::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataAck.session_id)
}

// required uint32 msg_id = 3;
inline bool MsgDataAck::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgDataAck::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgDataAck::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgDataAck::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgDataAck::msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataAck.msg_id)
  return _internal_msg_id();
}
inline void MsgDataAck::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgDataAck::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataAck.msg_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 4;
inline bool MsgDataAck::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgDataAck::has_session_type() const {
  return _internal_has_session_type();
}
inline void MsgDataAck::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType MsgDataAck::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType MsgDataAck::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataAck.session_type)
  return _internal_session_type();
}
inline void MsgDataAck::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void MsgDataAck::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataAck.session_type)
}

// -------------------------------------------------------------------

// MsgDataReadAck

// required uint32 user_id = 1;
inline bool MsgDataReadAck::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgDataReadAck::has_user_id() const {
  return _internal_has_user_id();
}
inline void MsgDataReadAck::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MsgDataReadAck::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t MsgDataReadAck::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadAck.user_id)
  return _internal_user_id();
}
inline void MsgDataReadAck::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void MsgDataReadAck::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadAck.user_id)
}

// required uint32 session_id = 2;
inline bool MsgDataReadAck::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgDataReadAck::has_session_id() const {
  return _internal_has_session_id();
}
inline void MsgDataReadAck::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgDataReadAck::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t MsgDataReadAck::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadAck.session_id)
  return _internal_session_id();
}
inline void MsgDataReadAck::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void MsgDataReadAck::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadAck.session_id)
}

// required uint32 msg_id = 3;
inline bool MsgDataReadAck::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgDataReadAck::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgDataReadAck::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgDataReadAck::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgDataReadAck::msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadAck.msg_id)
  return _internal_msg_id();
}
inline void MsgDataReadAck::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgDataReadAck::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadAck.msg_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 4;
inline bool MsgDataReadAck::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgDataReadAck::has_session_type() const {
  return _internal_has_session_type();
}
inline void MsgDataReadAck::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType MsgDataReadAck::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType MsgDataReadAck::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadAck.session_type)
  return _internal_session_type();
}
inline void MsgDataReadAck::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void MsgDataReadAck::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadAck.session_type)
}

// -------------------------------------------------------------------

// MsgDataReadNotify

// required uint32 user_id = 1;
inline bool MsgDataReadNotify::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgDataReadNotify::has_user_id() const {
  return _internal_has_user_id();
}
inline void MsgDataReadNotify::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MsgDataReadNotify::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t MsgDataReadNotify::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadNotify.user_id)
  return _internal_user_id();
}
inline void MsgDataReadNotify::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_ = value;
}
inline void MsgDataReadNotify::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadNotify.user_id)
}

// required uint32 session_id = 2;
inline bool MsgDataReadNotify::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgDataReadNotify::has_session_id() const {
  return _internal_has_session_id();
}
inline void MsgDataReadNotify::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgDataReadNotify::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t MsgDataReadNotify::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadNotify.session_id)
  return _internal_session_id();
}
inline void MsgDataReadNotify::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void MsgDataReadNotify::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadNotify.session_id)
}

// required uint32 msg_id = 3;
inline bool MsgDataReadNotify::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgDataReadNotify::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgDataReadNotify::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgDataReadNotify::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgDataReadNotify::msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadNotify.msg_id)
  return _internal_msg_id();
}
inline void MsgDataReadNotify::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgDataReadNotify::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadNotify.msg_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 4;
inline bool MsgDataReadNotify::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgDataReadNotify::has_session_type() const {
  return _internal_has_session_type();
}
inline void MsgDataReadNotify::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType MsgDataReadNotify::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType MsgDataReadNotify::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.MsgDataReadNotify.session_type)
  return _internal_session_type();
}
inline void MsgDataReadNotify::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void MsgDataReadNotify::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.MsgDataReadNotify.session_type)
}

// -------------------------------------------------------------------

// ClientTimeReq

// -------------------------------------------------------------------

// ClientTimeRsp

// required uint32 server_time = 1;
inline bool ClientTimeRsp::_internal_has_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientTimeRsp::has_server_time() const {
  return _internal_has_server_time();
}
inline void ClientTimeRsp::clear_server_time() {
  _impl_.server_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ClientTimeRsp::_internal_server_time() const {
  return _impl_.server_time_;
}
inline uint32_t ClientTimeRsp::server_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.ClientTimeRsp.server_time)
  return _internal_server_time();
}
inline void ClientTimeRsp::_internal_set_server_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_time_ = value;
}
inline void ClientTimeRsp::set_server_time(uint32_t value) {
  _internal_set_server_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.ClientTimeRsp.server_time)
}

// -------------------------------------------------------------------

// UnreadMsgCntReq

// required uint32 user_id = 1;
inline bool UnreadMsgCntReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnreadMsgCntReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnreadMsgCntReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UnreadMsgCntReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnreadMsgCntReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntReq.user_id)
  return _internal_user_id();
}
inline void UnreadMsgCntReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UnreadMsgCntReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.UnreadMsgCntReq.user_id)
}

// optional bytes attach_data = 20;
inline bool UnreadMsgCntReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnreadMsgCntReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UnreadMsgCntReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnreadMsgCntReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnreadMsgCntReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.UnreadMsgCntReq.attach_data)
}
inline std::string* UnreadMsgCntReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.UnreadMsgCntReq.attach_data)
  return _s;
}
inline const std::string& UnreadMsgCntReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UnreadMsgCntReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UnreadMsgCntReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UnreadMsgCntReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.UnreadMsgCntReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnreadMsgCntReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.UnreadMsgCntReq.attach_data)
}

// -------------------------------------------------------------------

// UnreadMsgCntRsp

// required uint32 user_id = 1;
inline bool UnreadMsgCntRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnreadMsgCntRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnreadMsgCntRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UnreadMsgCntRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnreadMsgCntRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntRsp.user_id)
  return _internal_user_id();
}
inline void UnreadMsgCntRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void UnreadMsgCntRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.UnreadMsgCntRsp.user_id)
}

// required uint32 total_cnt = 2;
inline bool UnreadMsgCntRsp::_internal_has_total_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnreadMsgCntRsp::has_total_cnt() const {
  return _internal_has_total_cnt();
}
inline void UnreadMsgCntRsp::clear_total_cnt() {
  _impl_.total_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnreadMsgCntRsp::_internal_total_cnt() const {
  return _impl_.total_cnt_;
}
inline uint32_t UnreadMsgCntRsp::total_cnt() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntRsp.total_cnt)
  return _internal_total_cnt();
}
inline void UnreadMsgCntRsp::_internal_set_total_cnt(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.total_cnt_ = value;
}
inline void UnreadMsgCntRsp::set_total_cnt(uint32_t value) {
  _internal_set_total_cnt(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.UnreadMsgCntRsp.total_cnt)
}

// repeated .Bohan.BaseDefine.UnreadInfo unreadinfo_list = 3;
inline int UnreadMsgCntRsp::_internal_unreadinfo_list_size() const {
  return _impl_.unreadinfo_list_.size();
}
inline int UnreadMsgCntRsp::unreadinfo_list_size() const {
  return _internal_unreadinfo_list_size();
}
inline ::Bohan::BaseDefine::UnreadInfo* UnreadMsgCntRsp::mutable_unreadinfo_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Message.UnreadMsgCntRsp.unreadinfo_list)
  return _impl_.unreadinfo_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UnreadInfo >*
UnreadMsgCntRsp::mutable_unreadinfo_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Message.UnreadMsgCntRsp.unreadinfo_list)
  return &_impl_.unreadinfo_list_;
}
inline const ::Bohan::BaseDefine::UnreadInfo& UnreadMsgCntRsp::_internal_unreadinfo_list(int index) const {
  return _impl_.unreadinfo_list_.Get(index);
}
inline const ::Bohan::BaseDefine::UnreadInfo& UnreadMsgCntRsp::unreadinfo_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntRsp.unreadinfo_list)
  return _internal_unreadinfo_list(index);
}
inline ::Bohan::BaseDefine::UnreadInfo* UnreadMsgCntRsp::_internal_add_unreadinfo_list() {
  return _impl_.unreadinfo_list_.Add();
}
inline ::Bohan::BaseDefine::UnreadInfo* UnreadMsgCntRsp::add_unreadinfo_list() {
  ::Bohan::BaseDefine::UnreadInfo* _add = _internal_add_unreadinfo_list();
  // @@protoc_insertion_point(field_add:Bohan.Message.UnreadMsgCntRsp.unreadinfo_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::UnreadInfo >&
UnreadMsgCntRsp::unreadinfo_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Message.UnreadMsgCntRsp.unreadinfo_list)
  return _impl_.unreadinfo_list_;
}

// optional bytes attach_data = 20;
inline bool UnreadMsgCntRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnreadMsgCntRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void UnreadMsgCntRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnreadMsgCntRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.UnreadMsgCntRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnreadMsgCntRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.UnreadMsgCntRsp.attach_data)
}
inline std::string* UnreadMsgCntRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.UnreadMsgCntRsp.attach_data)
  return _s;
}
inline const std::string& UnreadMsgCntRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void UnreadMsgCntRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* UnreadMsgCntRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* UnreadMsgCntRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.UnreadMsgCntRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnreadMsgCntRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.UnreadMsgCntRsp.attach_data)
}

// -------------------------------------------------------------------

// GetMsgListReq

// required uint32 user_id = 1;
inline bool GetMsgListReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetMsgListReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetMsgListReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetMsgListReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetMsgListReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.user_id)
  return _internal_user_id();
}
inline void GetMsgListReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void GetMsgListReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool GetMsgListReq::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetMsgListReq::has_session_type() const {
  return _internal_has_session_type();
}
inline void GetMsgListReq::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Bohan::BaseDefine::SessionType GetMsgListReq::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType GetMsgListReq::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.session_type)
  return _internal_session_type();
}
inline void GetMsgListReq::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.session_type_ = value;
}
inline void GetMsgListReq::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.session_type)
}

// required uint32 session_id = 3;
inline bool GetMsgListReq::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetMsgListReq::has_session_id() const {
  return _internal_has_session_id();
}
inline void GetMsgListReq::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GetMsgListReq::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t GetMsgListReq::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.session_id)
  return _internal_session_id();
}
inline void GetMsgListReq::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void GetMsgListReq::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.session_id)
}

// required uint32 msg_id_begin = 4;
inline bool GetMsgListReq::_internal_has_msg_id_begin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetMsgListReq::has_msg_id_begin() const {
  return _internal_has_msg_id_begin();
}
inline void GetMsgListReq::clear_msg_id_begin() {
  _impl_.msg_id_begin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GetMsgListReq::_internal_msg_id_begin() const {
  return _impl_.msg_id_begin_;
}
inline uint32_t GetMsgListReq::msg_id_begin() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.msg_id_begin)
  return _internal_msg_id_begin();
}
inline void GetMsgListReq::_internal_set_msg_id_begin(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.msg_id_begin_ = value;
}
inline void GetMsgListReq::set_msg_id_begin(uint32_t value) {
  _internal_set_msg_id_begin(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.msg_id_begin)
}

// required uint32 msg_cnt = 5;
inline bool GetMsgListReq::_internal_has_msg_cnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetMsgListReq::has_msg_cnt() const {
  return _internal_has_msg_cnt();
}
inline void GetMsgListReq::clear_msg_cnt() {
  _impl_.msg_cnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t GetMsgListReq::_internal_msg_cnt() const {
  return _impl_.msg_cnt_;
}
inline uint32_t GetMsgListReq::msg_cnt() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.msg_cnt)
  return _internal_msg_cnt();
}
inline void GetMsgListReq::_internal_set_msg_cnt(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.msg_cnt_ = value;
}
inline void GetMsgListReq::set_msg_cnt(uint32_t value) {
  _internal_set_msg_cnt(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.msg_cnt)
}

// optional bytes attach_data = 20;
inline bool GetMsgListReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetMsgListReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void GetMsgListReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetMsgListReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMsgListReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListReq.attach_data)
}
inline std::string* GetMsgListReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetMsgListReq.attach_data)
  return _s;
}
inline const std::string& GetMsgListReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void GetMsgListReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMsgListReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMsgListReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.GetMsgListReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetMsgListReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.GetMsgListReq.attach_data)
}

// -------------------------------------------------------------------

// GetMsgListRsp

// required uint32 user_id = 1;
inline bool GetMsgListRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetMsgListRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetMsgListRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetMsgListRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetMsgListRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.user_id)
  return _internal_user_id();
}
inline void GetMsgListRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void GetMsgListRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListRsp.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool GetMsgListRsp::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetMsgListRsp::has_session_type() const {
  return _internal_has_session_type();
}
inline void GetMsgListRsp::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::SessionType GetMsgListRsp::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType GetMsgListRsp::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.session_type)
  return _internal_session_type();
}
inline void GetMsgListRsp::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_type_ = value;
}
inline void GetMsgListRsp::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListRsp.session_type)
}

// required uint32 session_id = 3;
inline bool GetMsgListRsp::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetMsgListRsp::has_session_id() const {
  return _internal_has_session_id();
}
inline void GetMsgListRsp::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GetMsgListRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t GetMsgListRsp::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.session_id)
  return _internal_session_id();
}
inline void GetMsgListRsp::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void GetMsgListRsp::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListRsp.session_id)
}

// required uint32 msg_id_begin = 4;
inline bool GetMsgListRsp::_internal_has_msg_id_begin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetMsgListRsp::has_msg_id_begin() const {
  return _internal_has_msg_id_begin();
}
inline void GetMsgListRsp::clear_msg_id_begin() {
  _impl_.msg_id_begin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GetMsgListRsp::_internal_msg_id_begin() const {
  return _impl_.msg_id_begin_;
}
inline uint32_t GetMsgListRsp::msg_id_begin() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.msg_id_begin)
  return _internal_msg_id_begin();
}
inline void GetMsgListRsp::_internal_set_msg_id_begin(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.msg_id_begin_ = value;
}
inline void GetMsgListRsp::set_msg_id_begin(uint32_t value) {
  _internal_set_msg_id_begin(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListRsp.msg_id_begin)
}

// repeated .Bohan.BaseDefine.MsgInfo msg_list = 5;
inline int GetMsgListRsp::_internal_msg_list_size() const {
  return _impl_.msg_list_.size();
}
inline int GetMsgListRsp::msg_list_size() const {
  return _internal_msg_list_size();
}
inline ::Bohan::BaseDefine::MsgInfo* GetMsgListRsp::mutable_msg_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetMsgListRsp.msg_list)
  return _impl_.msg_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >*
GetMsgListRsp::mutable_msg_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Message.GetMsgListRsp.msg_list)
  return &_impl_.msg_list_;
}
inline const ::Bohan::BaseDefine::MsgInfo& GetMsgListRsp::_internal_msg_list(int index) const {
  return _impl_.msg_list_.Get(index);
}
inline const ::Bohan::BaseDefine::MsgInfo& GetMsgListRsp::msg_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.msg_list)
  return _internal_msg_list(index);
}
inline ::Bohan::BaseDefine::MsgInfo* GetMsgListRsp::_internal_add_msg_list() {
  return _impl_.msg_list_.Add();
}
inline ::Bohan::BaseDefine::MsgInfo* GetMsgListRsp::add_msg_list() {
  ::Bohan::BaseDefine::MsgInfo* _add = _internal_add_msg_list();
  // @@protoc_insertion_point(field_add:Bohan.Message.GetMsgListRsp.msg_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >&
GetMsgListRsp::msg_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Message.GetMsgListRsp.msg_list)
  return _impl_.msg_list_;
}

// optional bytes attach_data = 20;
inline bool GetMsgListRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetMsgListRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void GetMsgListRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetMsgListRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgListRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMsgListRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgListRsp.attach_data)
}
inline std::string* GetMsgListRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetMsgListRsp.attach_data)
  return _s;
}
inline const std::string& GetMsgListRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void GetMsgListRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMsgListRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMsgListRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.GetMsgListRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetMsgListRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.GetMsgListRsp.attach_data)
}

// -------------------------------------------------------------------

// GetLatestMsgIdReq

// required uint32 user_id = 1;
inline bool GetLatestMsgIdReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetLatestMsgIdReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetLatestMsgIdReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetLatestMsgIdReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetLatestMsgIdReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdReq.user_id)
  return _internal_user_id();
}
inline void GetLatestMsgIdReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void GetLatestMsgIdReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdReq.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool GetLatestMsgIdReq::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetLatestMsgIdReq::has_session_type() const {
  return _internal_has_session_type();
}
inline void GetLatestMsgIdReq::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType GetLatestMsgIdReq::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType GetLatestMsgIdReq::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdReq.session_type)
  return _internal_session_type();
}
inline void GetLatestMsgIdReq::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void GetLatestMsgIdReq::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdReq.session_type)
}

// required uint32 session_id = 3;
inline bool GetLatestMsgIdReq::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetLatestMsgIdReq::has_session_id() const {
  return _internal_has_session_id();
}
inline void GetLatestMsgIdReq::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GetLatestMsgIdReq::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t GetLatestMsgIdReq::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdReq.session_id)
  return _internal_session_id();
}
inline void GetLatestMsgIdReq::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void GetLatestMsgIdReq::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdReq.session_id)
}

// optional bytes attach_data = 20;
inline bool GetLatestMsgIdReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetLatestMsgIdReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void GetLatestMsgIdReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetLatestMsgIdReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestMsgIdReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdReq.attach_data)
}
inline std::string* GetLatestMsgIdReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetLatestMsgIdReq.attach_data)
  return _s;
}
inline const std::string& GetLatestMsgIdReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void GetLatestMsgIdReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestMsgIdReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestMsgIdReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.GetLatestMsgIdReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetLatestMsgIdReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.GetLatestMsgIdReq.attach_data)
}

// -------------------------------------------------------------------

// GetLatestMsgIdRsp

// required uint32 user_id = 1;
inline bool GetLatestMsgIdRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetLatestMsgIdRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetLatestMsgIdRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetLatestMsgIdRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetLatestMsgIdRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdRsp.user_id)
  return _internal_user_id();
}
inline void GetLatestMsgIdRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void GetLatestMsgIdRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdRsp.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool GetLatestMsgIdRsp::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetLatestMsgIdRsp::has_session_type() const {
  return _internal_has_session_type();
}
inline void GetLatestMsgIdRsp::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::SessionType GetLatestMsgIdRsp::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType GetLatestMsgIdRsp::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdRsp.session_type)
  return _internal_session_type();
}
inline void GetLatestMsgIdRsp::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_type_ = value;
}
inline void GetLatestMsgIdRsp::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdRsp.session_type)
}

// required uint32 session_id = 3;
inline bool GetLatestMsgIdRsp::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetLatestMsgIdRsp::has_session_id() const {
  return _internal_has_session_id();
}
inline void GetLatestMsgIdRsp::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GetLatestMsgIdRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t GetLatestMsgIdRsp::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdRsp.session_id)
  return _internal_session_id();
}
inline void GetLatestMsgIdRsp::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void GetLatestMsgIdRsp::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdRsp.session_id)
}

// required uint32 latest_msg_id = 4;
inline bool GetLatestMsgIdRsp::_internal_has_latest_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetLatestMsgIdRsp::has_latest_msg_id() const {
  return _internal_has_latest_msg_id();
}
inline void GetLatestMsgIdRsp::clear_latest_msg_id() {
  _impl_.latest_msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GetLatestMsgIdRsp::_internal_latest_msg_id() const {
  return _impl_.latest_msg_id_;
}
inline uint32_t GetLatestMsgIdRsp::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdRsp.latest_msg_id)
  return _internal_latest_msg_id();
}
inline void GetLatestMsgIdRsp::_internal_set_latest_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.latest_msg_id_ = value;
}
inline void GetLatestMsgIdRsp::set_latest_msg_id(uint32_t value) {
  _internal_set_latest_msg_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdRsp.latest_msg_id)
}

// optional bytes attach_data = 20;
inline bool GetLatestMsgIdRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetLatestMsgIdRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void GetLatestMsgIdRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetLatestMsgIdRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetLatestMsgIdRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLatestMsgIdRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.GetLatestMsgIdRsp.attach_data)
}
inline std::string* GetLatestMsgIdRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetLatestMsgIdRsp.attach_data)
  return _s;
}
inline const std::string& GetLatestMsgIdRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void GetLatestMsgIdRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLatestMsgIdRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLatestMsgIdRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.GetLatestMsgIdRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetLatestMsgIdRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.GetLatestMsgIdRsp.attach_data)
}

// -------------------------------------------------------------------

// GetMsgByIdReq

// required uint32 user_id = 1;
inline bool GetMsgByIdReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetMsgByIdReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void GetMsgByIdReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetMsgByIdReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t GetMsgByIdReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgByIdReq.user_id)
  return _internal_user_id();
}
inline void GetMsgByIdReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void GetMsgByIdReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgByIdReq.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool GetMsgByIdReq::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetMsgByIdReq::has_session_type() const {
  return _internal_has_session_type();
}
inline void GetMsgByIdReq::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType GetMsgByIdReq::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType GetMsgByIdReq::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgByIdReq.session_type)
  return _internal_session_type();
}
inline void GetMsgByIdReq::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void GetMsgByIdReq::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgByIdReq.session_type)
}

// required uint32 session_id = 3;
inline bool GetMsgByIdReq::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetMsgByIdReq::has_session_id() const {
  return _internal_has_session_id();
}
inline void GetMsgByIdReq::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GetMsgByIdReq::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t GetMsgByIdReq::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgByIdReq.session_id)
  return _internal_session_id();
}
inline void GetMsgByIdReq::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void GetMsgByIdReq::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgByIdReq.session_id)
}

// repeated uint32 msg_id_list = 4;
inline int GetMsgByIdReq::_internal_msg_id_list_size() const {
  return _impl_.msg_id_list_.size();
}
inline int GetMsgByIdReq::msg_id_list_size() const {
  return _internal_msg_id_list_size();
}
inline void GetMsgByIdReq::clear_msg_id_list() {
  _impl_.msg_id_list_.Clear();
}
inline uint32_t GetMsgByIdReq::_internal_msg_id_list(int index) const {
  return _impl_.msg_id_list_.Get(index);
}
inline uint32_t GetMsgByIdReq::msg_id_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgByIdReq.msg_id_list)
  return _internal_msg_id_list(index);
}
inline void GetMsgByIdReq::set_msg_id_list(int index, uint32_t value) {
  _impl_.msg_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgByIdReq.msg_id_list)
}
inline void GetMsgByIdReq::_internal_add_msg_id_list(uint32_t value) {
  _impl_.msg_id_list_.Add(value);
}
inline void GetMsgByIdReq::add_msg_id_list(uint32_t value) {
  _internal_add_msg_id_list(value);
  // @@protoc_insertion_point(field_add:Bohan.Message.GetMsgByIdReq.msg_id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GetMsgByIdReq::_internal_msg_id_list() const {
  return _impl_.msg_id_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
GetMsgByIdReq::msg_id_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Message.GetMsgByIdReq.msg_id_list)
  return _internal_msg_id_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GetMsgByIdReq::_internal_mutable_msg_id_list() {
  return &_impl_.msg_id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
GetMsgByIdReq::mutable_msg_id_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Message.GetMsgByIdReq.msg_id_list)
  return _internal_mutable_msg_id_list();
}

// optional bytes attach_data = 20;
inline bool GetMsgByIdReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetMsgByIdReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void GetMsgByIdReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetMsgByIdReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.GetMsgByIdReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMsgByIdReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.GetMsgByIdReq.attach_data)
}
inline std::string* GetMsgByIdReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.GetMsgByIdReq.attach_data)
  return _s;
}
inline const std::string& GetMsgByIdReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void GetMsgByIdReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMsgByIdReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMsgByIdReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.GetMsgByIdReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetMsgByIdReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.GetMsgByIdReq.attach_data)
}

// -------------------------------------------------------------------

// IMGetMsgByIdRsp

// required uint32 user_id = 1;
inline bool IMGetMsgByIdRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IMGetMsgByIdRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void IMGetMsgByIdRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t IMGetMsgByIdRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t IMGetMsgByIdRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.IMGetMsgByIdRsp.user_id)
  return _internal_user_id();
}
inline void IMGetMsgByIdRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_id_ = value;
}
inline void IMGetMsgByIdRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.IMGetMsgByIdRsp.user_id)
}

// required .Bohan.BaseDefine.SessionType session_type = 2;
inline bool IMGetMsgByIdRsp::_internal_has_session_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IMGetMsgByIdRsp::has_session_type() const {
  return _internal_has_session_type();
}
inline void IMGetMsgByIdRsp::clear_session_type() {
  _impl_.session_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::SessionType IMGetMsgByIdRsp::_internal_session_type() const {
  return static_cast< ::Bohan::BaseDefine::SessionType >(_impl_.session_type_);
}
inline ::Bohan::BaseDefine::SessionType IMGetMsgByIdRsp::session_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.IMGetMsgByIdRsp.session_type)
  return _internal_session_type();
}
inline void IMGetMsgByIdRsp::_internal_set_session_type(::Bohan::BaseDefine::SessionType value) {
  assert(::Bohan::BaseDefine::SessionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_type_ = value;
}
inline void IMGetMsgByIdRsp::set_session_type(::Bohan::BaseDefine::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.IMGetMsgByIdRsp.session_type)
}

// required uint32 session_id = 3;
inline bool IMGetMsgByIdRsp::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IMGetMsgByIdRsp::has_session_id() const {
  return _internal_has_session_id();
}
inline void IMGetMsgByIdRsp::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t IMGetMsgByIdRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t IMGetMsgByIdRsp::session_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.IMGetMsgByIdRsp.session_id)
  return _internal_session_id();
}
inline void IMGetMsgByIdRsp::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.session_id_ = value;
}
inline void IMGetMsgByIdRsp::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:Bohan.Message.IMGetMsgByIdRsp.session_id)
}

// repeated .Bohan.BaseDefine.MsgInfo msg_list = 4;
inline int IMGetMsgByIdRsp::_internal_msg_list_size() const {
  return _impl_.msg_list_.size();
}
inline int IMGetMsgByIdRsp::msg_list_size() const {
  return _internal_msg_list_size();
}
inline ::Bohan::BaseDefine::MsgInfo* IMGetMsgByIdRsp::mutable_msg_list(int index) {
  // @@protoc_insertion_point(field_mutable:Bohan.Message.IMGetMsgByIdRsp.msg_list)
  return _impl_.msg_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >*
IMGetMsgByIdRsp::mutable_msg_list() {
  // @@protoc_insertion_point(field_mutable_list:Bohan.Message.IMGetMsgByIdRsp.msg_list)
  return &_impl_.msg_list_;
}
inline const ::Bohan::BaseDefine::MsgInfo& IMGetMsgByIdRsp::_internal_msg_list(int index) const {
  return _impl_.msg_list_.Get(index);
}
inline const ::Bohan::BaseDefine::MsgInfo& IMGetMsgByIdRsp::msg_list(int index) const {
  // @@protoc_insertion_point(field_get:Bohan.Message.IMGetMsgByIdRsp.msg_list)
  return _internal_msg_list(index);
}
inline ::Bohan::BaseDefine::MsgInfo* IMGetMsgByIdRsp::_internal_add_msg_list() {
  return _impl_.msg_list_.Add();
}
inline ::Bohan::BaseDefine::MsgInfo* IMGetMsgByIdRsp::add_msg_list() {
  ::Bohan::BaseDefine::MsgInfo* _add = _internal_add_msg_list();
  // @@protoc_insertion_point(field_add:Bohan.Message.IMGetMsgByIdRsp.msg_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Bohan::BaseDefine::MsgInfo >&
IMGetMsgByIdRsp::msg_list() const {
  // @@protoc_insertion_point(field_list:Bohan.Message.IMGetMsgByIdRsp.msg_list)
  return _impl_.msg_list_;
}

// optional bytes attach_data = 20;
inline bool IMGetMsgByIdRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IMGetMsgByIdRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void IMGetMsgByIdRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IMGetMsgByIdRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Message.IMGetMsgByIdRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMGetMsgByIdRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Message.IMGetMsgByIdRsp.attach_data)
}
inline std::string* IMGetMsgByIdRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Message.IMGetMsgByIdRsp.attach_data)
  return _s;
}
inline const std::string& IMGetMsgByIdRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void IMGetMsgByIdRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* IMGetMsgByIdRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* IMGetMsgByIdRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Message.IMGetMsgByIdRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IMGetMsgByIdRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Message.IMGetMsgByIdRsp.attach_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Message
}  // namespace Bohan

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Message_2eproto
