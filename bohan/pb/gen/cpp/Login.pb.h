// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Login_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "BaseDefine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Login_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Login_2eproto {
  static const uint32_t offsets[];
};
namespace Bohan {
namespace Login {
class DeviceTokenReq;
struct DeviceTokenReqDefaultTypeInternal;
extern DeviceTokenReqDefaultTypeInternal _DeviceTokenReq_default_instance_;
class DeviceTokenRsp;
struct DeviceTokenRspDefaultTypeInternal;
extern DeviceTokenRspDefaultTypeInternal _DeviceTokenRsp_default_instance_;
class KickPCClientReq;
struct KickPCClientReqDefaultTypeInternal;
extern KickPCClientReqDefaultTypeInternal _KickPCClientReq_default_instance_;
class KickPCClientRsp;
struct KickPCClientRspDefaultTypeInternal;
extern KickPCClientRspDefaultTypeInternal _KickPCClientRsp_default_instance_;
class KickUser;
struct KickUserDefaultTypeInternal;
extern KickUserDefaultTypeInternal _KickUser_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRes;
struct LoginResDefaultTypeInternal;
extern LoginResDefaultTypeInternal _LoginRes_default_instance_;
class LogoutReq;
struct LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class LogoutRsp;
struct LogoutRspDefaultTypeInternal;
extern LogoutRspDefaultTypeInternal _LogoutRsp_default_instance_;
class MsgServReq;
struct MsgServReqDefaultTypeInternal;
extern MsgServReqDefaultTypeInternal _MsgServReq_default_instance_;
class MsgServRsp;
struct MsgServRspDefaultTypeInternal;
extern MsgServRspDefaultTypeInternal _MsgServRsp_default_instance_;
}  // namespace Login
}  // namespace Bohan
PROTOBUF_NAMESPACE_OPEN
template<> ::Bohan::Login::DeviceTokenReq* Arena::CreateMaybeMessage<::Bohan::Login::DeviceTokenReq>(Arena*);
template<> ::Bohan::Login::DeviceTokenRsp* Arena::CreateMaybeMessage<::Bohan::Login::DeviceTokenRsp>(Arena*);
template<> ::Bohan::Login::KickPCClientReq* Arena::CreateMaybeMessage<::Bohan::Login::KickPCClientReq>(Arena*);
template<> ::Bohan::Login::KickPCClientRsp* Arena::CreateMaybeMessage<::Bohan::Login::KickPCClientRsp>(Arena*);
template<> ::Bohan::Login::KickUser* Arena::CreateMaybeMessage<::Bohan::Login::KickUser>(Arena*);
template<> ::Bohan::Login::LoginReq* Arena::CreateMaybeMessage<::Bohan::Login::LoginReq>(Arena*);
template<> ::Bohan::Login::LoginRes* Arena::CreateMaybeMessage<::Bohan::Login::LoginRes>(Arena*);
template<> ::Bohan::Login::LogoutReq* Arena::CreateMaybeMessage<::Bohan::Login::LogoutReq>(Arena*);
template<> ::Bohan::Login::LogoutRsp* Arena::CreateMaybeMessage<::Bohan::Login::LogoutRsp>(Arena*);
template<> ::Bohan::Login::MsgServReq* Arena::CreateMaybeMessage<::Bohan::Login::MsgServReq>(Arena*);
template<> ::Bohan::Login::MsgServRsp* Arena::CreateMaybeMessage<::Bohan::Login::MsgServRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Bohan {
namespace Login {

// ===================================================================

class MsgServReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.MsgServReq) */ {
 public:
  inline MsgServReq() : MsgServReq(nullptr) {}
  ~MsgServReq() override;
  explicit PROTOBUF_CONSTEXPR MsgServReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgServReq(const MsgServReq& from);
  MsgServReq(MsgServReq&& from) noexcept
    : MsgServReq() {
    *this = ::std::move(from);
  }

  inline MsgServReq& operator=(const MsgServReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgServReq& operator=(MsgServReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgServReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgServReq* internal_default_instance() {
    return reinterpret_cast<const MsgServReq*>(
               &_MsgServReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgServReq& a, MsgServReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgServReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgServReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgServReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgServReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgServReq& from);
  void MergeFrom(const MsgServReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgServReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.MsgServReq";
  }
  protected:
  explicit MsgServReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Bohan.Login.MsgServReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class MsgServRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.MsgServRsp) */ {
 public:
  inline MsgServRsp() : MsgServRsp(nullptr) {}
  ~MsgServRsp() override;
  explicit PROTOBUF_CONSTEXPR MsgServRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgServRsp(const MsgServRsp& from);
  MsgServRsp(MsgServRsp&& from) noexcept
    : MsgServRsp() {
    *this = ::std::move(from);
  }

  inline MsgServRsp& operator=(const MsgServRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgServRsp& operator=(MsgServRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgServRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgServRsp* internal_default_instance() {
    return reinterpret_cast<const MsgServRsp*>(
               &_MsgServRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgServRsp& a, MsgServRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgServRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgServRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgServRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgServRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgServRsp& from);
  void MergeFrom(const MsgServRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgServRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.MsgServRsp";
  }
  protected:
  explicit MsgServRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorIpFieldNumber = 2,
    kBackipIpFieldNumber = 3,
    kResultCodeFieldNumber = 1,
    kPortFieldNumber = 4,
  };
  // optional string prior_ip = 2;
  bool has_prior_ip() const;
  private:
  bool _internal_has_prior_ip() const;
  public:
  void clear_prior_ip();
  const std::string& prior_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prior_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prior_ip();
  PROTOBUF_NODISCARD std::string* release_prior_ip();
  void set_allocated_prior_ip(std::string* prior_ip);
  private:
  const std::string& _internal_prior_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prior_ip(const std::string& value);
  std::string* _internal_mutable_prior_ip();
  public:

  // optional string backip_ip = 3;
  bool has_backip_ip() const;
  private:
  bool _internal_has_backip_ip() const;
  public:
  void clear_backip_ip();
  const std::string& backip_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backip_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backip_ip();
  PROTOBUF_NODISCARD std::string* release_backip_ip();
  void set_allocated_backip_ip(std::string* backip_ip);
  private:
  const std::string& _internal_backip_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backip_ip(const std::string& value);
  std::string* _internal_mutable_backip_ip();
  public:

  // required .Bohan.BaseDefine.ResultType result_code = 1;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  ::Bohan::BaseDefine::ResultType result_code() const;
  void set_result_code(::Bohan::BaseDefine::ResultType value);
  private:
  ::Bohan::BaseDefine::ResultType _internal_result_code() const;
  void _internal_set_result_code(::Bohan::BaseDefine::ResultType value);
  public:

  // optional uint32 port = 4;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.MsgServRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prior_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backip_ip_;
    int result_code_;
    uint32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit PROTOBUF_CONSTEXPR LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kNickNameFieldNumber = 3,
    kAvatarFieldNumber = 7,
    kClientVersionFieldNumber = 8,
    kClientTypeFieldNumber = 6,
    kRoleTypeFieldNumber = 4,
    kOnlineStatusFieldNumber = 5,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // required bytes password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // required string nick_name = 3;
  bool has_nick_name() const;
  private:
  bool _internal_has_nick_name() const;
  public:
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // required string avatar = 7;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // optional string client_version = 8;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // required .Bohan.BaseDefine.ClientType client_type = 6;
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  ::Bohan::BaseDefine::ClientType client_type() const;
  void set_client_type(::Bohan::BaseDefine::ClientType value);
  private:
  ::Bohan::BaseDefine::ClientType _internal_client_type() const;
  void _internal_set_client_type(::Bohan::BaseDefine::ClientType value);
  public:

  // required .Bohan.BaseDefine.RoleType role_type = 4;
  bool has_role_type() const;
  private:
  bool _internal_has_role_type() const;
  public:
  void clear_role_type();
  ::Bohan::BaseDefine::RoleType role_type() const;
  void set_role_type(::Bohan::BaseDefine::RoleType value);
  private:
  ::Bohan::BaseDefine::RoleType _internal_role_type() const;
  void _internal_set_role_type(::Bohan::BaseDefine::RoleType value);
  public:

  // required .Bohan.BaseDefine.UserStatType online_status = 5;
  bool has_online_status() const;
  private:
  bool _internal_has_online_status() const;
  public:
  void clear_online_status();
  ::Bohan::BaseDefine::UserStatType online_status() const;
  void set_online_status(::Bohan::BaseDefine::UserStatType value);
  private:
  ::Bohan::BaseDefine::UserStatType _internal_online_status() const;
  void _internal_set_online_status(::Bohan::BaseDefine::UserStatType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.LoginReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
    int client_type_;
    int role_type_;
    int online_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class LoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.LoginRes) */ {
 public:
  inline LoginRes() : LoginRes(nullptr) {}
  ~LoginRes() override;
  explicit PROTOBUF_CONSTEXPR LoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRes(const LoginRes& from);
  LoginRes(LoginRes&& from) noexcept
    : LoginRes() {
    *this = ::std::move(from);
  }

  inline LoginRes& operator=(const LoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRes& operator=(LoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRes* internal_default_instance() {
    return reinterpret_cast<const LoginRes*>(
               &_LoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRes& a, LoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginRes& from);
  void MergeFrom(const LoginRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.LoginRes";
  }
  protected:
  explicit LoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultStringFieldNumber = 3,
    kUserInfoFieldNumber = 5,
    kServerTimeFieldNumber = 1,
    kResultCodeFieldNumber = 2,
    kOnlineStatusFieldNumber = 4,
  };
  // optional string result_string = 3;
  bool has_result_string() const;
  private:
  bool _internal_has_result_string() const;
  public:
  void clear_result_string();
  const std::string& result_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_string();
  PROTOBUF_NODISCARD std::string* release_result_string();
  void set_allocated_result_string(std::string* result_string);
  private:
  const std::string& _internal_result_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_string(const std::string& value);
  std::string* _internal_mutable_result_string();
  public:

  // optional .Bohan.BaseDefine.UserInfo user_info = 5;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::Bohan::BaseDefine::UserInfo& user_info() const;
  PROTOBUF_NODISCARD ::Bohan::BaseDefine::UserInfo* release_user_info();
  ::Bohan::BaseDefine::UserInfo* mutable_user_info();
  void set_allocated_user_info(::Bohan::BaseDefine::UserInfo* user_info);
  private:
  const ::Bohan::BaseDefine::UserInfo& _internal_user_info() const;
  ::Bohan::BaseDefine::UserInfo* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::Bohan::BaseDefine::UserInfo* user_info);
  ::Bohan::BaseDefine::UserInfo* unsafe_arena_release_user_info();

  // required uint32 server_time = 1;
  bool has_server_time() const;
  private:
  bool _internal_has_server_time() const;
  public:
  void clear_server_time();
  uint32_t server_time() const;
  void set_server_time(uint32_t value);
  private:
  uint32_t _internal_server_time() const;
  void _internal_set_server_time(uint32_t value);
  public:

  // required .Bohan.BaseDefine.ResultType result_code = 2;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  ::Bohan::BaseDefine::ResultType result_code() const;
  void set_result_code(::Bohan::BaseDefine::ResultType value);
  private:
  ::Bohan::BaseDefine::ResultType _internal_result_code() const;
  void _internal_set_result_code(::Bohan::BaseDefine::ResultType value);
  public:

  // optional .Bohan.BaseDefine.UserStatType online_status = 4;
  bool has_online_status() const;
  private:
  bool _internal_has_online_status() const;
  public:
  void clear_online_status();
  ::Bohan::BaseDefine::UserStatType online_status() const;
  void set_online_status(::Bohan::BaseDefine::UserStatType value);
  private:
  ::Bohan::BaseDefine::UserStatType _internal_online_status() const;
  void _internal_set_online_status(::Bohan::BaseDefine::UserStatType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.LoginRes)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_string_;
    ::Bohan::BaseDefine::UserInfo* user_info_;
    uint32_t server_time_;
    int result_code_;
    int online_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class LogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.LogoutReq) */ {
 public:
  inline LogoutReq() : LogoutReq(nullptr) {}
  ~LogoutReq() override;
  explicit PROTOBUF_CONSTEXPR LogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReq(const LogoutReq& from);
  LogoutReq(LogoutReq&& from) noexcept
    : LogoutReq() {
    *this = ::std::move(from);
  }

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReq& operator=(LogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutReq& a, LogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogoutReq& from);
  void MergeFrom(const LogoutReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.LogoutReq";
  }
  protected:
  explicit LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Bohan.Login.LogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class LogoutRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.LogoutRsp) */ {
 public:
  inline LogoutRsp() : LogoutRsp(nullptr) {}
  ~LogoutRsp() override;
  explicit PROTOBUF_CONSTEXPR LogoutRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRsp(const LogoutRsp& from);
  LogoutRsp(LogoutRsp&& from) noexcept
    : LogoutRsp() {
    *this = ::std::move(from);
  }

  inline LogoutRsp& operator=(const LogoutRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRsp& operator=(LogoutRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LogoutRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRsp* internal_default_instance() {
    return reinterpret_cast<const LogoutRsp*>(
               &_LogoutRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogoutRsp& a, LogoutRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LogoutRsp& from);
  void MergeFrom(const LogoutRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.LogoutRsp";
  }
  protected:
  explicit LogoutRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultCodeFieldNumber = 1,
  };
  // required uint32 result_code = 1;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.LogoutRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t result_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class KickUser final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.KickUser) */ {
 public:
  inline KickUser() : KickUser(nullptr) {}
  ~KickUser() override;
  explicit PROTOBUF_CONSTEXPR KickUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickUser(const KickUser& from);
  KickUser(KickUser&& from) noexcept
    : KickUser() {
    *this = ::std::move(from);
  }

  inline KickUser& operator=(const KickUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickUser& operator=(KickUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KickUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickUser* internal_default_instance() {
    return reinterpret_cast<const KickUser*>(
               &_KickUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KickUser& a, KickUser& b) {
    a.Swap(&b);
  }
  inline void Swap(KickUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickUser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KickUser& from);
  void MergeFrom(const KickUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.KickUser";
  }
  protected:
  explicit KickUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kKickReasonFieldNumber = 2,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // required .Bohan.BaseDefine.KickReasonType kick_reason = 2;
  bool has_kick_reason() const;
  private:
  bool _internal_has_kick_reason() const;
  public:
  void clear_kick_reason();
  ::Bohan::BaseDefine::KickReasonType kick_reason() const;
  void set_kick_reason(::Bohan::BaseDefine::KickReasonType value);
  private:
  ::Bohan::BaseDefine::KickReasonType _internal_kick_reason() const;
  void _internal_set_kick_reason(::Bohan::BaseDefine::KickReasonType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.KickUser)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    int kick_reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class DeviceTokenReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.DeviceTokenReq) */ {
 public:
  inline DeviceTokenReq() : DeviceTokenReq(nullptr) {}
  ~DeviceTokenReq() override;
  explicit PROTOBUF_CONSTEXPR DeviceTokenReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceTokenReq(const DeviceTokenReq& from);
  DeviceTokenReq(DeviceTokenReq&& from) noexcept
    : DeviceTokenReq() {
    *this = ::std::move(from);
  }

  inline DeviceTokenReq& operator=(const DeviceTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceTokenReq& operator=(DeviceTokenReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceTokenReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceTokenReq* internal_default_instance() {
    return reinterpret_cast<const DeviceTokenReq*>(
               &_DeviceTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeviceTokenReq& a, DeviceTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceTokenReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceTokenReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceTokenReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceTokenReq& from);
  void MergeFrom(const DeviceTokenReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceTokenReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.DeviceTokenReq";
  }
  protected:
  explicit DeviceTokenReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kDeviceTokenFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kClientTypeFieldNumber = 3,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // required string device_token = 2;
  bool has_device_token() const;
  private:
  bool _internal_has_device_token() const;
  public:
  void clear_device_token();
  const std::string& device_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_token();
  PROTOBUF_NODISCARD std::string* release_device_token();
  void set_allocated_device_token(std::string* device_token);
  private:
  const std::string& _internal_device_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
  std::string* _internal_mutable_device_token();
  public:

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // optional .Bohan.BaseDefine.ClientType client_type = 3;
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  ::Bohan::BaseDefine::ClientType client_type() const;
  void set_client_type(::Bohan::BaseDefine::ClientType value);
  private:
  ::Bohan::BaseDefine::ClientType _internal_client_type() const;
  void _internal_set_client_type(::Bohan::BaseDefine::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.DeviceTokenReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    int client_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class DeviceTokenRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.DeviceTokenRsp) */ {
 public:
  inline DeviceTokenRsp() : DeviceTokenRsp(nullptr) {}
  ~DeviceTokenRsp() override;
  explicit PROTOBUF_CONSTEXPR DeviceTokenRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceTokenRsp(const DeviceTokenRsp& from);
  DeviceTokenRsp(DeviceTokenRsp&& from) noexcept
    : DeviceTokenRsp() {
    *this = ::std::move(from);
  }

  inline DeviceTokenRsp& operator=(const DeviceTokenRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceTokenRsp& operator=(DeviceTokenRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceTokenRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceTokenRsp* internal_default_instance() {
    return reinterpret_cast<const DeviceTokenRsp*>(
               &_DeviceTokenRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeviceTokenRsp& a, DeviceTokenRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceTokenRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceTokenRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceTokenRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceTokenRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceTokenRsp& from);
  void MergeFrom(const DeviceTokenRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceTokenRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.DeviceTokenRsp";
  }
  protected:
  explicit DeviceTokenRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kAttachDataFieldNumber = 20,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.DeviceTokenRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class KickPCClientReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.KickPCClientReq) */ {
 public:
  inline KickPCClientReq() : KickPCClientReq(nullptr) {}
  ~KickPCClientReq() override;
  explicit PROTOBUF_CONSTEXPR KickPCClientReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPCClientReq(const KickPCClientReq& from);
  KickPCClientReq(KickPCClientReq&& from) noexcept
    : KickPCClientReq() {
    *this = ::std::move(from);
  }

  inline KickPCClientReq& operator=(const KickPCClientReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPCClientReq& operator=(KickPCClientReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KickPCClientReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPCClientReq* internal_default_instance() {
    return reinterpret_cast<const KickPCClientReq*>(
               &_KickPCClientReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KickPCClientReq& a, KickPCClientReq& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPCClientReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPCClientReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPCClientReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPCClientReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KickPCClientReq& from);
  void MergeFrom(const KickPCClientReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPCClientReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.KickPCClientReq";
  }
  protected:
  explicit KickPCClientReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.KickPCClientReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class KickPCClientRsp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Bohan.Login.KickPCClientRsp) */ {
 public:
  inline KickPCClientRsp() : KickPCClientRsp(nullptr) {}
  ~KickPCClientRsp() override;
  explicit PROTOBUF_CONSTEXPR KickPCClientRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPCClientRsp(const KickPCClientRsp& from);
  KickPCClientRsp(KickPCClientRsp&& from) noexcept
    : KickPCClientRsp() {
    *this = ::std::move(from);
  }

  inline KickPCClientRsp& operator=(const KickPCClientRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPCClientRsp& operator=(KickPCClientRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KickPCClientRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPCClientRsp* internal_default_instance() {
    return reinterpret_cast<const KickPCClientRsp*>(
               &_KickPCClientRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(KickPCClientRsp& a, KickPCClientRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPCClientRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPCClientRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPCClientRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPCClientRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KickPCClientRsp& from);
  void MergeFrom(const KickPCClientRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPCClientRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bohan.Login.KickPCClientRsp";
  }
  protected:
  explicit KickPCClientRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kResultCodeFieldNumber = 2,
  };
  // required bytes user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // required uint32 result_code = 2;
  bool has_result_code() const;
  private:
  bool _internal_has_result_code() const;
  public:
  void clear_result_code();
  uint32_t result_code() const;
  void set_result_code(uint32_t value);
  private:
  uint32_t _internal_result_code() const;
  void _internal_set_result_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Bohan.Login.KickPCClientRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    uint32_t result_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgServReq

// -------------------------------------------------------------------

// MsgServRsp

// required .Bohan.BaseDefine.ResultType result_code = 1;
inline bool MsgServRsp::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgServRsp::has_result_code() const {
  return _internal_has_result_code();
}
inline void MsgServRsp::clear_result_code() {
  _impl_.result_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Bohan::BaseDefine::ResultType MsgServRsp::_internal_result_code() const {
  return static_cast< ::Bohan::BaseDefine::ResultType >(_impl_.result_code_);
}
inline ::Bohan::BaseDefine::ResultType MsgServRsp::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.MsgServRsp.result_code)
  return _internal_result_code();
}
inline void MsgServRsp::_internal_set_result_code(::Bohan::BaseDefine::ResultType value) {
  assert(::Bohan::BaseDefine::ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.result_code_ = value;
}
inline void MsgServRsp::set_result_code(::Bohan::BaseDefine::ResultType value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.MsgServRsp.result_code)
}

// optional string prior_ip = 2;
inline bool MsgServRsp::_internal_has_prior_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgServRsp::has_prior_ip() const {
  return _internal_has_prior_ip();
}
inline void MsgServRsp::clear_prior_ip() {
  _impl_.prior_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgServRsp::prior_ip() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.MsgServRsp.prior_ip)
  return _internal_prior_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgServRsp::set_prior_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.prior_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.MsgServRsp.prior_ip)
}
inline std::string* MsgServRsp::mutable_prior_ip() {
  std::string* _s = _internal_mutable_prior_ip();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.MsgServRsp.prior_ip)
  return _s;
}
inline const std::string& MsgServRsp::_internal_prior_ip() const {
  return _impl_.prior_ip_.Get();
}
inline void MsgServRsp::_internal_set_prior_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prior_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgServRsp::_internal_mutable_prior_ip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prior_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgServRsp::release_prior_ip() {
  // @@protoc_insertion_point(field_release:Bohan.Login.MsgServRsp.prior_ip)
  if (!_internal_has_prior_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.prior_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prior_ip_.IsDefault()) {
    _impl_.prior_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgServRsp::set_allocated_prior_ip(std::string* prior_ip) {
  if (prior_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prior_ip_.SetAllocated(prior_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prior_ip_.IsDefault()) {
    _impl_.prior_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.MsgServRsp.prior_ip)
}

// optional string backip_ip = 3;
inline bool MsgServRsp::_internal_has_backip_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgServRsp::has_backip_ip() const {
  return _internal_has_backip_ip();
}
inline void MsgServRsp::clear_backip_ip() {
  _impl_.backip_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MsgServRsp::backip_ip() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.MsgServRsp.backip_ip)
  return _internal_backip_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgServRsp::set_backip_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.backip_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.MsgServRsp.backip_ip)
}
inline std::string* MsgServRsp::mutable_backip_ip() {
  std::string* _s = _internal_mutable_backip_ip();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.MsgServRsp.backip_ip)
  return _s;
}
inline const std::string& MsgServRsp::_internal_backip_ip() const {
  return _impl_.backip_ip_.Get();
}
inline void MsgServRsp::_internal_set_backip_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.backip_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgServRsp::_internal_mutable_backip_ip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.backip_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgServRsp::release_backip_ip() {
  // @@protoc_insertion_point(field_release:Bohan.Login.MsgServRsp.backip_ip)
  if (!_internal_has_backip_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.backip_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backip_ip_.IsDefault()) {
    _impl_.backip_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgServRsp::set_allocated_backip_ip(std::string* backip_ip) {
  if (backip_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.backip_ip_.SetAllocated(backip_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backip_ip_.IsDefault()) {
    _impl_.backip_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.MsgServRsp.backip_ip)
}

// optional uint32 port = 4;
inline bool MsgServRsp::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgServRsp::has_port() const {
  return _internal_has_port();
}
inline void MsgServRsp::clear_port() {
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgServRsp::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t MsgServRsp::port() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.MsgServRsp.port)
  return _internal_port();
}
inline void MsgServRsp::_internal_set_port(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.port_ = value;
}
inline void MsgServRsp::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.MsgServRsp.port)
}

// -------------------------------------------------------------------

// LoginReq

// required bytes user_id = 1;
inline bool LoginReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginReq::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.user_id)
}
inline std::string* LoginReq::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginReq.user_id)
  return _s;
}
inline const std::string& LoginReq::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void LoginReq::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginReq.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReq::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginReq.user_id)
}

// required bytes password = 2;
inline bool LoginReq::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginReq::has_password() const {
  return _internal_has_password();
}
inline void LoginReq::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.password)
}
inline std::string* LoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginReq.password)
  return _s;
}
inline const std::string& LoginReq::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginReq::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginReq.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginReq.password)
}

// required string nick_name = 3;
inline bool LoginReq::_internal_has_nick_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginReq::has_nick_name() const {
  return _internal_has_nick_name();
}
inline void LoginReq::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginReq::nick_name() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_nick_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.nick_name)
}
inline std::string* LoginReq::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginReq.nick_name)
  return _s;
}
inline const std::string& LoginReq::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void LoginReq::_internal_set_nick_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_nick_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_nick_name() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginReq.nick_name)
  if (!_internal_has_nick_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.nick_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReq::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginReq.nick_name)
}

// required .Bohan.BaseDefine.RoleType role_type = 4;
inline bool LoginReq::_internal_has_role_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoginReq::has_role_type() const {
  return _internal_has_role_type();
}
inline void LoginReq::clear_role_type() {
  _impl_.role_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::Bohan::BaseDefine::RoleType LoginReq::_internal_role_type() const {
  return static_cast< ::Bohan::BaseDefine::RoleType >(_impl_.role_type_);
}
inline ::Bohan::BaseDefine::RoleType LoginReq::role_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.role_type)
  return _internal_role_type();
}
inline void LoginReq::_internal_set_role_type(::Bohan::BaseDefine::RoleType value) {
  assert(::Bohan::BaseDefine::RoleType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.role_type_ = value;
}
inline void LoginReq::set_role_type(::Bohan::BaseDefine::RoleType value) {
  _internal_set_role_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.role_type)
}

// required .Bohan.BaseDefine.UserStatType online_status = 5;
inline bool LoginReq::_internal_has_online_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LoginReq::has_online_status() const {
  return _internal_has_online_status();
}
inline void LoginReq::clear_online_status() {
  _impl_.online_status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::Bohan::BaseDefine::UserStatType LoginReq::_internal_online_status() const {
  return static_cast< ::Bohan::BaseDefine::UserStatType >(_impl_.online_status_);
}
inline ::Bohan::BaseDefine::UserStatType LoginReq::online_status() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.online_status)
  return _internal_online_status();
}
inline void LoginReq::_internal_set_online_status(::Bohan::BaseDefine::UserStatType value) {
  assert(::Bohan::BaseDefine::UserStatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.online_status_ = value;
}
inline void LoginReq::set_online_status(::Bohan::BaseDefine::UserStatType value) {
  _internal_set_online_status(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.online_status)
}

// required .Bohan.BaseDefine.ClientType client_type = 6;
inline bool LoginReq::_internal_has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginReq::has_client_type() const {
  return _internal_has_client_type();
}
inline void LoginReq::clear_client_type() {
  _impl_.client_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::Bohan::BaseDefine::ClientType LoginReq::_internal_client_type() const {
  return static_cast< ::Bohan::BaseDefine::ClientType >(_impl_.client_type_);
}
inline ::Bohan::BaseDefine::ClientType LoginReq::client_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.client_type)
  return _internal_client_type();
}
inline void LoginReq::_internal_set_client_type(::Bohan::BaseDefine::ClientType value) {
  assert(::Bohan::BaseDefine::ClientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.client_type_ = value;
}
inline void LoginReq::set_client_type(::Bohan::BaseDefine::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.client_type)
}

// required string avatar = 7;
inline bool LoginReq::_internal_has_avatar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginReq::has_avatar() const {
  return _internal_has_avatar();
}
inline void LoginReq::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LoginReq::avatar() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_avatar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.avatar)
}
inline std::string* LoginReq::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginReq.avatar)
  return _s;
}
inline const std::string& LoginReq::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void LoginReq::_internal_set_avatar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_avatar() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_avatar() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginReq.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReq::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginReq.avatar)
}

// optional string client_version = 8;
inline bool LoginReq::_internal_has_client_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginReq::has_client_version() const {
  return _internal_has_client_version();
}
inline void LoginReq::clear_client_version() {
  _impl_.client_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LoginReq::client_version() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginReq.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_client_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginReq.client_version)
}
inline std::string* LoginReq::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginReq.client_version)
  return _s;
}
inline const std::string& LoginReq::_internal_client_version() const {
  return _impl_.client_version_.Get();
}
inline void LoginReq::_internal_set_client_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_client_version() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_client_version() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginReq.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReq::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginReq.client_version)
}

// -------------------------------------------------------------------

// LoginRes

// required uint32 server_time = 1;
inline bool LoginRes::_internal_has_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginRes::has_server_time() const {
  return _internal_has_server_time();
}
inline void LoginRes::clear_server_time() {
  _impl_.server_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginRes::_internal_server_time() const {
  return _impl_.server_time_;
}
inline uint32_t LoginRes::server_time() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginRes.server_time)
  return _internal_server_time();
}
inline void LoginRes::_internal_set_server_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.server_time_ = value;
}
inline void LoginRes::set_server_time(uint32_t value) {
  _internal_set_server_time(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginRes.server_time)
}

// required .Bohan.BaseDefine.ResultType result_code = 2;
inline bool LoginRes::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginRes::has_result_code() const {
  return _internal_has_result_code();
}
inline void LoginRes::clear_result_code() {
  _impl_.result_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::ResultType LoginRes::_internal_result_code() const {
  return static_cast< ::Bohan::BaseDefine::ResultType >(_impl_.result_code_);
}
inline ::Bohan::BaseDefine::ResultType LoginRes::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginRes.result_code)
  return _internal_result_code();
}
inline void LoginRes::_internal_set_result_code(::Bohan::BaseDefine::ResultType value) {
  assert(::Bohan::BaseDefine::ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_code_ = value;
}
inline void LoginRes::set_result_code(::Bohan::BaseDefine::ResultType value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginRes.result_code)
}

// optional string result_string = 3;
inline bool LoginRes::_internal_has_result_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginRes::has_result_string() const {
  return _internal_has_result_string();
}
inline void LoginRes::clear_result_string() {
  _impl_.result_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRes::result_string() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginRes.result_string)
  return _internal_result_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRes::set_result_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.result_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginRes.result_string)
}
inline std::string* LoginRes::mutable_result_string() {
  std::string* _s = _internal_mutable_result_string();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginRes.result_string)
  return _s;
}
inline const std::string& LoginRes::_internal_result_string() const {
  return _impl_.result_string_.Get();
}
inline void LoginRes::_internal_set_result_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_string_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRes::_internal_mutable_result_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.result_string_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRes::release_result_string() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginRes.result_string)
  if (!_internal_has_result_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.result_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_string_.IsDefault()) {
    _impl_.result_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginRes::set_allocated_result_string(std::string* result_string) {
  if (result_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_string_.SetAllocated(result_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_string_.IsDefault()) {
    _impl_.result_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginRes.result_string)
}

// optional .Bohan.BaseDefine.UserStatType online_status = 4;
inline bool LoginRes::_internal_has_online_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginRes::has_online_status() const {
  return _internal_has_online_status();
}
inline void LoginRes::clear_online_status() {
  _impl_.online_status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::Bohan::BaseDefine::UserStatType LoginRes::_internal_online_status() const {
  return static_cast< ::Bohan::BaseDefine::UserStatType >(_impl_.online_status_);
}
inline ::Bohan::BaseDefine::UserStatType LoginRes::online_status() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginRes.online_status)
  return _internal_online_status();
}
inline void LoginRes::_internal_set_online_status(::Bohan::BaseDefine::UserStatType value) {
  assert(::Bohan::BaseDefine::UserStatType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.online_status_ = value;
}
inline void LoginRes::set_online_status(::Bohan::BaseDefine::UserStatType value) {
  _internal_set_online_status(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LoginRes.online_status)
}

// optional .Bohan.BaseDefine.UserInfo user_info = 5;
inline bool LoginRes::_internal_has_user_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_info_ != nullptr);
  return value;
}
inline bool LoginRes::has_user_info() const {
  return _internal_has_user_info();
}
inline const ::Bohan::BaseDefine::UserInfo& LoginRes::_internal_user_info() const {
  const ::Bohan::BaseDefine::UserInfo* p = _impl_.user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Bohan::BaseDefine::UserInfo&>(
      ::Bohan::BaseDefine::_UserInfo_default_instance_);
}
inline const ::Bohan::BaseDefine::UserInfo& LoginRes::user_info() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LoginRes.user_info)
  return _internal_user_info();
}
inline void LoginRes::unsafe_arena_set_allocated_user_info(
    ::Bohan::BaseDefine::UserInfo* user_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  _impl_.user_info_ = user_info;
  if (user_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Bohan.Login.LoginRes.user_info)
}
inline ::Bohan::BaseDefine::UserInfo* LoginRes::release_user_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Bohan::BaseDefine::UserInfo* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Bohan::BaseDefine::UserInfo* LoginRes::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_release:Bohan.Login.LoginRes.user_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Bohan::BaseDefine::UserInfo* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
  return temp;
}
inline ::Bohan::BaseDefine::UserInfo* LoginRes::_internal_mutable_user_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Bohan::BaseDefine::UserInfo>(GetArenaForAllocation());
    _impl_.user_info_ = p;
  }
  return _impl_.user_info_;
}
inline ::Bohan::BaseDefine::UserInfo* LoginRes::mutable_user_info() {
  ::Bohan::BaseDefine::UserInfo* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.LoginRes.user_info)
  return _msg;
}
inline void LoginRes::set_allocated_user_info(::Bohan::BaseDefine::UserInfo* user_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_info_);
  }
  if (user_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_info));
    if (message_arena != submessage_arena) {
      user_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.LoginRes.user_info)
}

// -------------------------------------------------------------------

// LogoutReq

// -------------------------------------------------------------------

// LogoutRsp

// required uint32 result_code = 1;
inline bool LogoutRsp::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutRsp::has_result_code() const {
  return _internal_has_result_code();
}
inline void LogoutRsp::clear_result_code() {
  _impl_.result_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t LogoutRsp::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t LogoutRsp::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.LogoutRsp.result_code)
  return _internal_result_code();
}
inline void LogoutRsp::_internal_set_result_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_code_ = value;
}
inline void LogoutRsp::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.LogoutRsp.result_code)
}

// -------------------------------------------------------------------

// KickUser

// required bytes user_id = 1;
inline bool KickUser::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickUser::has_user_id() const {
  return _internal_has_user_id();
}
inline void KickUser::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KickUser::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.KickUser.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickUser::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.KickUser.user_id)
}
inline std::string* KickUser::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.KickUser.user_id)
  return _s;
}
inline const std::string& KickUser::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void KickUser::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KickUser::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KickUser::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.KickUser.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickUser::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.KickUser.user_id)
}

// required .Bohan.BaseDefine.KickReasonType kick_reason = 2;
inline bool KickUser::_internal_has_kick_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickUser::has_kick_reason() const {
  return _internal_has_kick_reason();
}
inline void KickUser::clear_kick_reason() {
  _impl_.kick_reason_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::Bohan::BaseDefine::KickReasonType KickUser::_internal_kick_reason() const {
  return static_cast< ::Bohan::BaseDefine::KickReasonType >(_impl_.kick_reason_);
}
inline ::Bohan::BaseDefine::KickReasonType KickUser::kick_reason() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.KickUser.kick_reason)
  return _internal_kick_reason();
}
inline void KickUser::_internal_set_kick_reason(::Bohan::BaseDefine::KickReasonType value) {
  assert(::Bohan::BaseDefine::KickReasonType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kick_reason_ = value;
}
inline void KickUser::set_kick_reason(::Bohan::BaseDefine::KickReasonType value) {
  _internal_set_kick_reason(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.KickUser.kick_reason)
}

// -------------------------------------------------------------------

// DeviceTokenReq

// required bytes user_id = 1;
inline bool DeviceTokenReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceTokenReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void DeviceTokenReq::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceTokenReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenReq.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceTokenReq::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenReq.user_id)
}
inline std::string* DeviceTokenReq::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.DeviceTokenReq.user_id)
  return _s;
}
inline const std::string& DeviceTokenReq::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DeviceTokenReq::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.DeviceTokenReq.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceTokenReq::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.DeviceTokenReq.user_id)
}

// required string device_token = 2;
inline bool DeviceTokenReq::_internal_has_device_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceTokenReq::has_device_token() const {
  return _internal_has_device_token();
}
inline void DeviceTokenReq::clear_device_token() {
  _impl_.device_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceTokenReq::device_token() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenReq.device_token)
  return _internal_device_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceTokenReq::set_device_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.device_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenReq.device_token)
}
inline std::string* DeviceTokenReq::mutable_device_token() {
  std::string* _s = _internal_mutable_device_token();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.DeviceTokenReq.device_token)
  return _s;
}
inline const std::string& DeviceTokenReq::_internal_device_token() const {
  return _impl_.device_token_.Get();
}
inline void DeviceTokenReq::_internal_set_device_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_token_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::_internal_mutable_device_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.device_token_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::release_device_token() {
  // @@protoc_insertion_point(field_release:Bohan.Login.DeviceTokenReq.device_token)
  if (!_internal_has_device_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.device_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_token_.IsDefault()) {
    _impl_.device_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceTokenReq::set_allocated_device_token(std::string* device_token) {
  if (device_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.device_token_.SetAllocated(device_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_token_.IsDefault()) {
    _impl_.device_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.DeviceTokenReq.device_token)
}

// optional .Bohan.BaseDefine.ClientType client_type = 3;
inline bool DeviceTokenReq::_internal_has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceTokenReq::has_client_type() const {
  return _internal_has_client_type();
}
inline void DeviceTokenReq::clear_client_type() {
  _impl_.client_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::Bohan::BaseDefine::ClientType DeviceTokenReq::_internal_client_type() const {
  return static_cast< ::Bohan::BaseDefine::ClientType >(_impl_.client_type_);
}
inline ::Bohan::BaseDefine::ClientType DeviceTokenReq::client_type() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenReq.client_type)
  return _internal_client_type();
}
inline void DeviceTokenReq::_internal_set_client_type(::Bohan::BaseDefine::ClientType value) {
  assert(::Bohan::BaseDefine::ClientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.client_type_ = value;
}
inline void DeviceTokenReq::set_client_type(::Bohan::BaseDefine::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenReq.client_type)
}

// optional bytes attach_data = 20;
inline bool DeviceTokenReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceTokenReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void DeviceTokenReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceTokenReq::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceTokenReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenReq.attach_data)
}
inline std::string* DeviceTokenReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.DeviceTokenReq.attach_data)
  return _s;
}
inline const std::string& DeviceTokenReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void DeviceTokenReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceTokenReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Login.DeviceTokenReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceTokenReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.DeviceTokenReq.attach_data)
}

// -------------------------------------------------------------------

// DeviceTokenRsp

// required bytes user_id = 1;
inline bool DeviceTokenRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceTokenRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void DeviceTokenRsp::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceTokenRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenRsp.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceTokenRsp::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenRsp.user_id)
}
inline std::string* DeviceTokenRsp::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.DeviceTokenRsp.user_id)
  return _s;
}
inline const std::string& DeviceTokenRsp::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void DeviceTokenRsp::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceTokenRsp::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceTokenRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.DeviceTokenRsp.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceTokenRsp::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.DeviceTokenRsp.user_id)
}

// optional bytes attach_data = 20;
inline bool DeviceTokenRsp::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceTokenRsp::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void DeviceTokenRsp::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceTokenRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.DeviceTokenRsp.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceTokenRsp::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.DeviceTokenRsp.attach_data)
}
inline std::string* DeviceTokenRsp::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.DeviceTokenRsp.attach_data)
  return _s;
}
inline const std::string& DeviceTokenRsp::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void DeviceTokenRsp::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceTokenRsp::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceTokenRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:Bohan.Login.DeviceTokenRsp.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceTokenRsp::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.DeviceTokenRsp.attach_data)
}

// -------------------------------------------------------------------

// KickPCClientReq

// required bytes user_id = 1;
inline bool KickPCClientReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickPCClientReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void KickPCClientReq::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KickPCClientReq::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.KickPCClientReq.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPCClientReq::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.KickPCClientReq.user_id)
}
inline std::string* KickPCClientReq::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.KickPCClientReq.user_id)
  return _s;
}
inline const std::string& KickPCClientReq::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void KickPCClientReq::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KickPCClientReq::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KickPCClientReq::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.KickPCClientReq.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPCClientReq::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.KickPCClientReq.user_id)
}

// -------------------------------------------------------------------

// KickPCClientRsp

// required bytes user_id = 1;
inline bool KickPCClientRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickPCClientRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void KickPCClientRsp::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KickPCClientRsp::user_id() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.KickPCClientRsp.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPCClientRsp::set_user_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Bohan.Login.KickPCClientRsp.user_id)
}
inline std::string* KickPCClientRsp::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:Bohan.Login.KickPCClientRsp.user_id)
  return _s;
}
inline const std::string& KickPCClientRsp::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void KickPCClientRsp::_internal_set_user_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* KickPCClientRsp::_internal_mutable_user_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* KickPCClientRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:Bohan.Login.KickPCClientRsp.user_id)
  if (!_internal_has_user_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KickPCClientRsp::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Bohan.Login.KickPCClientRsp.user_id)
}

// required uint32 result_code = 2;
inline bool KickPCClientRsp::_internal_has_result_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickPCClientRsp::has_result_code() const {
  return _internal_has_result_code();
}
inline void KickPCClientRsp::clear_result_code() {
  _impl_.result_code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KickPCClientRsp::_internal_result_code() const {
  return _impl_.result_code_;
}
inline uint32_t KickPCClientRsp::result_code() const {
  // @@protoc_insertion_point(field_get:Bohan.Login.KickPCClientRsp.result_code)
  return _internal_result_code();
}
inline void KickPCClientRsp::_internal_set_result_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_code_ = value;
}
inline void KickPCClientRsp::set_result_code(uint32_t value) {
  _internal_set_result_code(value);
  // @@protoc_insertion_point(field_set:Bohan.Login.KickPCClientRsp.result_code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Login
}  // namespace Bohan

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
